<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DL之路---啃鱼书（3）</title>
      <link href="/2025/06/15/22/"/>
      <url>/2025/06/15/22/</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络的学习"><a href="#神经网络的学习" class="headerlink" title="神经网络的学习"></a>神经网络的学习</h1><h3 id="从数据中学习"><a href="#从数据中学习" class="headerlink" title="从数据中学习"></a>从数据中学习</h3><blockquote><h4 id="所谓的学习就是从训练数据中自动获取最优权重参数的过程"><a href="#所谓的学习就是从训练数据中自动获取最优权重参数的过程" class="headerlink" title="所谓的学习就是从训练数据中自动获取最优权重参数的过程"></a>所谓的学习就是从训练数据中自动获取最优权重参数的过程</h4><h4 id="为了使神经网络能够学习，引入了损失函数这一指标，而学习的目标就是以损失函数为基准，找出使它的值达到最小的权重参数（函数斜率的梯度法）"><a href="#为了使神经网络能够学习，引入了损失函数这一指标，而学习的目标就是以损失函数为基准，找出使它的值达到最小的权重参数（函数斜率的梯度法）" class="headerlink" title="为了使神经网络能够学习，引入了损失函数这一指标，而学习的目标就是以损失函数为基准，找出使它的值达到最小的权重参数（函数斜率的梯度法）"></a>为了使神经网络能够学习，引入了损失函数这一指标，而学习的目标就是以损失函数为基准，找出使它的值达到最小的权重参数（函数斜率的梯度法）</h4><h4 id="特征量：是指可以从输入数据（输入图像）中准确地提取出本质数据（重要数据）的转换器（图像的特征量通常表示为向量形式），但特征量的选取是人为选择的，还是存在人为因素的介入"><a href="#特征量：是指可以从输入数据（输入图像）中准确地提取出本质数据（重要数据）的转换器（图像的特征量通常表示为向量形式），但特征量的选取是人为选择的，还是存在人为因素的介入" class="headerlink" title="特征量：是指可以从输入数据（输入图像）中准确地提取出本质数据（重要数据）的转换器（图像的特征量通常表示为向量形式），但特征量的选取是人为选择的，还是存在人为因素的介入"></a>特征量：是指可以从输入数据（输入图像）中准确地提取出本质数据（重要数据）的转换器（图像的特征量通常表示为向量形式），但特征量的选取是人为选择的，还是存在人为因素的介入</h4><h4 id="深度学习也被称为端到端机器学习（end-to-end-machine-learning），从原始数据（输入）中获得目标结果（输出）"><a href="#深度学习也被称为端到端机器学习（end-to-end-machine-learning），从原始数据（输入）中获得目标结果（输出）" class="headerlink" title="深度学习也被称为端到端机器学习（end-to-end machine learning），从原始数据（输入）中获得目标结果（输出）"></a>深度学习也被称为端到端机器学习（end-to-end machine learning），从原始数据（输入）中获得目标结果（输出）</h4><h4 id="神经网络的优点是对所有的问题都可以使用同样的流程来解决，与待处理的问题无关，它可以将数据直接作为原始数据，进行端到端学习"><a href="#神经网络的优点是对所有的问题都可以使用同样的流程来解决，与待处理的问题无关，它可以将数据直接作为原始数据，进行端到端学习" class="headerlink" title="神经网络的优点是对所有的问题都可以使用同样的流程来解决，与待处理的问题无关，它可以将数据直接作为原始数据，进行端到端学习"></a>神经网络的优点是对所有的问题都可以使用同样的流程来解决，与待处理的问题无关，它可以将数据直接作为原始数据，进行端到端学习</h4><h4 id="在机器学习中，一般将数据分为训练数据和测试数据两部分来进行学习和实验，首先使用训练数据进行学习，寻找最优参数，再使用测试数据评价训练得到的模型的实际能力"><a href="#在机器学习中，一般将数据分为训练数据和测试数据两部分来进行学习和实验，首先使用训练数据进行学习，寻找最优参数，再使用测试数据评价训练得到的模型的实际能力" class="headerlink" title="在机器学习中，一般将数据分为训练数据和测试数据两部分来进行学习和实验，首先使用训练数据进行学习，寻找最优参数，再使用测试数据评价训练得到的模型的实际能力"></a>在机器学习中，一般将数据分为训练数据和测试数据两部分来进行学习和实验，首先使用训练数据进行学习，寻找最优参数，再使用测试数据评价训练得到的模型的实际能力</h4><h4 id="划分为训练数据和测试数据（也称为监督数据）是为了追求“泛化能力”"><a href="#划分为训练数据和测试数据（也称为监督数据）是为了追求“泛化能力”" class="headerlink" title="划分为训练数据和测试数据（也称为监督数据）是为了追求“泛化能力”"></a>划分为训练数据和测试数据（也称为监督数据）是为了追求“泛化能力”</h4><h4 id="泛化能力：是指处理未被观察过的数据（不包含在训练数据中的数据）的能力"><a href="#泛化能力：是指处理未被观察过的数据（不包含在训练数据中的数据）的能力" class="headerlink" title="泛化能力：是指处理未被观察过的数据（不包含在训练数据中的数据）的能力"></a>泛化能力：是指处理未被观察过的数据（不包含在训练数据中的数据）的能力</h4><h4 id="获得泛化能力是机器学习的最终目标"><a href="#获得泛化能力是机器学习的最终目标" class="headerlink" title="获得泛化能力是机器学习的最终目标"></a>获得泛化能力是机器学习的最终目标</h4><h4 id="过拟合：它是指只对某个数据集过度拟合的状态"><a href="#过拟合：它是指只对某个数据集过度拟合的状态" class="headerlink" title="过拟合：它是指只对某个数据集过度拟合的状态"></a>过拟合：它是指只对某个数据集过度拟合的状态</h4></blockquote><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><blockquote><h4 id="神经网络的学习通过某个指标表示现在的状态，再以这个指标为基准，寻找最优权重参数，而这个指标就是损失函数"><a href="#神经网络的学习通过某个指标表示现在的状态，再以这个指标为基准，寻找最优权重参数，而这个指标就是损失函数" class="headerlink" title="神经网络的学习通过某个指标表示现在的状态，再以这个指标为基准，寻找最优权重参数，而这个指标就是损失函数"></a>神经网络的学习通过某个指标表示现在的状态，再以这个指标为基准，寻找最优权重参数，而这个指标就是损失函数</h4><h4 id="损失函数可以使用任何函数，但一般使用的是均方误差和交叉熵误差"><a href="#损失函数可以使用任何函数，但一般使用的是均方误差和交叉熵误差" class="headerlink" title="损失函数可以使用任何函数，但一般使用的是均方误差和交叉熵误差"></a>损失函数可以使用任何函数，但一般使用的是均方误差和交叉熵误差</h4><h4 id="损失函数是表示神经网络性能好坏的指标，它反映了当前的神经网络对监督数据的拟合程度"><a href="#损失函数是表示神经网络性能好坏的指标，它反映了当前的神经网络对监督数据的拟合程度" class="headerlink" title="损失函数是表示神经网络性能好坏的指标，它反映了当前的神经网络对监督数据的拟合程度"></a>损失函数是表示神经网络性能好坏的指标，它反映了当前的神经网络对监督数据的拟合程度</h4><h4 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h4><blockquote><h4 id="其表达式如下："><a href="#其表达式如下：" class="headerlink" title="其表达式如下："></a>其表达式如下：</h4><p>$$<br>E &#x3D; \frac{1}{2} \sum_{k} (y_k - t_k)^2<br>$$</p><h4 id="其中，-y-k-是表示神经网络的输出，-t-k-表示监督数据（测试数据），-k-表示数据的维数"><a href="#其中，-y-k-是表示神经网络的输出，-t-k-表示监督数据（测试数据），-k-表示数据的维数" class="headerlink" title="其中，$y_k$ 是表示神经网络的输出，$t_k$ 表示监督数据（测试数据），$k$ 表示数据的维数"></a>其中，$y_k$ 是表示神经网络的输出，$t_k$ 表示监督数据（测试数据），$k$ 表示数据的维数</h4><h4 id="题外话：均方误差式子的一个特点就是，其名中的4个字与式子中皆有对应，均-对应式子中的-frac-1-2-，方-对应式子中的-2-，误差-对应式子中的-y-k-t-k"><a href="#题外话：均方误差式子的一个特点就是，其名中的4个字与式子中皆有对应，均-对应式子中的-frac-1-2-，方-对应式子中的-2-，误差-对应式子中的-y-k-t-k" class="headerlink" title="题外话：均方误差式子的一个特点就是，其名中的4个字与式子中皆有对应，均 对应式子中的 $\frac{1}{2}$ ，方 对应式子中的 $()^2$ ，误差 对应式子中的 $ y_k - t_k $"></a>题外话：均方误差式子的一个特点就是，其名中的4个字与式子中皆有对应，均 对应式子中的 $\frac{1}{2}$ ，方 对应式子中的 $()^2$ ，误差 对应式子中的 $ y_k - t_k $</h4></blockquote><h4 id="交叉熵误差"><a href="#交叉熵误差" class="headerlink" title="交叉熵误差"></a>交叉熵误差</h4><blockquote><h4 id="其表达式如下：-1"><a href="#其表达式如下：-1" class="headerlink" title="其表达式如下："></a>其表达式如下：</h4><p>$$<br>E &#x3D; - \sum_{k} t_k \log y_k<br>$$</p><h4 id="其中，-y-k-是表示神经网络的输出，-t-k-是正确解标签，且-t-k-中只有正确解标签的索引为1，其余的都是0-one-hot表示"><a href="#其中，-y-k-是表示神经网络的输出，-t-k-是正确解标签，且-t-k-中只有正确解标签的索引为1，其余的都是0-one-hot表示" class="headerlink" title="其中，$y_k$ 是表示神经网络的输出，$t_k$ 是正确解标签，且 $t_k$ 中只有正确解标签的索引为1，其余的都是0(one-hot表示)"></a>其中，$y_k$ 是表示神经网络的输出，$t_k$ 是正确解标签，且 $t_k$ 中只有正确解标签的索引为1，其余的都是0(one-hot表示)</h4><h4 id="所以说，实际上交叉熵误差式子只计算对应正确解标签的输出的自然对数，交叉熵误差的值是由正确解标签所对应的输出结果决定的"><a href="#所以说，实际上交叉熵误差式子只计算对应正确解标签的输出的自然对数，交叉熵误差的值是由正确解标签所对应的输出结果决定的" class="headerlink" title="所以说，实际上交叉熵误差式子只计算对应正确解标签的输出的自然对数，交叉熵误差的值是由正确解标签所对应的输出结果决定的"></a>所以说，实际上交叉熵误差式子只计算对应正确解标签的输出的自然对数，交叉熵误差的值是由正确解标签所对应的输出结果决定的</h4><h4 id="正确解标签对应的输出越大，交叉熵误差的值就越接近0，反之则越大，输出为1时，交叉熵误差为0，log函数图像如下"><a href="#正确解标签对应的输出越大，交叉熵误差的值就越接近0，反之则越大，输出为1时，交叉熵误差为0，log函数图像如下" class="headerlink" title="正确解标签对应的输出越大，交叉熵误差的值就越接近0，反之则越大，输出为1时，交叉熵误差为0，log函数图像如下"></a>正确解标签对应的输出越大，交叉熵误差的值就越接近0，反之则越大，输出为1时，交叉熵误差为0，log函数图像如下</h4><p><img src="http://picbed.yanzu.tech/img/DL/3/1.png"></p></blockquote><h4 id="mini-batch学习"><a href="#mini-batch学习" class="headerlink" title="mini-batch学习"></a>mini-batch学习</h4><blockquote><h4 id="机器学习使用训练数据进行学习，其本质就是针对训练数据计算损失函数的值，找出使该值尽可能小的参数，所以计算损失函数时必须将所有的训练数据作为对象"><a href="#机器学习使用训练数据进行学习，其本质就是针对训练数据计算损失函数的值，找出使该值尽可能小的参数，所以计算损失函数时必须将所有的训练数据作为对象" class="headerlink" title="机器学习使用训练数据进行学习，其本质就是针对训练数据计算损失函数的值，找出使该值尽可能小的参数，所以计算损失函数时必须将所有的训练数据作为对象"></a>机器学习使用训练数据进行学习，其本质就是针对训练数据计算损失函数的值，找出使该值尽可能小的参数，所以计算损失函数时必须将所有的训练数据作为对象</h4><h4 id="前面提到的损失函数都是针对的单个数据，若要求所有的训练数据的损失函数的总和，以交叉熵误差为例，损失函数可以写为："><a href="#前面提到的损失函数都是针对的单个数据，若要求所有的训练数据的损失函数的总和，以交叉熵误差为例，损失函数可以写为：" class="headerlink" title="前面提到的损失函数都是针对的单个数据，若要求所有的训练数据的损失函数的总和，以交叉熵误差为例，损失函数可以写为："></a>前面提到的损失函数都是针对的单个数据，若要求所有的训练数据的损失函数的总和，以交叉熵误差为例，损失函数可以写为：</h4><p>$$<br>E &#x3D; - \frac{1}{N} \sum_{n} \sum_{k} t_{nk} \log y_{nk}<br>$$</p><h4 id="这里是假设有-N-个数据，-t-nk-表示第-n-个数据的第-k-个元素的值，-t-nk-是监督数据，-t-nk-是神经网络的输出"><a href="#这里是假设有-N-个数据，-t-nk-表示第-n-个数据的第-k-个元素的值，-t-nk-是监督数据，-t-nk-是神经网络的输出" class="headerlink" title="这里是假设有$N$个数据，$t_{nk}$ 表示第 $n$ 个数据的第 $k$ 个元素的值，$t_{nk}$ 是监督数据，$t_{nk}$ 是神经网络的输出"></a>这里是假设有$N$个数据，$t_{nk}$ 表示第 $n$ 个数据的第 $k$ 个元素的值，$t_{nk}$ 是监督数据，$t_{nk}$ 是神经网络的输出</h4><h4 id="通过除以-N-（正规化），可以求单个数据的平均损失函数，这样的平均化，可以获得和训练数据的数量无关的统一指标"><a href="#通过除以-N-（正规化），可以求单个数据的平均损失函数，这样的平均化，可以获得和训练数据的数量无关的统一指标" class="headerlink" title="通过除以 $N$ （正规化），可以求单个数据的平均损失函数，这样的平均化，可以获得和训练数据的数量无关的统一指标"></a>通过除以 $N$ （正规化），可以求单个数据的平均损失函数，这样的平均化，可以获得和训练数据的数量无关的统一指标</h4><h4 id="如果将全部的训练数据作为对象求损失函数的总和，那这个计算过程会是非常漫长的，训练数据量非常庞大时，以全部训练数据作为对象计算损失函数更是不现实的"><a href="#如果将全部的训练数据作为对象求损失函数的总和，那这个计算过程会是非常漫长的，训练数据量非常庞大时，以全部训练数据作为对象计算损失函数更是不现实的" class="headerlink" title="如果将全部的训练数据作为对象求损失函数的总和，那这个计算过程会是非常漫长的，训练数据量非常庞大时，以全部训练数据作为对象计算损失函数更是不现实的"></a>如果将全部的训练数据作为对象求损失函数的总和，那这个计算过程会是非常漫长的，训练数据量非常庞大时，以全部训练数据作为对象计算损失函数更是不现实的</h4><h4 id="因此，从全部训练数据中选择一部分，作为全部训练数据的“近似”"><a href="#因此，从全部训练数据中选择一部分，作为全部训练数据的“近似”" class="headerlink" title="因此，从全部训练数据中选择一部分，作为全部训练数据的“近似”"></a>因此，从全部训练数据中选择一部分，作为全部训练数据的“近似”</h4><h4 id="神经网络的学习也是从训练数据中选出一批数据（称为mini-batch-小批量），然后对每个mini-batch进行学习，用这一批数据的结果来近似全部数据的结果，这种学习方式就是所谓的-mini-batch学习"><a href="#神经网络的学习也是从训练数据中选出一批数据（称为mini-batch-小批量），然后对每个mini-batch进行学习，用这一批数据的结果来近似全部数据的结果，这种学习方式就是所谓的-mini-batch学习" class="headerlink" title="神经网络的学习也是从训练数据中选出一批数据（称为mini-batch,小批量），然后对每个mini-batch进行学习，用这一批数据的结果来近似全部数据的结果，这种学习方式就是所谓的 mini-batch学习"></a>神经网络的学习也是从训练数据中选出一批数据（称为mini-batch,小批量），然后对每个mini-batch进行学习，用这一批数据的结果来近似全部数据的结果，这种学习方式就是所谓的 <strong>mini-batch学习</strong></h4></blockquote><h4 id="为什么要引入损失函数"><a href="#为什么要引入损失函数" class="headerlink" title="为什么要引入损失函数"></a>为什么要引入损失函数</h4><blockquote><h4 id="为了找到使损失函数的值尽可能小的地方，需要计算参数的导数（确切地讲是梯度），然后以这个导数为指引，逐步更新参数的值"><a href="#为了找到使损失函数的值尽可能小的地方，需要计算参数的导数（确切地讲是梯度），然后以这个导数为指引，逐步更新参数的值" class="headerlink" title="为了找到使损失函数的值尽可能小的地方，需要计算参数的导数（确切地讲是梯度），然后以这个导数为指引，逐步更新参数的值"></a>为了找到使损失函数的值尽可能小的地方，需要计算参数的导数（确切地讲是梯度），然后以这个导数为指引，逐步更新参数的值</h4><h4 id="损失函数的导数一般不会有0值，更不会恒为0（阶跃函数除外），而识别精度的导数恒为0或者只有极小部分不为0，这样权重的调整并不会影响其值，这并不是我们想要的"><a href="#损失函数的导数一般不会有0值，更不会恒为0（阶跃函数除外），而识别精度的导数恒为0或者只有极小部分不为0，这样权重的调整并不会影响其值，这并不是我们想要的" class="headerlink" title="损失函数的导数一般不会有0值，更不会恒为0（阶跃函数除外），而识别精度的导数恒为0或者只有极小部分不为0，这样权重的调整并不会影响其值，这并不是我们想要的"></a>损失函数的导数一般不会有0值，更不会恒为0（阶跃函数除外），而识别精度的导数恒为0或者只有极小部分不为0，这样权重的调整并不会影响其值，这并不是我们想要的</h4></blockquote></blockquote><h3 id="数值微分（数值梯度）"><a href="#数值微分（数值梯度）" class="headerlink" title="数值微分（数值梯度）"></a>数值微分（数值梯度）</h3><blockquote><h4 id="梯度法使用梯度的信息决定前进的方向"><a href="#梯度法使用梯度的信息决定前进的方向" class="headerlink" title="梯度法使用梯度的信息决定前进的方向"></a>梯度法使用梯度的信息决定前进的方向</h4><h4 id="利用微小的差分求导数的过程就是所谓的数值微分（numerical-differentiation）"><a href="#利用微小的差分求导数的过程就是所谓的数值微分（numerical-differentiation）" class="headerlink" title="利用微小的差分求导数的过程就是所谓的数值微分（numerical differentiation）"></a>利用微小的差分求导数的过程就是所谓的数值微分（numerical differentiation）</h4><h4 id="基于数学式的推到求导数的过程，则称之为-解析性求解或解析性求导"><a href="#基于数学式的推到求导数的过程，则称之为-解析性求解或解析性求导" class="headerlink" title="基于数学式的推到求导数的过程，则称之为 解析性求解或解析性求导"></a>基于数学式的推到求导数的过程，则称之为 解析性求解或解析性求导</h4></blockquote><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><blockquote><h4 id="由全部变量的偏导数汇总成的向量称为梯度"><a href="#由全部变量的偏导数汇总成的向量称为梯度" class="headerlink" title="由全部变量的偏导数汇总成的向量称为梯度"></a>由全部变量的偏导数汇总成的向量称为梯度</h4><h4 id="梯度法"><a href="#梯度法" class="headerlink" title="梯度法"></a>梯度法</h4><blockquote><h4 id="寻找的最优参数是指损失函数取最小值时的参数"><a href="#寻找的最优参数是指损失函数取最小值时的参数" class="headerlink" title="寻找的最优参数是指损失函数取最小值时的参数"></a>寻找的最优参数是指损失函数取最小值时的参数</h4><h4 id="使用梯度来寻找损失函数最小值的方法就是所谓的-梯度法，通过不断地沿梯度方向前进，逐渐减小函数值的过程就是梯度法"><a href="#使用梯度来寻找损失函数最小值的方法就是所谓的-梯度法，通过不断地沿梯度方向前进，逐渐减小函数值的过程就是梯度法" class="headerlink" title="使用梯度来寻找损失函数最小值的方法就是所谓的 梯度法，通过不断地沿梯度方向前进，逐渐减小函数值的过程就是梯度法"></a>使用梯度来寻找损失函数最小值的方法就是所谓的 梯度法，通过不断地沿梯度方向前进，逐渐减小函数值的过程就是梯度法</h4><h4 id="梯度表示的各点处的函数值减小最多的方向"><a href="#梯度表示的各点处的函数值减小最多的方向" class="headerlink" title="梯度表示的各点处的函数值减小最多的方向"></a>梯度表示的各点处的函数值减小最多的方向</h4><h4 id="函数最小值、极小值和鞍点处的梯度为-0（梯度法就是要找梯度为0的地方）"><a href="#函数最小值、极小值和鞍点处的梯度为-0（梯度法就是要找梯度为0的地方）" class="headerlink" title="函数最小值、极小值和鞍点处的梯度为 0（梯度法就是要找梯度为0的地方）"></a>函数最小值、极小值和鞍点处的梯度为 0（梯度法就是要找梯度为0的地方）</h4><h4 id="极小值是局部最小值，鞍点是从某个方向上看是极大值，从另一个方向看是极小值的点"><a href="#极小值是局部最小值，鞍点是从某个方向上看是极大值，从另一个方向看是极小值的点" class="headerlink" title="极小值是局部最小值，鞍点是从某个方向上看是极大值，从另一个方向看是极小值的点"></a>极小值是局部最小值，鞍点是从某个方向上看是极大值，从另一个方向看是极小值的点</h4><h4 id="学习高原：它是指，当函数很复杂且呈扁平状时，学习可能会进入一个（几乎）平坦的地区，陷入所谓的学习高原而无法前进的停滞期"><a href="#学习高原：它是指，当函数很复杂且呈扁平状时，学习可能会进入一个（几乎）平坦的地区，陷入所谓的学习高原而无法前进的停滞期" class="headerlink" title="学习高原：它是指，当函数很复杂且呈扁平状时，学习可能会进入一个（几乎）平坦的地区，陷入所谓的学习高原而无法前进的停滞期"></a>学习高原：它是指，当函数很复杂且呈扁平状时，学习可能会进入一个（几乎）平坦的地区，陷入所谓的<strong>学习高原</strong>而无法前进的停滞期</h4><h4 id="根据寻找目的（最大值或最小值）的不同，梯度法分为了：梯度下降法和梯度上升法"><a href="#根据寻找目的（最大值或最小值）的不同，梯度法分为了：梯度下降法和梯度上升法" class="headerlink" title="根据寻找目的（最大值或最小值）的不同，梯度法分为了：梯度下降法和梯度上升法"></a>根据寻找目的（最大值或最小值）的不同，梯度法分为了：梯度下降法和梯度上升法</h4><ul><li><h4 id="梯度下降法：寻找最小值的梯度法"><a href="#梯度下降法：寻找最小值的梯度法" class="headerlink" title="梯度下降法：寻找最小值的梯度法"></a>梯度下降法：寻找最小值的梯度法</h4></li><li><h4 id="梯度上升法：寻找最大值的梯度法"><a href="#梯度上升法：寻找最大值的梯度法" class="headerlink" title="梯度上升法：寻找最大值的梯度法"></a>梯度上升法：寻找最大值的梯度法</h4></li></ul><h4 id="通过反转损失函数的符号，求最小值和求最大值的问题可以变成相同的问题"><a href="#通过反转损失函数的符号，求最小值和求最大值的问题可以变成相同的问题" class="headerlink" title="通过反转损失函数的符号，求最小值和求最大值的问题可以变成相同的问题"></a>通过反转损失函数的符号，求最小值和求最大值的问题可以变成相同的问题</h4><h4 id="神经网络（深度学习）中，梯度法一般是指的梯度下降法"><a href="#神经网络（深度学习）中，梯度法一般是指的梯度下降法" class="headerlink" title="神经网络（深度学习）中，梯度法一般是指的梯度下降法"></a>神经网络（深度学习）中，梯度法一般是指的梯度下降法</h4><h4 id="学习率决定在一次学习中，应该学习多少，以及在多大程度上更新参数"><a href="#学习率决定在一次学习中，应该学习多少，以及在多大程度上更新参数" class="headerlink" title="学习率决定在一次学习中，应该学习多少，以及在多大程度上更新参数"></a>学习率决定在一次学习中，应该学习多少，以及在多大程度上更新参数</h4><h4 id="在神经网络的学习中，一般会一边改变学习率的值，一边确认学习是否正确进行了"><a href="#在神经网络的学习中，一般会一边改变学习率的值，一边确认学习是否正确进行了" class="headerlink" title="在神经网络的学习中，一般会一边改变学习率的值，一边确认学习是否正确进行了"></a>在神经网络的学习中，一般会一边改变学习率的值，一边确认学习是否正确进行了</h4><h4 id="学习率这样的参数也被称为超参数，需要人工设定"><a href="#学习率这样的参数也被称为超参数，需要人工设定" class="headerlink" title="学习率这样的参数也被称为超参数，需要人工设定"></a>学习率这样的参数也被称为<strong>超参数</strong>，需要人工设定</h4></blockquote><h4 id="神经网络的梯度"><a href="#神经网络的梯度" class="headerlink" title="神经网络的梯度"></a>神经网络的梯度</h4><blockquote><h4 id="这里的梯度指的是损失函数关于权重参数的梯度"><a href="#这里的梯度指的是损失函数关于权重参数的梯度" class="headerlink" title="这里的梯度指的是损失函数关于权重参数的梯度"></a>这里的梯度指的是损失函数关于权重参数的梯度</h4><h4 id="例子说明，一个神经网络的权重W形状为-2x3，损失函数用L表示，此时梯度可以用-frac-partial-L-partial-W-来表示，数学表示式如下"><a href="#例子说明，一个神经网络的权重W形状为-2x3，损失函数用L表示，此时梯度可以用-frac-partial-L-partial-W-来表示，数学表示式如下" class="headerlink" title="例子说明，一个神经网络的权重W形状为 2x3，损失函数用L表示，此时梯度可以用 $\frac{\partial L}{\partial W}$ 来表示，数学表示式如下"></a>例子说明，一个神经网络的权重W形状为 2x3，损失函数用L表示，此时梯度可以用 $\frac{\partial L}{\partial W}$ 来表示，数学表示式如下</h4><p><img src="http://picbed.yanzu.tech/img/DL/3/2.png"></p><h4 id="求出神经网络的梯度后，接下来只需根据梯度法，更新权重参数即可"><a href="#求出神经网络的梯度后，接下来只需根据梯度法，更新权重参数即可" class="headerlink" title="求出神经网络的梯度后，接下来只需根据梯度法，更新权重参数即可"></a>求出神经网络的梯度后，接下来只需根据梯度法，更新权重参数即可</h4></blockquote><h4 id="学习算法的实现"><a href="#学习算法的实现" class="headerlink" title="学习算法的实现"></a>学习算法的实现</h4><blockquote><h4 id="神经网络的学习的步骤"><a href="#神经网络的学习的步骤" class="headerlink" title="神经网络的学习的步骤"></a>神经网络的学习的步骤</h4><blockquote><h4 id="前提是：神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为“学习”"><a href="#前提是：神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为“学习”" class="headerlink" title="前提是：神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为“学习”"></a>前提是：神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为“学习”</h4><ol><li><h4 id="（mini-batch）从训练数据中随机选出一部分数据，这部分数据称为mini-batch，目标是是减小mini-batch的损失函数的值"><a href="#（mini-batch）从训练数据中随机选出一部分数据，这部分数据称为mini-batch，目标是是减小mini-batch的损失函数的值" class="headerlink" title="（mini-batch）从训练数据中随机选出一部分数据，这部分数据称为mini-batch，目标是是减小mini-batch的损失函数的值"></a>（mini-batch）从训练数据中随机选出一部分数据，这部分数据称为mini-batch，目标是是减小mini-batch的损失函数的值</h4></li><li><h4 id="（计算梯度）为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度，梯度表示损失函数的值减小最多的方向"><a href="#（计算梯度）为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度，梯度表示损失函数的值减小最多的方向" class="headerlink" title="（计算梯度）为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度，梯度表示损失函数的值减小最多的方向"></a>（计算梯度）为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度，梯度表示损失函数的值减小最多的方向</h4></li><li><h4 id="（更新参数）将权重参数沿梯度方向进行微小更新"><a href="#（更新参数）将权重参数沿梯度方向进行微小更新" class="headerlink" title="（更新参数）将权重参数沿梯度方向进行微小更新"></a>（更新参数）将权重参数沿梯度方向进行微小更新</h4></li><li><h4 id="（重复）重复前三步"><a href="#（重复）重复前三步" class="headerlink" title="（重复）重复前三步"></a>（重复）重复前三步</h4></li></ol><h4 id="因为更新权重参数采用的梯度法是梯度下降法，又是随机选择的mini-batch数据，所以称之为随机梯度下降法（stochastic-gradient-descent，SGD）"><a href="#因为更新权重参数采用的梯度法是梯度下降法，又是随机选择的mini-batch数据，所以称之为随机梯度下降法（stochastic-gradient-descent，SGD）" class="headerlink" title="因为更新权重参数采用的梯度法是梯度下降法，又是随机选择的mini-batch数据，所以称之为随机梯度下降法（stochastic gradient descent，SGD）"></a>因为更新权重参数采用的梯度法是梯度下降法，又是随机选择的mini-batch数据，所以称之为随机梯度下降法（stochastic gradient descent，SGD）</h4></blockquote><h4 id="手写数字识别的神经网络的实现"><a href="#手写数字识别的神经网络的实现" class="headerlink" title="手写数字识别的神经网络的实现"></a>手写数字识别的神经网络的实现</h4><h4 id="基于测试数据的评价"><a href="#基于测试数据的评价" class="headerlink" title="基于测试数据的评价"></a>基于测试数据的评价</h4><blockquote><h4 id="神经网络的学习中，必须确认是否能够正确识别训练数据以外的其他数-据，即确认是否会发生过拟合"><a href="#神经网络的学习中，必须确认是否能够正确识别训练数据以外的其他数-据，即确认是否会发生过拟合" class="headerlink" title="神经网络的学习中，必须确认是否能够正确识别训练数据以外的其他数 据，即确认是否会发生过拟合"></a>神经网络的学习中，必须确认是否能够正确识别训练数据以外的其他数 据，即确认是否会发生过拟合</h4><h4 id="过拟合是指，虽然训练数据中的数字图像能被正确辨别，但是不在训练数据中的数字图像却无法被识别的现象"><a href="#过拟合是指，虽然训练数据中的数字图像能被正确辨别，但是不在训练数据中的数字图像却无法被识别的现象" class="headerlink" title="过拟合是指，虽然训练数据中的数字图像能被正确辨别，但是不在训练数据中的数字图像却无法被识别的现象"></a>过拟合是指，虽然训练数据中的数字图像能被正确辨别，但是不在训练数据中的数字图像却无法被识别的现象</h4><h4 id="要评价神经网络的泛化能力，就必须使用不包含在训练数据中的数据，这就要用到测试数据了"><a href="#要评价神经网络的泛化能力，就必须使用不包含在训练数据中的数据，这就要用到测试数据了" class="headerlink" title="要评价神经网络的泛化能力，就必须使用不包含在训练数据中的数据，这就要用到测试数据了"></a>要评价神经网络的泛化能力，就必须使用不包含在训练数据中的数据，这就要用到测试数据了</h4><h4 id="另外又引入了一个新的概念——epoch"><a href="#另外又引入了一个新的概念——epoch" class="headerlink" title="另外又引入了一个新的概念——epoch"></a>另外又引入了一个新的概念——epoch</h4><blockquote><h4 id="epoch是一个单位，一个epoch表示学习中所有训练数据均被使用过一次时的更新次数"><a href="#epoch是一个单位，一个epoch表示学习中所有训练数据均被使用过一次时的更新次数" class="headerlink" title="epoch是一个单位，一个epoch表示学习中所有训练数据均被使用过一次时的更新次数"></a>epoch是一个单位，一个epoch表示学习中所有训练数据均被使用过一次时的更新次数</h4><h4 id="如，对于10000笔训练数据，用大小为-100-笔数据的mini-batch进行学习时，重复随机梯度下降法-100次，所有的训练数据就都被“看过”了，此时，100次就是一个-epoch"><a href="#如，对于10000笔训练数据，用大小为-100-笔数据的mini-batch进行学习时，重复随机梯度下降法-100次，所有的训练数据就都被“看过”了，此时，100次就是一个-epoch" class="headerlink" title="如，对于10000笔训练数据，用大小为 100 笔数据的mini-batch进行学习时，重复随机梯度下降法 100次，所有的训练数据就都被“看过”了，此时，100次就是一个 epoch"></a>如，对于10000笔训练数据，用大小为 100 笔数据的mini-batch进行学习时，重复随机梯度下降法 100次，所有的训练数据就都被“看过”了，此时，100次就是一个 epoch</h4><h4 id="遍历一次所有数据，就成为一个epoch"><a href="#遍历一次所有数据，就成为一个epoch" class="headerlink" title="遍历一次所有数据，就成为一个epoch"></a>遍历一次所有数据，就成为一个epoch</h4></blockquote></blockquote></blockquote></blockquote><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><blockquote><h4 id="均方误差的实现"><a href="#均方误差的实现" class="headerlink" title="均方误差的实现"></a>均方误差的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mean_squared_error</span>(<span class="params">y, t</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * np.<span class="built_in">sum</span>((y - t)**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设2为正确解</span></span><br><span class="line">t = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">y = np.array([<span class="number">0.1</span>, <span class="number">0.05</span>, <span class="number">0.6</span>, <span class="number">0.0</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>])</span><br><span class="line">result = mean_squared_error(y, t)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">y = np.array([<span class="number">0.1</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>, <span class="number">0.0</span>])</span><br><span class="line">result_ = mean_squared_error(y, t)</span><br><span class="line"><span class="built_in">print</span>(result_)</span><br></pre></td></tr></table></figure><h4 id="交叉熵误差的实现"><a href="#交叉熵误差的实现" class="headerlink" title="交叉熵误差的实现"></a>交叉熵误差的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy_error</span>(<span class="params">y, t</span>):</span><br><span class="line"><span class="comment"># 加上delta是为了避免出现 log(0)，导致出现负无穷</span></span><br><span class="line">delta = <span class="number">1e-7</span></span><br><span class="line"><span class="keyword">return</span> -np.<span class="built_in">sum</span>(t * np.log(y + delta))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">y = np.array([<span class="number">0.1</span>, <span class="number">0.05</span>, <span class="number">0.6</span>, <span class="number">0.0</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>])</span><br><span class="line">result = cross_entropy_error(y, t)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">y = np.array([<span class="number">0.1</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>, <span class="number">0.0</span>])</span><br><span class="line">result_ = cross_entropy_error(y, t)</span><br><span class="line"><span class="built_in">print</span>(result_)</span><br></pre></td></tr></table></figure><h4 id="使用mini-batch学习的手写数字识别"><a href="#使用mini-batch学习的手写数字识别" class="headerlink" title="使用mini-batch学习的手写数字识别"></a>使用mini-batch学习的手写数字识别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line">sys.path.append(os.pardir)<span class="comment"># 将父目录添加到系统路径，以便导入自定义模块</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> dataset.mnist <span class="keyword">import</span> load_mnist</span><br><span class="line"><span class="keyword">from</span> common.function <span class="keyword">import</span> sigmoid, softmax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载MNIST数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line"><span class="comment"># normalize=True:将图像的像素值正规化到0.0~1.0</span></span><br><span class="line"><span class="comment"># flatten=True:将图像从2维数组转为1维数组</span></span><br><span class="line"><span class="comment"># one_hot_label=False:标签为0~9的数字,而不是one-hot编码</span></span><br><span class="line">(x_train, t_train), (x_test, t_test) = load_mnist(normalize=<span class="literal">True</span>, flatten=<span class="literal">True</span>, one_hot_label=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x_test, t_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化神经网络</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_network</span>():</span><br><span class="line"><span class="comment"># 从文件加载预训练的网络参数（权重和偏置）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;sample_weight.pkl&quot;</span>, rb)<span class="keyword">as</span> f:</span><br><span class="line">network = pickle.load(f)</span><br><span class="line"><span class="keyword">return</span> network</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 神经网络的预测函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">network, x</span>):</span><br><span class="line"><span class="comment"># x 是输入数据</span></span><br><span class="line"><span class="comment"># 获取网络的权重和偏置</span></span><br><span class="line">w1, w2, w3 = network[<span class="string">&#x27;W1&#x27;</span>], network[<span class="string">&#x27;W2&#x27;</span>], network[<span class="string">&#x27;W3&#x27;</span>]</span><br><span class="line">b1, b2, b3 = network[<span class="string">&#x27;b1&#x27;</span>], network[<span class="string">&#x27;b2&#x27;</span>], network[<span class="string">&#x27;b3&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向前传播</span></span><br><span class="line">a1 = np.dot(x, w1) + b1</span><br><span class="line">z1 = sigmoid(a1)</span><br><span class="line">a2 = np.dot(z1, w2) + b2</span><br><span class="line">z2 = sigmoid(a2)</span><br><span class="line">a3 = np.dot(z2, w3) + b3</span><br><span class="line">y = softmax(a3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x, t = get_data()</span><br><span class="line">network = init_network()</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">100</span><span class="comment"># 设置批处理大小</span></span><br><span class="line">accuracy_cnt = <span class="number">0</span><span class="comment"># 初始化准确率计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用批处理进行预测</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(x), batch_size):</span><br><span class="line">x_batch = x[i:i+batch_size]<span class="comment"># 获取当前批次输入的数据</span></span><br><span class="line">y_batch = predict(network, x_batch)<span class="comment"># 对当前批次进行预测</span></span><br><span class="line">p = np.argmax(y_batch, axis=<span class="number">1</span>)<span class="comment"># 获取每个样本预测概率最大的类别</span></span><br><span class="line">accuracy_cnt += np.<span class="built_in">sum</span>(p == t[i:i+batch_size])<span class="comment"># 统计预测正确的样本数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出最终的识别准确率    </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy: &quot;</span> + <span class="built_in">str</span>(<span class="built_in">float</span>(accuracy_cnt) / <span class="built_in">len</span>(x)))</span><br></pre></td></tr></table></figure><h4 id="数值微分"><a href="#数值微分" class="headerlink" title="数值微分"></a>数值微分</h4><blockquote><h4 id="导数的实现"><a href="#导数的实现" class="headerlink" title="导数的实现"></a>导数的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numerical_diff</span>(<span class="params">f, x</span>):</span><br><span class="line"> h = <span class="number">1e-4</span></span><br><span class="line"> <span class="keyword">return</span> (f(h + x) - f(x)) / h</span><br></pre></td></tr></table></figure><h4 id="上面这样计算函数f的差分是不准确的，它计算的是-x-h-和-x-之间的斜率，它与实际要计算的导数是有差异的，这一差异是因h不可能无限接近0导致的，这种属于是前向差分"><a href="#上面这样计算函数f的差分是不准确的，它计算的是-x-h-和-x-之间的斜率，它与实际要计算的导数是有差异的，这一差异是因h不可能无限接近0导致的，这种属于是前向差分" class="headerlink" title="上面这样计算函数f的差分是不准确的，它计算的是(x+h)和(x)之间的斜率，它与实际要计算的导数是有差异的，这一差异是因h不可能无限接近0导致的，这种属于是前向差分"></a>上面这样计算函数f的差分是不准确的，它计算的是(x+h)和(x)之间的斜率，它与实际要计算的导数是有差异的，这一差异是因h不可能无限接近0导致的，这种属于是前向差分</h4><h4 id="正确的应该是-x-h-和-x-h-之间的差分，以x为中心，这也称之为中心差分"><a href="#正确的应该是-x-h-和-x-h-之间的差分，以x为中心，这也称之为中心差分" class="headerlink" title="正确的应该是 (x+h)和(x-h)之间的差分，以x为中心，这也称之为中心差分"></a>正确的应该是 (x+h)和(x-h)之间的差分，以x为中心，这也称之为中心差分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numerical_diff</span>(<span class="params">f, x</span>):</span><br><span class="line"> h = <span class="number">1e-4</span></span><br><span class="line"> <span class="keyword">return</span> (f(x+h) - f(x-h)) / (<span class="number">2</span> * h)</span><br></pre></td></tr></table></figure><h4 id="举个数值微分实例，y-0-01X-2-0-1x"><a href="#举个数值微分实例，y-0-01X-2-0-1x" class="headerlink" title="举个数值微分实例，y &#x3D; 0.01X^2 + 0.1x"></a>举个数值微分实例，y &#x3D; 0.01X^2 + 0.1x</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun_1</span>(<span class="params">x</span>):</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0.01</span>*x**<span class="number">2</span> + <span class="number">0.1</span> * x</span><br></pre></td></tr></table></figure><h4 id="绘制其图像"><a href="#绘制其图像" class="headerlink" title="绘制其图像"></a>绘制其图像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">0.0</span>, <span class="number">20.0</span>, <span class="number">0.1</span>)</span><br><span class="line">y = fun_1(x)</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;f(x)&quot;</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="计算x-5和x-10处的导数，并画出其图像（含切线）"><a href="#计算x-5和x-10处的导数，并画出其图像（含切线）" class="headerlink" title="计算x&#x3D;5和x&#x3D;10处的导数，并画出其图像（含切线）"></a>计算x&#x3D;5和x&#x3D;10处的导数，并画出其图像（含切线）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">a = numerical_diff(fun_1, <span class="number">5</span>)</span><br><span class="line">b = numerical_diff(fun_1, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tangent_line</span>(<span class="params">f, x</span>):</span><br><span class="line"> d = numerical_diff(f, x)</span><br><span class="line"> <span class="built_in">print</span>(d)</span><br><span class="line"> y = f(x) - d*x</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">lambda</span> t: d*t + y</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">0.0</span>, <span class="number">20.0</span>, <span class="number">0.1</span>)</span><br><span class="line">y = fun_1(x)</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;f(x)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置切点坐标</span></span><br><span class="line">tangent_x = <span class="number">5</span></span><br><span class="line">tangent_y = fun_1(tangent_x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制原函数和切线图像</span></span><br><span class="line">tf = tangent_line(fun_1, tangent_x)</span><br><span class="line">y2 = tf(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.plot(x, y2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制切点处辅助线</span></span><br><span class="line"><span class="comment"># 垂直x轴的</span></span><br><span class="line">plt.axvline(x=tangent_x, color=<span class="string">&#x27;gray&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 垂直y轴的</span></span><br><span class="line">plt.axhline(y=tangent_y, color=<span class="string">&#x27;gray&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 标记切点(红色圆点)</span></span><br><span class="line">plt.plot(tangent_x, tangent_y, <span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加坐标标注</span></span><br><span class="line">plt.text(tangent_x, tangent_y, <span class="string">f&#x27;(<span class="subst">&#123;tangent_x:<span class="number">.1</span>f&#125;</span>, <span class="subst">&#123;tangent_y:<span class="number">.2</span>f&#125;</span>)&#x27;</span>, </span><br><span class="line">      horizontalalignment=<span class="string">&#x27;right&#x27;</span>, verticalalignment=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置切点坐标</span></span><br><span class="line">tangent_x = <span class="number">10</span></span><br><span class="line">tangent_y = fun_1(tangent_x)</span><br><span class="line"></span><br><span class="line">tf = tangent_line(fun_1, tangent_x)</span><br><span class="line">y3 = tf(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.plot(x, y3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制切点处辅助线</span></span><br><span class="line"><span class="comment"># 垂直x轴的</span></span><br><span class="line">plt.axvline(x=tangent_x, color=<span class="string">&#x27;gray&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 垂直y轴的</span></span><br><span class="line">plt.axhline(y=tangent_y, color=<span class="string">&#x27;gray&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 标记切点(红色圆点)</span></span><br><span class="line">plt.plot(tangent_x, tangent_y, <span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加坐标标注</span></span><br><span class="line">plt.text(tangent_x, tangent_y, <span class="string">f&#x27;(<span class="subst">&#123;tangent_x:<span class="number">.1</span>f&#125;</span>, <span class="subst">&#123;tangent_y:<span class="number">.2</span>f&#125;</span>)&#x27;</span>, </span><br><span class="line">      horizontalalignment=<span class="string">&#x27;right&#x27;</span>, verticalalignment=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h4><blockquote><h4 id="求-f-x-0-x-1-x-0-2-x-1-2-的偏导，并画出其函数图像"><a href="#求-f-x-0-x-1-x-0-2-x-1-2-的偏导，并画出其函数图像" class="headerlink" title="求 $f(x_0,x_1)&#x3D;x_0^2+x_1^2$的偏导，并画出其函数图像"></a>求 $f(x_0,x_1)&#x3D;x_0^2+x_1^2$的偏导，并画出其函数图像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义网格</span></span><br><span class="line">x0 = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">100</span>)</span><br><span class="line">x1 = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">100</span>)</span><br><span class="line">X0, X1 = np.meshgrid(x0, x1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line">Z = X0**<span class="number">2</span> + X1**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建图形窗口</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">14</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 三维图像</span></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax1.plot_surface(X0, X1, Z, cmap=<span class="string">&#x27;viridis&#x27;</span>, edgecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">r&#x27;$f(x_0, x_1) = x_0^2 + x_1^2$&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;$x_0$&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;$x_1$&#x27;</span>)</span><br><span class="line">ax1.set_zlabel(<span class="string">&#x27;$f(x_0, x_1)$&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 等高线图 + 梯度向量</span></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">contour = ax2.contourf(X0, X1, Z, levels=<span class="number">30</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">ax2.set_title(<span class="string">&#x27;Contour and Gradient&#x27;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;$x_0$&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;$x_1$&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算梯度（偏导）</span></span><br><span class="line">grad_x0 = <span class="number">2</span> * X0</span><br><span class="line">grad_x1 = <span class="number">2</span> * X1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制梯度向量（用 quiver 画箭头）</span></span><br><span class="line">skip = <span class="number">5</span>  <span class="comment"># 降低密度</span></span><br><span class="line">ax2.quiver(X0[::skip, ::skip], X1[::skip, ::skip],</span><br><span class="line">           grad_x0[::skip, ::skip], grad_x1[::skip, ::skip],</span><br><span class="line">           color=<span class="string">&#x27;white&#x27;</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">plt.colorbar(contour, ax=ax2, label=<span class="string">&#x27;Function Value&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></blockquote></blockquote><h4 id="梯度-1"><a href="#梯度-1" class="headerlink" title="梯度"></a>梯度</h4><blockquote><h4 id="简单的梯度的实现"><a href="#简单的梯度的实现" class="headerlink" title="简单的梯度的实现"></a>简单的梯度的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numerical_gradient</span>(<span class="params">f, x</span>):</span><br><span class="line">    h = <span class="number">1e-4</span></span><br><span class="line">    <span class="comment"># 生成和x形状相同的数组，且所有元素为0</span></span><br><span class="line">    grad = np.zeros_like(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(x.size):</span><br><span class="line">        tmp_val = x[idx]</span><br><span class="line">        <span class="comment"># f(x+h)的计算</span></span><br><span class="line">        x[idx] = tmp_val + h</span><br><span class="line">        fxh1 = f(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># f(x-h)的计算</span></span><br><span class="line">        x[idx] = tmp_val - h</span><br><span class="line">        fxh2 = f(x)</span><br><span class="line"></span><br><span class="line">        grad[idx] = (fxh1 - fxh2) / (<span class="number">2</span> * h)</span><br><span class="line">        x[idx] = tmp_val <span class="comment"># 还原值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> grad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(numerical_gradient(fun_2, np.array([<span class="number">3.0</span>, <span class="number">4.0</span>])))</span><br><span class="line"><span class="built_in">print</span>(numerical_gradient(fun_2, np.array([<span class="number">0.0</span>, <span class="number">2.0</span>])))</span><br><span class="line"><span class="built_in">print</span>(numerical_gradient(fun_2, np.array([<span class="number">3.0</span>, <span class="number">0.0</span>])))</span><br></pre></td></tr></table></figure><h4 id="这里给出一个计算任意维数组的数值梯度"><a href="#这里给出一个计算任意维数组的数值梯度" class="headerlink" title="这里给出一个计算任意维数组的数值梯度"></a>这里给出一个计算任意维数组的数值梯度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numerical_gradient</span>(<span class="params">f, x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算任意维数组的数值梯度</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        f: 目标函数</span></span><br><span class="line"><span class="string">        x: 任意维度的数组</span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        梯度数组，形状与x相同</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    实现原理：</span></span><br><span class="line"><span class="string">    1. 使用中心差分法计算梯度：(f(x+h) - f(x-h)) / (2h)</span></span><br><span class="line"><span class="string">    2. 对数组中的每个元素分别计算梯度</span></span><br><span class="line"><span class="string">    3. 使用numpy的迭代器处理任意维度的数组</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    h = <span class="number">1e-4</span>  <span class="comment"># 0.0001，微小的变化量</span></span><br><span class="line">    grad = np.zeros_like(x)  <span class="comment"># 创建与x形状相同的零数组，用于存储梯度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用numpy的迭代器遍历数组的所有元素</span></span><br><span class="line">    <span class="comment"># flags=[&#x27;multi_index&#x27;]: 获取多维索引</span></span><br><span class="line">    <span class="comment"># op_flags=[&#x27;readwrite&#x27;]: 允许读写操作</span></span><br><span class="line">    it = np.nditer(x, flags=[<span class="string">&#x27;multi_index&#x27;</span>], op_flags=[<span class="string">&#x27;readwrite&#x27;</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> it.finished:</span><br><span class="line">        idx = it.multi_index  <span class="comment"># 获取当前元素的多维索引</span></span><br><span class="line">        tmp_val = x[idx]  <span class="comment"># 保存当前值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算f(x+h)</span></span><br><span class="line">        x[idx] = tmp_val + h</span><br><span class="line">        fxh1 = f(x)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算f(x-h)</span></span><br><span class="line">        x[idx] = tmp_val - h </span><br><span class="line">        fxh2 = f(x)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用中心差分法计算梯度</span></span><br><span class="line">        grad[idx] = (fxh1 - fxh2) / (<span class="number">2</span>*h)</span><br><span class="line">        </span><br><span class="line">        x[idx] = tmp_val  <span class="comment"># 恢复原始值</span></span><br><span class="line">        it.iternext()  <span class="comment"># 移动到下一个元素</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> grad</span><br></pre></td></tr></table></figure><h4 id="梯度下降法的实现"><a href="#梯度下降法的实现" class="headerlink" title="梯度下降法的实现"></a>梯度下降法的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f 是要进行最优化的函数，init_x是初始值，lr是学习率，step_num是梯度法的重复次数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">f, init_x, lr=<span class="number">0.01</span>, step_num=<span class="number">100</span></span>):</span><br><span class="line">    x = init_x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(step_num):</span><br><span class="line">        grad = numerical_gradient(f, x)</span><br><span class="line">        x -= lr * grad</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init_x = np.array([-<span class="number">3.0</span>, <span class="number">4.0</span>])</span><br><span class="line">result_ = gradient_descent(fun_2, init_x=init_x, lr=<span class="number">0.1</span>, step_num=<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(result_)</span><br></pre></td></tr></table></figure><h4 id="图像展示梯度法的过程"><a href="#图像展示梯度法的过程" class="headerlink" title="图像展示梯度法的过程"></a>图像展示梯度法的过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent_</span>(<span class="params">f, init_x, lr=<span class="number">0.01</span>, step_num=<span class="number">100</span></span>):</span><br><span class="line">    x = init_x</span><br><span class="line">    x_history = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(step_num):</span><br><span class="line">        x_history.append(x.copy())</span><br><span class="line">        </span><br><span class="line">        grad = numerical_gradient(f, x)</span><br><span class="line">        x -= lr * grad</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x, np.array(x_history)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init_x = np.array([-<span class="number">3.0</span>, <span class="number">4.0</span>])</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span></span><br><span class="line">step_num = <span class="number">20</span></span><br><span class="line">x, x_history = gradient_descent_(fun_2, init_x, lr, step_num)</span><br><span class="line"></span><br><span class="line">plt.plot([-<span class="number">5</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">0</span>], <span class="string">&#x27;--b&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">5</span>, <span class="number">5</span>], <span class="string">&#x27;--b&#x27;</span>)</span><br><span class="line">plt.plot(x_history[:, <span class="number">0</span>], x_history[:, <span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">3.5</span>, <span class="number">3.5</span>)</span><br><span class="line">plt.ylim(-<span class="number">4.5</span>, <span class="number">4.5</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;X0&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;X1&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></blockquote><h4 id="神经网络的梯度-1"><a href="#神经网络的梯度-1" class="headerlink" title="神经网络的梯度"></a>神经网络的梯度</h4><blockquote><h4 id="简单的神经网络"><a href="#简单的神经网络" class="headerlink" title="简单的神经网络"></a>简单的神经网络</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># 导入必要的库</span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="comment"># 将父目录添加到系统路径中，以便能够导入common模块</span></span><br><span class="line">sys.path.append(os.pardir)</span><br><span class="line"><span class="keyword">from</span> common.functions <span class="keyword">import</span> softmax, cross_entropy_error</span><br><span class="line"><span class="keyword">from</span> common.gradient <span class="keyword">import</span> numerical_gradient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simpleNet</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一个简单的神经网络类</span></span><br><span class="line"><span class="string">    实现了一个2输入3输出的单层神经网络</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化权重矩阵，使用随机数生成2x3的权重矩阵</span></span><br><span class="line">        <span class="variable language_">self</span>.W = np.random.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播函数</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 输入数据</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            神经网络的输出</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> np.dot(x, <span class="variable language_">self</span>.W)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算损失函数</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 输入数据</span></span><br><span class="line"><span class="string">            t: 正确解标签</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            损失函数的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        z = <span class="variable language_">self</span>.predict(x)  <span class="comment"># 获取神经网络的输出</span></span><br><span class="line">        y = softmax(z)       <span class="comment"># 使用softmax函数将输出转换为概率</span></span><br><span class="line">        loss = cross_entropy_error(y, t)  <span class="comment"># 计算交叉熵误差</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建测试数据</span></span><br><span class="line">x = np.array([<span class="number">0.6</span>, <span class="number">0.9</span>])  <span class="comment"># 输入数据</span></span><br><span class="line">t = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># 正确解标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建神经网络实例</span></span><br><span class="line">net = simpleNet()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数，用于计算梯度</span></span><br><span class="line">f = <span class="keyword">lambda</span> w: net.loss(x, t)</span><br><span class="line"><span class="comment"># 使用数值微分计算梯度</span></span><br><span class="line">dW = numerical_gradient(f, net.W)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印梯度结果</span></span><br><span class="line"><span class="built_in">print</span>(dW)</span><br></pre></td></tr></table></figure><h4 id="这里需要注意的是，为什么要在类外定义一个损失函数f，因为类中的损失函数loss-是一个实例方法，需要访问实例的权重self-W，而numerical-gradient-函数参数中的f，需要的是一个纯函数，而不是一个类中的实例方法"><a href="#这里需要注意的是，为什么要在类外定义一个损失函数f，因为类中的损失函数loss-是一个实例方法，需要访问实例的权重self-W，而numerical-gradient-函数参数中的f，需要的是一个纯函数，而不是一个类中的实例方法" class="headerlink" title="这里需要注意的是，为什么要在类外定义一个损失函数f，因为类中的损失函数loss()是一个实例方法，需要访问实例的权重self.W，而numerical_gradient()函数参数中的f，需要的是一个纯函数，而不是一个类中的实例方法"></a>这里需要注意的是，为什么要在类外定义一个损失函数f，因为类中的损失函数loss()是一个实例方法，需要访问实例的权重self.W，而numerical_gradient()函数参数中的f，需要的是一个纯函数，而不是一个类中的实例方法</h4></blockquote><h4 id="手写数字识别的神经网络的实现-1"><a href="#手写数字识别的神经网络的实现-1" class="headerlink" title="手写数字识别的神经网络的实现"></a>手写数字识别的神经网络的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line">sys.path.append(os.pardir)  <span class="comment"># 将父目录添加到系统路径中，以便导入common模块</span></span><br><span class="line"><span class="keyword">from</span> common.functions <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> common.gradient <span class="keyword">import</span> numerical_gradient</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoLayerNet</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    两层神经网络类</span></span><br><span class="line"><span class="string">    实现了一个具有一个隐藏层的神经网络</span></span><br><span class="line"><span class="string">    结构：输入层 -&gt; 隐藏层 -&gt; 输出层</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size, hidden_size, output_size, weight_init_std=<span class="number">0.01</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化神经网络</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            input_size: 输入层神经元数量</span></span><br><span class="line"><span class="string">            hidden_size: 隐藏层神经元数量</span></span><br><span class="line"><span class="string">            output_size: 输出层神经元数量</span></span><br><span class="line"><span class="string">            weight_init_std: 权重初始化的标准差</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化权重和偏置</span></span><br><span class="line">        <span class="variable language_">self</span>.params = &#123;&#125;</span><br><span class="line">        <span class="comment"># 第一层权重矩阵，形状为(input_size, hidden_size)</span></span><br><span class="line">        <span class="variable language_">self</span>.params[<span class="string">&#x27;W1&#x27;</span>] = weight_init_std * np.random.randn(input_size, hidden_size)</span><br><span class="line">        <span class="comment"># 第一层偏置，形状为(hidden_size,)</span></span><br><span class="line">        <span class="variable language_">self</span>.params[<span class="string">&#x27;b1&#x27;</span>] = np.zeros(hidden_size)</span><br><span class="line">        <span class="comment"># 第二层权重矩阵，形状为(hidden_size, output_size)</span></span><br><span class="line">        <span class="variable language_">self</span>.params[<span class="string">&#x27;W2&#x27;</span>] = weight_init_std * np.random.randn(hidden_size, output_size)</span><br><span class="line">        <span class="comment"># 第二层偏置，形状为(output_size,)</span></span><br><span class="line">        <span class="variable language_">self</span>.params[<span class="string">&#x27;b2&#x27;</span>] = np.zeros(output_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播，计算神经网络的输出</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 输入数据</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            神经网络的输出（经过softmax后的概率分布）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        W1, W2 = <span class="variable language_">self</span>.params[<span class="string">&#x27;W1&#x27;</span>], <span class="variable language_">self</span>.params[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">        b1, b2 = <span class="variable language_">self</span>.params[<span class="string">&#x27;b1&#x27;</span>], <span class="variable language_">self</span>.params[<span class="string">&#x27;b2&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 第一层计算</span></span><br><span class="line">        a1 = np.dot(x, W1) + b1  <span class="comment"># 线性变换</span></span><br><span class="line">        z1 = sigmoid(a1)         <span class="comment"># 激活函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二层计算</span></span><br><span class="line">        a2 = np.dot(z1, W2) + b2  <span class="comment"># 线性变换</span></span><br><span class="line">        y = softmax(a2)           <span class="comment"># 输出层激活函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算损失函数</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 输入数据</span></span><br><span class="line"><span class="string">            t: 正确解标签</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            损失函数的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        y = <span class="variable language_">self</span>.predict(x)</span><br><span class="line">        <span class="keyword">return</span> cross_entropy_error(y, t)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算识别精度</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 输入数据</span></span><br><span class="line"><span class="string">            t: 正确解标签</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            识别精度（0-1之间的值）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        y = <span class="variable language_">self</span>.predict(x)</span><br><span class="line">        y = np.argmax(y, axis=<span class="number">1</span>)  <span class="comment"># 获取预测结果</span></span><br><span class="line">        t = np.argmax(t, axis=<span class="number">1</span>)  <span class="comment"># 获取正确解</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算正确率</span></span><br><span class="line">        accuracy = np.<span class="built_in">sum</span>(y == t) / <span class="built_in">float</span>(x.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> accuracy</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numerical_gradient</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用数值微分计算梯度</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 输入数据</span></span><br><span class="line"><span class="string">            t: 正确解标签</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            包含各层权重和偏置梯度的字典</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 定义损失函数</span></span><br><span class="line">        loss_W = <span class="keyword">lambda</span> W: <span class="variable language_">self</span>.loss(x, t)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算各层参数的梯度</span></span><br><span class="line">        grads = &#123;&#125;</span><br><span class="line">        grads[<span class="string">&#x27;W1&#x27;</span>] = numerical_gradient(loss_W, <span class="variable language_">self</span>.params[<span class="string">&#x27;W1&#x27;</span>])  <span class="comment"># 第一层权重梯度</span></span><br><span class="line">        grads[<span class="string">&#x27;b1&#x27;</span>] = numerical_gradient(loss_W, <span class="variable language_">self</span>.params[<span class="string">&#x27;b1&#x27;</span>])  <span class="comment"># 第一层偏置梯度</span></span><br><span class="line">        grads[<span class="string">&#x27;W2&#x27;</span>] = numerical_gradient(loss_W, <span class="variable language_">self</span>.params[<span class="string">&#x27;W2&#x27;</span>])  <span class="comment"># 第二层权重梯度</span></span><br><span class="line">        grads[<span class="string">&#x27;b2&#x27;</span>] = numerical_gradient(loss_W, <span class="variable language_">self</span>.params[<span class="string">&#x27;b2&#x27;</span>])  <span class="comment"># 第二层偏置梯度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grads</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用反向传播计算梯度</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 输入数据</span></span><br><span class="line"><span class="string">            t: 正确解标签</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            包含各层权重和偏置梯度的字典</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        W1, W2 = <span class="variable language_">self</span>.params[<span class="string">&#x27;W1&#x27;</span>], <span class="variable language_">self</span>.params[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">        b1, b2 = <span class="variable language_">self</span>.params[<span class="string">&#x27;b1&#x27;</span>], <span class="variable language_">self</span>.params[<span class="string">&#x27;b2&#x27;</span>]</span><br><span class="line">        grads = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        batch_num = x.shape[<span class="number">0</span>]  <span class="comment"># 批次大小</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 前向传播</span></span><br><span class="line">        a1 = np.dot(x, W1) + b1</span><br><span class="line">        z1 = sigmoid(a1)</span><br><span class="line">        a2 = np.dot(z1, W2) + b2</span><br><span class="line">        y = softmax(a2)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        <span class="comment"># 输出层的误差</span></span><br><span class="line">        dy = (y - t) / batch_num</span><br><span class="line">        <span class="comment"># 第二层权重的梯度</span></span><br><span class="line">        grads[<span class="string">&#x27;W2&#x27;</span>] = np.dot(z1.T, dy)</span><br><span class="line">        <span class="comment"># 第二层偏置的梯度</span></span><br><span class="line">        grads[<span class="string">&#x27;b2&#x27;</span>] = np.<span class="built_in">sum</span>(dy, axis=<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一层的误差</span></span><br><span class="line">        dz1 = np.dot(dy, W2.T)</span><br><span class="line">        da1 = sigmoid_grad(a1) * dz1</span><br><span class="line">        <span class="comment"># 第一层权重的梯度</span></span><br><span class="line">        grads[<span class="string">&#x27;W1&#x27;</span>] = np.dot(x.T, da1)</span><br><span class="line">        <span class="comment"># 第一层偏置的梯度</span></span><br><span class="line">        grads[<span class="string">&#x27;b1&#x27;</span>] = np.<span class="built_in">sum</span>(da1, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grads</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">net = TwoLayerNet(input_size=<span class="number">784</span>, hidden_size=<span class="number">100</span>, output_size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(net.params[<span class="string">&#x27;W1&#x27;</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(net.params[<span class="string">&#x27;b1&#x27;</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(net.params[<span class="string">&#x27;W2&#x27;</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(net.params[<span class="string">&#x27;b2&#x27;</span>].shape)</span><br><span class="line"></span><br><span class="line">x = np.random.rand(<span class="number">100</span>, <span class="number">784</span>)</span><br><span class="line">t = np.random.rand(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">grads = net.numerical_gradient(x, t)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(grads[<span class="string">&#x27;W1&#x27;</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(grads[<span class="string">&#x27;b1&#x27;</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(grads[<span class="string">&#x27;W2&#x27;</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(grads[<span class="string">&#x27;b2&#x27;</span>].shape)</span><br></pre></td></tr></table></figure><h4 id="mini-batch的实现，以及基于测试数据的评价"><a href="#mini-batch的实现，以及基于测试数据的评价" class="headerlink" title="mini-batch的实现，以及基于测试数据的评价"></a>mini-batch的实现，以及基于测试数据的评价</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line">sys.path.append(<span class="string">&#x27;../../py_pro/DL/&#x27;</span>)  <span class="comment"># 将父目录添加到系统路径中，以便导入其他模块</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> dataset.mnist <span class="keyword">import</span> load_mnist  <span class="comment"># 导入MNIST数据集加载函数</span></span><br><span class="line"><span class="keyword">from</span> two_layer_net <span class="keyword">import</span> TwoLayerNet  <span class="comment"># 导入两层神经网络类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载MNIST数据集</span></span><br><span class="line"><span class="comment"># normalize=True: 将输入图像像素值正规化到0~1之间</span></span><br><span class="line"><span class="comment"># one_hot_label=True: 将标签转换为one-hot形式</span></span><br><span class="line">(x_train, t_train), (x_test, t_test) = load_mnist(normalize=<span class="literal">True</span>, one_hot_label=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两层神经网络实例</span></span><br><span class="line"><span class="comment"># 输入层784个神经元（28x28像素）</span></span><br><span class="line"><span class="comment"># 隐藏层50个神经元</span></span><br><span class="line"><span class="comment"># 输出层10个神经元（0-9十个数字）</span></span><br><span class="line">network = TwoLayerNet(input_size=<span class="number">784</span>, hidden_size=<span class="number">50</span>, output_size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置超参数</span></span><br><span class="line">iters_num = <span class="number">10000</span>  <span class="comment"># 训练迭代次数</span></span><br><span class="line">train_size = x_train.shape[<span class="number">0</span>]  <span class="comment"># 训练数据的大小</span></span><br><span class="line">batch_size = <span class="number">100</span>  <span class="comment"># 每批次的样本数</span></span><br><span class="line">learning_rate = <span class="number">0.1</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于记录训练过程的列表</span></span><br><span class="line">train_loss_list = []  <span class="comment"># 记录训练损失</span></span><br><span class="line">train_acc_list = []   <span class="comment"># 记录训练准确率</span></span><br><span class="line">test_acc_list = []    <span class="comment"># 记录测试准确率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个epoch的迭代次数</span></span><br><span class="line">iter_per_epoch = <span class="built_in">max</span>(train_size / batch_size, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iters_num):</span><br><span class="line">    <span class="comment"># 随机选择批次数据</span></span><br><span class="line">    batch_mask = np.random.choice(train_size, batch_size)</span><br><span class="line">    x_batch = x_train[batch_mask]</span><br><span class="line">    t_batch = t_train[batch_mask]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算梯度</span></span><br><span class="line">    <span class="comment"># 使用反向传播计算梯度（比数值微分更快）</span></span><br><span class="line">    <span class="comment">#grad = network.numerical_gradient(x_batch, t_batch)  # 数值微分（较慢）</span></span><br><span class="line">    grad = network.gradient(x_batch, t_batch)  <span class="comment"># 反向传播（较快）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    <span class="comment"># 对每个参数进行梯度下降更新</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> (<span class="string">&#x27;W1&#x27;</span>, <span class="string">&#x27;b1&#x27;</span>, <span class="string">&#x27;W2&#x27;</span>, <span class="string">&#x27;b2&#x27;</span>):</span><br><span class="line">        network.params[key] -= learning_rate * grad[key]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录训练损失</span></span><br><span class="line">    loss = network.loss(x_batch, t_batch)</span><br><span class="line">    train_loss_list.append(loss)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每个epoch计算一次训练集和测试集的准确率</span></span><br><span class="line">    <span class="keyword">if</span> i % iter_per_epoch == <span class="number">0</span>:</span><br><span class="line">        train_acc = network.accuracy(x_train, t_train)</span><br><span class="line">        test_acc = network.accuracy(x_test, t_test)</span><br><span class="line">        train_acc_list.append(train_acc)</span><br><span class="line">        test_acc_list.append(test_acc)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;train acc, test acc | &quot;</span> + <span class="built_in">str</span>(train_acc) + <span class="string">&quot;, &quot;</span> + <span class="built_in">str</span>(test_acc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练结果</span></span><br><span class="line">markers = &#123;<span class="string">&#x27;train&#x27;</span>: <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;test&#x27;</span>: <span class="string">&#x27;s&#x27;</span>&#125;  <span class="comment"># 设置图例标记</span></span><br><span class="line">x = np.arange(<span class="built_in">len</span>(train_acc_list))</span><br><span class="line">plt.plot(x, train_acc_list, label=<span class="string">&#x27;train acc&#x27;</span>)  <span class="comment"># 绘制训练准确率曲线</span></span><br><span class="line">plt.plot(x, test_acc_list, label=<span class="string">&#x27;test acc&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)  <span class="comment"># 绘制测试准确率曲线</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;epochs&quot;</span>)  <span class="comment"># x轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;accuracy&quot;</span>)  <span class="comment"># y轴标签</span></span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">1.0</span>)  <span class="comment"># 设置y轴范围</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)  <span class="comment"># 显示图例</span></span><br><span class="line">plt.show()  <span class="comment"># 显示图形</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="都说这本鱼书是-最最最-最入门的神经网络和深度学习的书了，但是，从这一章开始，已经开始头脑风暴了，难顶哟-TUT"><a href="#都说这本鱼书是-最最最-最入门的神经网络和深度学习的书了，但是，从这一章开始，已经开始头脑风暴了，难顶哟-TUT" class="headerlink" title="都说这本鱼书是 最最最 最入门的神经网络和深度学习的书了，但是，从这一章开始，已经开始头脑风暴了，难顶哟(TUT)"></a>都说这本鱼书是 最最最 最入门的神经网络和深度学习的书了，但是，从这一章开始，已经开始头脑风暴了，难顶哟(TUT)</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> DL </tag>
            
            <tag> gnaw_book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DL之路---啃鱼书（2）</title>
      <link href="/2025/06/11/21/"/>
      <url>/2025/06/11/21/</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><blockquote><h4 id="神经网络的一个重要性质是它可以自动地从数据中学习到合适的权重参数"><a href="#神经网络的一个重要性质是它可以自动地从数据中学习到合适的权重参数" class="headerlink" title="神经网络的一个重要性质是它可以自动地从数据中学习到合适的权重参数"></a>神经网络的一个重要性质是它可以自动地从数据中学习到合适的权重参数</h4><h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><blockquote><h4 id="它会将输入信号的总和转换为输出信号，它决定了以何种方式激活输入信号的总和"><a href="#它会将输入信号的总和转换为输出信号，它决定了以何种方式激活输入信号的总和" class="headerlink" title="它会将输入信号的总和转换为输出信号，它决定了以何种方式激活输入信号的总和"></a>它会将输入信号的总和转换为输出信号，它决定了以何种方式激活输入信号的总和</h4><h4 id="朴素感知机和神经网络的主要区别就在于激活函数的不同"><a href="#朴素感知机和神经网络的主要区别就在于激活函数的不同" class="headerlink" title="朴素感知机和神经网络的主要区别就在于激活函数的不同"></a>朴素感知机和神经网络的主要区别就在于激活函数的不同</h4><h4 id="计算过程如下"><a href="#计算过程如下" class="headerlink" title="计算过程如下:"></a>计算过程如下:</h4><p><img src="http://picbed.yanzu.tech/img/DL/2/1.png"></p><h4 id="阶跃函数：一旦输入超过阈值，就切换输出（sign符号函数，朴素感知机的激活函数）"><a href="#阶跃函数：一旦输入超过阈值，就切换输出（sign符号函数，朴素感知机的激活函数）" class="headerlink" title="阶跃函数：一旦输入超过阈值，就切换输出（sign符号函数，朴素感知机的激活函数）"></a>阶跃函数：一旦输入超过阈值，就切换输出（sign符号函数，朴素感知机的激活函数）</h4><h4 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h4><blockquote><h4 id="神经网络中一个常用的激活函数就是sigmoid函数，其表达式如下："><a href="#神经网络中一个常用的激活函数就是sigmoid函数，其表达式如下：" class="headerlink" title="神经网络中一个常用的激活函数就是sigmoid函数，其表达式如下："></a>神经网络中一个常用的激活函数就是sigmoid函数，其表达式如下：</h4><p>$$<br>h(x) &#x3D; \frac {1}{1 + exp(-x)}<br>$$</p></blockquote><h4 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h4><h4 id="自变量-x-0-时，直接输出该值，-x-le-0-时，输出0"><a href="#自变量-x-0-时，直接输出该值，-x-le-0-时，输出0" class="headerlink" title="自变量 $ x &gt; 0 $ 时，直接输出该值，$ x \le 0 $  时，输出0"></a>自变量 $ x &gt; 0 $ 时，直接输出该值，$ x \le 0 $  时，输出0</h4><h4 id="它的表达式如下："><a href="#它的表达式如下：" class="headerlink" title="它的表达式如下："></a>它的表达式如下：</h4><p><img src="http://picbed.yanzu.tech/img/DL/2/11.png"></p></blockquote><h4 id="3层神经网络的实现"><a href="#3层神经网络的实现" class="headerlink" title="3层神经网络的实现"></a>3层神经网络的实现</h4><blockquote><h4 id="首先引入一个概念符号确认"><a href="#首先引入一个概念符号确认" class="headerlink" title="首先引入一个概念符号确认"></a>首先引入一个概念符号确认</h4><h4 id="下面是权重符号的表示，"><a href="#下面是权重符号的表示，" class="headerlink" title="下面是权重符号的表示，"></a>下面是权重符号的表示，</h4><p><img src="http://picbed.yanzu.tech/img/DL/2/5.png"></p><h4 id="各层间信号传递的实现"><a href="#各层间信号传递的实现" class="headerlink" title="各层间信号传递的实现"></a>各层间信号传递的实现</h4><h4 id="首先是第0层到第1层之间信号传递的实现"><a href="#首先是第0层到第1层之间信号传递的实现" class="headerlink" title="首先是第0层到第1层之间信号传递的实现"></a>首先是第0层到第1层之间信号传递的实现</h4><p><img src="http://picbed.yanzu.tech/img/DL/2/6.png"></p><h4 id="注意，偏置-b-的右下角的索引号只有一个，这是因为前一层的偏置神经元（神经元1）只有一个，右下角的索引是表示前一个神经元的，对应到权重的符号表示是-b-left-1-right-None-1-，因为本身a本身就在一个神经元上了，所以前一个索引是None"><a href="#注意，偏置-b-的右下角的索引号只有一个，这是因为前一层的偏置神经元（神经元1）只有一个，右下角的索引是表示前一个神经元的，对应到权重的符号表示是-b-left-1-right-None-1-，因为本身a本身就在一个神经元上了，所以前一个索引是None" class="headerlink" title="注意，偏置 $ b $ 的右下角的索引号只有一个，这是因为前一层的偏置神经元（神经元1）只有一个，右下角的索引是表示前一个神经元的，对应到权重的符号表示是 $ b^\left[(1)\right]_{None,1} $ ，因为本身a本身就在一个神经元上了，所以前一个索引是None"></a>注意，偏置 $ b $ 的右下角的索引号只有一个，这是因为前一层的偏置神经元（神经元1）只有一个，右下角的索引是表示前一个神经元的，对应到权重的符号表示是 $ b^\left[(1)\right]_{None,1} $ ，因为本身a本身就在一个神经元上了，所以前一个索引是None</h4><h4 id="a-1-的表达式如下："><a href="#a-1-的表达式如下：" class="headerlink" title="$ a_1 $的表达式如下："></a>$ a_1 $的表达式如下：</h4><p>$$<br>a_1^{(1)} &#x3D; w_{11}^{(1)} x_1 + w_{12}^{(1)} x_2 + b_1^{(1)}<br>$$</p><h4 id="使用矩阵的乘法运算表示第1层的加权和"><a href="#使用矩阵的乘法运算表示第1层的加权和" class="headerlink" title="使用矩阵的乘法运算表示第1层的加权和"></a>使用矩阵的乘法运算表示第1层的加权和</h4><p>$$<br>A^{(1)} &#x3D; XW^{(1)} + B^{(1)}<br>$$</p><h4 id="其中，-A-1-X-B-1-W-1-如下所示"><a href="#其中，-A-1-X-B-1-W-1-如下所示" class="headerlink" title="其中，$ A^{(1)},X,B^{(1)},W^{(1)} $如下所示"></a>其中，$ A^{(1)},X,B^{(1)},W^{(1)} $如下所示</h4><p><img src="http://picbed.yanzu.tech/img/DL/2/12.png"></p><h4 id="W-i-的每一列对应一个-a-i"><a href="#W-i-的每一列对应一个-a-i" class="headerlink" title="$W_i$的每一列对应一个$ a_i $"></a>$W_i$的每一列对应一个$ a_i $</h4></blockquote><h4 id="第1层到第2层之间信号传递的实现"><a href="#第1层到第2层之间信号传递的实现" class="headerlink" title="第1层到第2层之间信号传递的实现"></a>第1层到第2层之间信号传递的实现</h4><p><img src="http://picbed.yanzu.tech/img/DL/2/7.png"></p><h4 id="第2层到输出层之间信号传递的实现"><a href="#第2层到输出层之间信号传递的实现" class="headerlink" title="第2层到输出层之间信号传递的实现"></a>第2层到输出层之间信号传递的实现</h4><p><img src="http://picbed.yanzu.tech/img/DL/2/8.png"></p><h4 id="输出层的激活函数一般用-sigma-来表示，隐藏层的激活函数一般用-h-来表示"><a href="#输出层的激活函数一般用-sigma-来表示，隐藏层的激活函数一般用-h-来表示" class="headerlink" title="输出层的激活函数一般用 $ \sigma() $ 来表示，隐藏层的激活函数一般用 $ h() $ 来表示"></a>输出层的激活函数一般用 $ \sigma() $ 来表示，隐藏层的激活函数一般用 $ h() $ 来表示</h4><h4 id="另外，输出层所使用的激活函数要根据求解问题的性质来确定，一般情况下，回归问题可以使用恒等函数，二元分类问题可以使用-sigmoid-函数，多元分类问题可以使用-softmax-函数"><a href="#另外，输出层所使用的激活函数要根据求解问题的性质来确定，一般情况下，回归问题可以使用恒等函数，二元分类问题可以使用-sigmoid-函数，多元分类问题可以使用-softmax-函数" class="headerlink" title="另外，输出层所使用的激活函数要根据求解问题的性质来确定，一般情况下，回归问题可以使用恒等函数，二元分类问题可以使用 $sigmoid$ 函数，多元分类问题可以使用 $softmax$函数"></a>另外，输出层所使用的激活函数要根据求解问题的性质来确定，一般情况下，回归问题可以使用恒等函数，二元分类问题可以使用 $sigmoid$ 函数，多元分类问题可以使用 $softmax$函数</h4><h4 id="输出层的设计"><a href="#输出层的设计" class="headerlink" title="输出层的设计"></a>输出层的设计</h4><blockquote><h4 id="机器学习的问题大致可以分为分类问题和回归问题-分类问题是数-据属于哪一个类别的问题；而回归问题是根据某个输入预测一个（连续的）数值的问题"><a href="#机器学习的问题大致可以分为分类问题和回归问题-分类问题是数-据属于哪一个类别的问题；而回归问题是根据某个输入预测一个（连续的）数值的问题" class="headerlink" title="机器学习的问题大致可以分为分类问题和回归问题,分类问题是数 据属于哪一个类别的问题；而回归问题是根据某个输入预测一个（连续的）数值的问题"></a>机器学习的问题大致可以分为分类问题和回归问题,分类问题是数 据属于哪一个类别的问题；而回归问题是根据某个输入预测一个（连续的）数值的问题</h4><h4 id="softmax-函数（输出层的激活函数）"><a href="#softmax-函数（输出层的激活函数）" class="headerlink" title="$softmax$函数（输出层的激活函数）"></a>$softmax$函数（输出层的激活函数）</h4><blockquote><h4 id="分类问题中使用该函数，表达式如下："><a href="#分类问题中使用该函数，表达式如下：" class="headerlink" title="分类问题中使用该函数，表达式如下："></a>分类问题中使用该函数，表达式如下：</h4><p>$$<br>\sigma &#x3D; y_k &#x3D; \frac {exp(a_k)} {\sum^{n}_{i &#x3D; 1} exp(a_i)}<br>$$</p><h4 id="这个式子表示：假设输出层共有-n-个神经元，计算第-k-个神经元的输出-y-k"><a href="#这个式子表示：假设输出层共有-n-个神经元，计算第-k-个神经元的输出-y-k" class="headerlink" title="这个式子表示：假设输出层共有$n$个神经元，计算第$k$个神经元的输出$y_k$"></a>这个式子表示：假设输出层共有$n$个神经元，计算第$k$个神经元的输出$y_k$</h4><p><img src="http://picbed.yanzu.tech/img/DL/2/9.png"></p><h4 id="可以看出，输出层的各个神经元都受到所有输入信号的影响"><a href="#可以看出，输出层的各个神经元都受到所有输入信号的影响" class="headerlink" title="可以看出，输出层的各个神经元都受到所有输入信号的影响"></a>可以看出，输出层的各个神经元都受到所有输入信号的影响</h4></blockquote><h4 id="注意到，上面这种形式的-softmax-函数有一个致命问题，那就是指数部分容易发生溢出"><a href="#注意到，上面这种形式的-softmax-函数有一个致命问题，那就是指数部分容易发生溢出" class="headerlink" title="注意到，上面这种形式的$softmax$函数有一个致命问题，那就是指数部分容易发生溢出"></a>注意到，上面这种形式的$softmax$函数有一个致命问题，那就是指数部分容易发生溢出</h4><h4 id="为此，对其进行改进"><a href="#为此，对其进行改进" class="headerlink" title="为此，对其进行改进"></a>为此，对其进行改进</h4><p><img src="http://picbed.yanzu.tech/img/DL/2/10.png"></p><h4 id="在进行-softmax-的指数的运算时，加上（或者减去）某个常数并不会改变运算的结果，这里的-C’-可以使用任何值，但是为了防止溢出，一般会使用输入信号中的最大值"><a href="#在进行-softmax-的指数的运算时，加上（或者减去）某个常数并不会改变运算的结果，这里的-C’-可以使用任何值，但是为了防止溢出，一般会使用输入信号中的最大值" class="headerlink" title="在进行$softmax$的指数的运算时，加上（或者减去）某个常数并不会改变运算的结果，这里的$C’$可以使用任何值，但是为了防止溢出，一般会使用输入信号中的最大值"></a>在进行$softmax$的指数的运算时，加上（或者减去）某个常数并不会改变运算的结果，这里的$C’$可以使用任何值，但是为了防止溢出，一般会使用输入信号中的最大值</h4><h4 id="softmax-函数的特征，其输出是0-0到1-0之间的实数，且输出值的总和是1，这是它的一个重要性质，正因如此，一般把-softmax-的输出解释为-概率"><a href="#softmax-函数的特征，其输出是0-0到1-0之间的实数，且输出值的总和是1，这是它的一个重要性质，正因如此，一般把-softmax-的输出解释为-概率" class="headerlink" title="$softmax$函数的特征，其输出是0.0到1.0之间的实数，且输出值的总和是1，这是它的一个重要性质，正因如此，一般把$softmax$的输出解释为 概率"></a>$softmax$函数的特征，其输出是0.0到1.0之间的实数，且输出值的总和是1，这是它的一个重要性质，正因如此，一般把$softmax$的输出解释为 概率</h4><h4 id="通过使用-softmax-函数，我们可以用概率的（统计的）方法处理问题"><a href="#通过使用-softmax-函数，我们可以用概率的（统计的）方法处理问题" class="headerlink" title="通过使用$softmax$函数，我们可以用概率的（统计的）方法处理问题"></a>通过使用$softmax$函数，我们可以用概率的（统计的）方法处理问题</h4><h4 id="另外，即便使用了-softmax-函数，各个元素之间的大小关-系也不会改变，因为指数函数-y-exp-x-是单调递增函数"><a href="#另外，即便使用了-softmax-函数，各个元素之间的大小关-系也不会改变，因为指数函数-y-exp-x-是单调递增函数" class="headerlink" title="另外，即便使用了$softmax$函数，各个元素之间的大小关 系也不会改变，因为指数函数$ y &#x3D; exp(x) $是单调递增函数"></a>另外，即便使用了$softmax$函数，各个元素之间的大小关 系也不会改变，因为指数函数$ y &#x3D; exp(x) $是单调递增函数</h4><h4 id="一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果，且即便使用-softmax-函数，输出值最大的神经元的位置也不会变，因此，神经网络在进行分类时，输出层的-softmax-函数可以省略（还有个原因是，指数函数的运算需要一定的计算机运算量）"><a href="#一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果，且即便使用-softmax-函数，输出值最大的神经元的位置也不会变，因此，神经网络在进行分类时，输出层的-softmax-函数可以省略（还有个原因是，指数函数的运算需要一定的计算机运算量）" class="headerlink" title="一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果，且即便使用$softmax$函数，输出值最大的神经元的位置也不会变，因此，神经网络在进行分类时，输出层的$softmax$函数可以省略（还有个原因是，指数函数的运算需要一定的计算机运算量）"></a>一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果，且即便使用$softmax$函数，输出值最大的神经元的位置也不会变，因此，神经网络在进行<strong>分类</strong>时，输出层的$softmax$函数可以省略（还有个原因是，指数函数的运算需要一定的计算机运算量）</h4><h4 id="求解机器学习问题的步骤可以分为学习和推理两个阶段，首先，在学习阶段进行模型的学习，然后，在推理阶段，用学到的模型对未知的数据进行推理（分类）"><a href="#求解机器学习问题的步骤可以分为学习和推理两个阶段，首先，在学习阶段进行模型的学习，然后，在推理阶段，用学到的模型对未知的数据进行推理（分类）" class="headerlink" title="求解机器学习问题的步骤可以分为学习和推理两个阶段，首先，在学习阶段进行模型的学习，然后，在推理阶段，用学到的模型对未知的数据进行推理（分类）"></a>求解机器学习问题的步骤可以分为学习和推理两个阶段，首先，在学习阶段进行模型的学习，然后，在推理阶段，用学到的模型对未知的数据进行推理（分类）</h4></blockquote><h4 id="手写数字识别"><a href="#手写数字识别" class="headerlink" title="手写数字识别"></a>手写数字识别</h4><blockquote><h4 id="one-hot表示是仅正确解标签为1，其余皆为0的数组"><a href="#one-hot表示是仅正确解标签为1，其余皆为0的数组" class="headerlink" title="one-hot表示是仅正确解标签为1，其余皆为0的数组"></a>one-hot表示是仅正确解标签为1，其余皆为0的数组</h4><h4 id="pickle可以可以将程序运行中的对象保存为文件，如果加载保存过的pickle文件，可以立刻复原之前程序运行中的对象（Numpy数组），使用pickle-load-可以直接还原所有数据结构"><a href="#pickle可以可以将程序运行中的对象保存为文件，如果加载保存过的pickle文件，可以立刻复原之前程序运行中的对象（Numpy数组），使用pickle-load-可以直接还原所有数据结构" class="headerlink" title="pickle可以可以将程序运行中的对象保存为文件，如果加载保存过的pickle文件，可以立刻复原之前程序运行中的对象（Numpy数组），使用pickle.load()可以直接还原所有数据结构"></a>pickle可以可以将程序运行中的对象保存为文件，如果加载保存过的pickle文件，可以立刻复原之前程序运行中的对象（Numpy数组），使用pickle.load()可以直接还原所有数据结构</h4><h4 id="argmax-np-array-axis-函数可以取出数组中的最大值的索引，axis-1指定沿着行方向寻找最大值"><a href="#argmax-np-array-axis-函数可以取出数组中的最大值的索引，axis-1指定沿着行方向寻找最大值" class="headerlink" title="argmax(np.array, axis)函数可以取出数组中的最大值的索引，axis&#x3D;1指定沿着行方向寻找最大值"></a>argmax(np.array, axis)函数可以取出数组中的最大值的索引，axis&#x3D;1指定沿着行方向寻找最大值</h4><h4 id="正规化（normalization）：把数据限定到某个范围内的处理"><a href="#正规化（normalization）：把数据限定到某个范围内的处理" class="headerlink" title="正规化（normalization）：把数据限定到某个范围内的处理"></a>正规化（normalization）：把数据限定到某个范围内的处理</h4><h4 id="预处理（pre-processing）：对神经网络的输入数据进行某种既定的转换"><a href="#预处理（pre-processing）：对神经网络的输入数据进行某种既定的转换" class="headerlink" title="预处理（pre-processing）：对神经网络的输入数据进行某种既定的转换"></a>预处理（pre-processing）：对神经网络的输入数据进行某种既定的转换</h4><h4 id="数据白化（whitening）：将数据整体的分布形状均匀化的方法"><a href="#数据白化（whitening）：将数据整体的分布形状均匀化的方法" class="headerlink" title="数据白化（whitening）：将数据整体的分布形状均匀化的方法"></a>数据白化（whitening）：将数据整体的分布形状均匀化的方法</h4><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4></blockquote></blockquote><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><blockquote><h4 id="阶跃函数的实现"><a href="#阶跃函数的实现" class="headerlink" title="阶跃函数的实现"></a>阶跃函数的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">step_fun</span>(<span class="params">x</span>):</span><br><span class="line"> y = x &gt; <span class="number">0</span></span><br><span class="line"> <span class="keyword">return</span> y.astype(np.<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># y = x &gt; 0是什么意思</span></span><br><span class="line"><span class="comment"># 对numpy数组进行bool运算，它会对数组内的每个元素做bool运算，得到一个对应bool值的bool数组，不是浮点型数组了</span></span><br><span class="line">x = np.array([-<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">y = x &gt; <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment"># astype()函数可以转换numpy数组的类型，需要对int指定精度，可以是32，也可以是64</span></span><br><span class="line">y = y.astype(np.int32)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><h4 id="阶跃函数的图像"><a href="#阶跃函数的图像" class="headerlink" title="阶跃函数的图像"></a>阶跃函数的图像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">step_fun</span>(<span class="params">x</span>):</span><br><span class="line"> <span class="keyword">return</span> np.array(x &gt; <span class="number">0</span>, dtype=np.int32)</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.1</span>)</span><br><span class="line">y = step_fun(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylim(-<span class="number">0.1</span>, <span class="number">1.1</span>) <span class="comment"># 指定y轴范围</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/DL/2/2.png"></p><h4 id="sigmoid函数的实现"><a href="#sigmoid函数的实现" class="headerlink" title="sigmoid函数的实现"></a>sigmoid函数的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.array([-<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>])</span><br><span class="line"><span class="built_in">print</span>(sigmoid(x))</span><br></pre></td></tr></table></figure><h4 id="sigmoid函数图像"><a href="#sigmoid函数图像" class="headerlink" title="sigmoid函数图像"></a>sigmoid函数图像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.1</span>)</span><br><span class="line">y = sigmoid(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylim(-<span class="number">0.1</span>, <span class="number">1.1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/DL/2/3.png"></p><h4 id="可以看到，阶跃函数和sigmoid函数的几个共同点："><a href="#可以看到，阶跃函数和sigmoid函数的几个共同点：" class="headerlink" title="可以看到，阶跃函数和sigmoid函数的几个共同点："></a>可以看到，阶跃函数和sigmoid函数的几个共同点：</h4><h4 id="一是，当输入信号为重要信息时，阶跃函数和sigmoid函数都会输出较大的值；当输入信号为不重要的信息时，两者都输出较小的值"><a href="#一是，当输入信号为重要信息时，阶跃函数和sigmoid函数都会输出较大的值；当输入信号为不重要的信息时，两者都输出较小的值" class="headerlink" title="一是，当输入信号为重要信息时，阶跃函数和sigmoid函数都会输出较大的值；当输入信号为不重要的信息时，两者都输出较小的值"></a>一是，当输入信号为重要信息时，阶跃函数和sigmoid函数都会输出较大的值；当输入信号为不重要的信息时，两者都输出较小的值</h4><h4 id="另一个是，不管输入信号有多小，或者有多大，输出信号的值都在0到1之间"><a href="#另一个是，不管输入信号有多小，或者有多大，输出信号的值都在0到1之间" class="headerlink" title="另一个是，不管输入信号有多小，或者有多大，输出信号的值都在0到1之间"></a>另一个是，不管输入信号有多小，或者有多大，输出信号的值都在0到1之间</h4><h4 id="另外，两者均是非线性函数，不管是朴素感知机还是神经网络，其激活函数必须是非线性函数，不能是线性函数"><a href="#另外，两者均是非线性函数，不管是朴素感知机还是神经网络，其激活函数必须是非线性函数，不能是线性函数" class="headerlink" title="另外，两者均是非线性函数，不管是朴素感知机还是神经网络，其激活函数必须是非线性函数，不能是线性函数"></a>另外，两者均是非线性函数，不管是朴素感知机还是神经网络，其激活函数必须是非线性函数，不能是线性函数</h4><h4 id="ReLU函数的实现"><a href="#ReLU函数的实现" class="headerlink" title="ReLU函数的实现"></a>ReLU函数的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">x</span>):</span><br><span class="line"> <span class="keyword">return</span> np.maximum(<span class="number">0</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.array([-<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>])</span><br><span class="line"><span class="built_in">print</span>(relu(x))</span><br></pre></td></tr></table></figure><h4 id="ReLU函数的的图像"><a href="#ReLU函数的的图像" class="headerlink" title="ReLU函数的的图像"></a>ReLU函数的的图像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-<span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">1.0</span>)</span><br><span class="line">y = relu(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylim(-<span class="number">1.0</span>, <span class="number">6.0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/DL/2/4.png"></p><h4 id="多维数组的运算"><a href="#多维数组的运算" class="headerlink" title="多维数组的运算"></a>多维数组的运算</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="built_in">print</span>(np.ndim(A)) <span class="comment"># 输出数组的维数</span></span><br><span class="line"><span class="built_in">print</span>(np.shape(A)) <span class="comment"># 输出数组的形状，其结果是一个元组</span></span><br><span class="line"><span class="built_in">print</span>(A.shape) <span class="comment"># 另外一种方式</span></span><br><span class="line"><span class="built_in">print</span>(A.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组，注意二维以及高维数组还需要一个额外的中括号括起来</span></span><br><span class="line">B = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="built_in">print</span>(np.ndim(B)) <span class="comment"># 输出数组的维数</span></span><br><span class="line"><span class="built_in">print</span>(np.shape(B)) <span class="comment"># 输出数组的形状，其结果是一个元组</span></span><br><span class="line"><span class="built_in">print</span>(B.shape) <span class="comment"># 另外一种方式</span></span><br><span class="line"><span class="built_in">print</span>(B.shape[<span class="number">1</span>]) <span class="comment"># shape[0]是数组的行数，shape[1]是数组的列数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2 * 2 的矩阵乘法</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(A.shape)</span><br><span class="line">B = np.array([[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="built_in">print</span>(B.shape)</span><br><span class="line"><span class="built_in">print</span>(np.dot(A, B)) <span class="comment"># dot()接收两个numpy数组作为参数，返回数组的乘积</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2*3 和 3*2 的矩阵乘法</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(A.shape)</span><br><span class="line">B = np.array([[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(B.shape)</span><br><span class="line"><span class="built_in">print</span>(np.dot(A, B)) <span class="comment"># dot()接收两个numpy数组作为参数，返回数组的乘积</span></span><br><span class="line"><span class="built_in">print</span>(A @ B)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于一维numpy数组的乘法运算，同样是借助了广播功能</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(A.shape)</span><br><span class="line">B = np.array([<span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(B.shape)</span><br><span class="line"><span class="built_in">print</span>(np.dot(A, B))</span><br></pre></td></tr></table></figure><h4 id="神经网络的内积"><a href="#神经网络的内积" class="headerlink" title="神经网络的内积"></a>神经网络的内积</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(X.shape)</span><br><span class="line">W = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(W.shape)</span><br><span class="line">Y = np.dot(X, W)</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure></blockquote><h4 id="第0层到第1层之间信号传递的实现"><a href="#第0层到第1层之间信号传递的实现" class="headerlink" title="第0层到第1层之间信号传递的实现"></a>第0层到第1层之间信号传递的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([<span class="number">1.0</span>, <span class="number">0.5</span>])</span><br><span class="line">W1 = np.array([[<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.5</span>], [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>]])</span><br><span class="line">B1 = np.array([<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>])</span><br><span class="line"><span class="built_in">print</span>(W1.shape)</span><br><span class="line"><span class="built_in">print</span>(X.shape)</span><br><span class="line"><span class="built_in">print</span>(B1.shape)</span><br><span class="line">A1 = np.dot(X, W1) + B1</span><br><span class="line"><span class="built_in">print</span>(A1)</span><br><span class="line">Z1 = sigmoid(A1)</span><br><span class="line"><span class="built_in">print</span>(Z1)</span><br></pre></td></tr></table></figure><h4 id="第1层到第2层之间信号传递的实现-1"><a href="#第1层到第2层之间信号传递的实现-1" class="headerlink" title="第1层到第2层之间信号传递的实现"></a>第1层到第2层之间信号传递的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">W2 = np.array([[<span class="number">0.1</span>, <span class="number">0.4</span>], [<span class="number">0.2</span>, <span class="number">0.5</span>], [<span class="number">0.3</span>, <span class="number">0.6</span>]])</span><br><span class="line">B2 = np.array([<span class="number">0.1</span>, <span class="number">0.2</span>])</span><br><span class="line"><span class="built_in">print</span>(Z1.shape)</span><br><span class="line"><span class="built_in">print</span>(W2.shape)</span><br><span class="line"><span class="built_in">print</span>(B2.shape)</span><br><span class="line"><span class="comment"># Z2 从第一层的输出变成了第二层的输入了，新的(x1, x2, x3)</span></span><br><span class="line">A2 = np.dot(Z1, W2) + B2</span><br><span class="line"><span class="built_in">print</span>(A2)</span><br><span class="line">Z2 = sigmoid(A2)</span><br><span class="line"><span class="built_in">print</span>(Z2)</span><br></pre></td></tr></table></figure><h4 id="第2层到输出层之间信号传递的实现-1"><a href="#第2层到输出层之间信号传递的实现-1" class="headerlink" title="第2层到输出层之间信号传递的实现"></a>第2层到输出层之间信号传递的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，这两层之间的激活函数与之前隐藏层的有所不同了</span></span><br><span class="line"><span class="comment"># 这里的激活函数是恒等函数，就是输入是什么输出就是什么</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">identify_fun</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">W3 = np.array([[<span class="number">0.1</span>, <span class="number">0.3</span>], [<span class="number">0.2</span>, <span class="number">0.4</span>]])</span><br><span class="line">B3 = np.array([<span class="number">0.1</span>, <span class="number">0.2</span>])</span><br><span class="line"><span class="built_in">print</span>(W3.shape)</span><br><span class="line"><span class="built_in">print</span>(B3.shape)</span><br><span class="line"></span><br><span class="line">A3 = np.dot(Z2, W3) + B3</span><br><span class="line">Y = identify_fun(A3)</span><br><span class="line"><span class="built_in">print</span>(A3.shape)</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure><h4 id="写成函数形式，实现3层神经网络"><a href="#写成函数形式，实现3层神经网络" class="headerlink" title="写成函数形式，实现3层神经网络"></a>写成函数形式，实现3层神经网络</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_network</span>():</span><br><span class="line">    network = &#123;&#125;</span><br><span class="line">    network[<span class="string">&#x27;W1&#x27;</span>] = np.array([[<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.5</span>], [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>]])</span><br><span class="line">    network[<span class="string">&#x27;b1&#x27;</span>] = np.array([<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>])</span><br><span class="line">    network[<span class="string">&#x27;W2&#x27;</span>] = np.array([[<span class="number">0.1</span>, <span class="number">0.4</span>], [<span class="number">0.2</span>, <span class="number">0.5</span>], [<span class="number">0.3</span>, <span class="number">0.6</span>]])</span><br><span class="line">    network[<span class="string">&#x27;b2&#x27;</span>] = np.array([<span class="number">0.1</span>, <span class="number">0.2</span>])</span><br><span class="line">    network[<span class="string">&#x27;W3&#x27;</span>] = np.array([[<span class="number">0.1</span>, <span class="number">0.3</span>], [<span class="number">0.2</span>, <span class="number">0.4</span>]])</span><br><span class="line">    network[<span class="string">&#x27;b3&#x27;</span>] = np.array([<span class="number">0.1</span>, <span class="number">0.2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> network</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">network, x</span>):</span><br><span class="line">    W1, W2, W3 = network[<span class="string">&#x27;W1&#x27;</span>], network[<span class="string">&#x27;W2&#x27;</span>], network[<span class="string">&#x27;W3&#x27;</span>]</span><br><span class="line">    b1, b2, b3 = network[<span class="string">&#x27;b1&#x27;</span>], network[<span class="string">&#x27;b2&#x27;</span>], network[<span class="string">&#x27;b3&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    a1 = np.dot(x, W1) + b1</span><br><span class="line">    z1 = sigmoid(a1)</span><br><span class="line">    a2 = np.dot(z1, W2) + b2</span><br><span class="line">    z2 = sigmoid(a2)</span><br><span class="line">    a3 = np.dot(z2, W3) + b3</span><br><span class="line">    y = identify_fun(a3)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">network = init_network()</span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">0.5</span>])</span><br><span class="line">y = forward(network, x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><h4 id="softmax-函数的实现"><a href="#softmax-函数的实现" class="headerlink" title="$softmax$函数的实现"></a>$softmax$函数的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">a</span>):</span><br><span class="line">    exp_a = np.exp(a)</span><br><span class="line">    sum_exp_a = np.<span class="built_in">sum</span>(exp_a)</span><br><span class="line">    y = exp_a / sum_exp_a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0.3</span>, <span class="number">2.9</span>, <span class="number">4.0</span>])</span><br><span class="line"><span class="built_in">print</span>(softmax(a))</span><br></pre></td></tr></table></figure><h4 id="改进后的-softmax-的实现"><a href="#改进后的-softmax-的实现" class="headerlink" title="改进后的$softmax$的实现"></a>改进后的$softmax$的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">a</span>):</span><br><span class="line">    c = np.<span class="built_in">max</span>(a)</span><br><span class="line">    exp_a = np.exp(a - c)</span><br><span class="line">    sum_exp_a = np.<span class="built_in">sum</span>(exp_a)</span><br><span class="line">    y = exp_a / sum_exp_a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1010</span>, <span class="number">1000</span>, <span class="number">990</span>])</span><br><span class="line"><span class="built_in">print</span>(softmax(a))</span><br></pre></td></tr></table></figure><h4 id="手写数字识别-1"><a href="#手写数字识别-1" class="headerlink" title="手写数字识别"></a>手写数字识别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;../../py_pro/DL/&#x27;</span>) <span class="comment"># 指定获取mnist数据集的脚本路径</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> dataset.mnist <span class="keyword">import</span> load_mnist</span><br><span class="line"><span class="comment"># (训练图像，训练标签)，(测试图像，测试标签)</span></span><br><span class="line">(x_train, t_train), (x_test, t_test) = load_mnist(normalize=<span class="literal">True</span>, flatten=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x_train.shape)</span><br><span class="line"><span class="built_in">print</span>(t_train.shape)</span><br><span class="line"><span class="built_in">print</span>(x_test.shape)</span><br><span class="line"><span class="built_in">print</span>(t_test.shape)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;../../py_pro/DL/&#x27;</span>) <span class="comment"># 指定获取mnist数据集的脚本路径</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> dataset.mnist <span class="keyword">import</span> load_mnist</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">img_show</span>(<span class="params">img</span>):</span><br><span class="line">    pil_img = Image.fromarray(np.uint8(img))</span><br><span class="line">    pil_img.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(x_train, t_train), (x_test, t_test) = load_mnist(normalize=<span class="literal">False</span>, flatten=<span class="literal">True</span>)</span><br><span class="line">img = x_train[<span class="number">0</span>]</span><br><span class="line">label = t_train[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(label)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line">img = img.reshape(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line"></span><br><span class="line">img_show(img)</span><br></pre></td></tr></table></figure><h4 id="神经网络的推理处理"><a href="#神经网络的推理处理" class="headerlink" title="神经网络的推理处理"></a>神经网络的推理处理</h4><blockquote><h4 id="神经网络的输入层有784个神经元，输出层有10个神经元，784是图片像素是28-28，10是0-910种类别，有2个隐藏层，神经元数量分别是50、100，这个可以是任意值"><a href="#神经网络的输入层有784个神经元，输出层有10个神经元，784是图片像素是28-28，10是0-910种类别，有2个隐藏层，神经元数量分别是50、100，这个可以是任意值" class="headerlink" title="神经网络的输入层有784个神经元，输出层有10个神经元，784是图片像素是28*28，10是0~910种类别，有2个隐藏层，神经元数量分别是50、100，这个可以是任意值"></a>神经网络的输入层有784个神经元，输出层有10个神经元，784是图片像素是28*28，10是0~910种类别，有2个隐藏层，神经元数量分别是50、100，这个可以是任意值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line">    (x_train, t_train), (x_test, t_test) = load_mnist(normalize=<span class="literal">False</span>, flatten=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> x_test, t_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_network</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;../../py_pro/DL/ch03/sample_weight.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        network = pickle.load(f)</span><br><span class="line">    <span class="keyword">return</span> network</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">network, x</span>):</span><br><span class="line">    W1, W2, W3 = network[<span class="string">&#x27;W1&#x27;</span>], network[<span class="string">&#x27;W2&#x27;</span>], network[<span class="string">&#x27;W3&#x27;</span>]</span><br><span class="line">    b1, b2, b3 = network[<span class="string">&#x27;b1&#x27;</span>], network[<span class="string">&#x27;b2&#x27;</span>], network[<span class="string">&#x27;b3&#x27;</span>]</span><br><span class="line">    a1 = np.dot(x, W1) + b1</span><br><span class="line">    z1 = sigmoid(a1)</span><br><span class="line">    a2 = np.dot(z1, W2) + b2</span><br><span class="line">    z2 = sigmoid(a2)</span><br><span class="line">    a3 = np.dot(z2, W3) + b3</span><br><span class="line">    y = softmax(a3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">x, t = get_data()</span><br><span class="line">network = init_network()</span><br><span class="line"></span><br><span class="line">accuracy_cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    y = predict(network, x[i])</span><br><span class="line">    p = np.argmax(y)</span><br><span class="line">    <span class="keyword">if</span> p == t[i]:</span><br><span class="line">        accuracy_cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Accuracy: &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">float</span>(accuracy_cnt) / <span class="built_in">len</span>(x)))</span><br></pre></td></tr></table></figure><h4 id="批处理方式"><a href="#批处理方式" class="headerlink" title="批处理方式"></a>批处理方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x, t = get_data()</span><br><span class="line">network = init_network()</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">accuracy_cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(x), batch_size):</span><br><span class="line">    x_batch = x[i:i + batch_size]</span><br><span class="line">    y_batch = predict(network, x_batch)</span><br><span class="line">    p = np.argmax(y_batch, axis=<span class="number">1</span>)</span><br><span class="line">    accuracy_cnt += np.<span class="built_in">sum</span>(p == t[i:i+batch_size])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Accuracy: &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">float</span>(accuracy_cnt) / <span class="built_in">len</span>(x)))</span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> DL </tag>
            
            <tag> gnaw_book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DL之路---啃鱼书（1）</title>
      <link href="/2025/06/11/20/"/>
      <url>/2025/06/11/20/</url>
      
        <content type="html"><![CDATA[<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><blockquote><h4 id="感知机（Perceptron）是一种人工神经网络，用于解决二分类问题"><a href="#感知机（Perceptron）是一种人工神经网络，用于解决二分类问题" class="headerlink" title="感知机（Perceptron）是一种人工神经网络，用于解决二分类问题"></a>感知机（Perceptron）是一种人工神经网络，用于解决二分类问题</h4><h4 id="它模拟的是生物神经元的行为，主要包括："><a href="#它模拟的是生物神经元的行为，主要包括：" class="headerlink" title="它模拟的是生物神经元的行为，主要包括："></a>它模拟的是生物神经元的行为，主要包括：</h4><blockquote><h4 id="输入：多个特征值-x-1-x-2…x-n"><a href="#输入：多个特征值-x-1-x-2…x-n" class="headerlink" title="输入：多个特征值 $ x_1,x_2…x_n $"></a>输入：多个特征值 $ x_1,x_2…x_n $</h4><h4 id="权重：每个输入对应一个权重-omega-1-omega-2…-omega-3"><a href="#权重：每个输入对应一个权重-omega-1-omega-2…-omega-3" class="headerlink" title="权重：每个输入对应一个权重 $ \omega_1,\omega_2…\omega_3 $"></a>权重：每个输入对应一个权重 $ \omega_1,\omega_2…\omega_3 $</h4><h4 id="偏置：一个常数项-b"><a href="#偏置：一个常数项-b" class="headerlink" title="偏置：一个常数项 $ b $"></a>偏置：一个常数项 $ b $</h4></blockquote><h4 id="偏置是用于控制神经元被激活的容易程度"><a href="#偏置是用于控制神经元被激活的容易程度" class="headerlink" title="偏置是用于控制神经元被激活的容易程度"></a>偏置是用于控制神经元被激活的容易程度</h4><h4 id="权重是用于控制各个信号的重要性的"><a href="#权重是用于控制各个信号的重要性的" class="headerlink" title="权重是用于控制各个信号的重要性的"></a>权重是用于控制各个信号的重要性的</h4><h4 id="而激活函数则是决定以什么方式来激活输入信号的总和"><a href="#而激活函数则是决定以什么方式来激活输入信号的总和" class="headerlink" title="而激活函数则是决定以什么方式来激活输入信号的总和"></a>而激活函数则是决定以什么方式来激活输入信号的总和</h4><h4 id="数学表达式为："><a href="#数学表达式为：" class="headerlink" title="数学表达式为："></a>数学表达式为：</h4><p>$$<br>y &#x3D; sign(\omega \cdot x + b)<br>$$</p><h4 id="其中，-omega-cdot-x-sum-i-1-n-omega-i-x-i-，sign函数定义为："><a href="#其中，-omega-cdot-x-sum-i-1-n-omega-i-x-i-，sign函数定义为：" class="headerlink" title="其中，$ \omega \cdot x &#x3D; \sum_{i&#x3D;1}^n \omega_i x_i $，sign函数定义为："></a>其中，$ \omega \cdot x &#x3D; \sum_{i&#x3D;1}^n \omega_i x_i $，sign函数定义为：</h4><p>$$<br> sign(z) &#x3D;<br>\begin{cases}<br>1 &amp; \text{if } z &gt; 0, \<br>-1 &amp; \text otherwise.<br>\end{cases}<br>$$</p><h4 id="工作原理：找到一个线性超平面（即一条直线或一个超平面）来将数据分为两类（-1-和-1）。通过不断调整权重-omega-和偏置-b-，使得训练数据被正确分类"><a href="#工作原理：找到一个线性超平面（即一条直线或一个超平面）来将数据分为两类（-1-和-1）。通过不断调整权重-omega-和偏置-b-，使得训练数据被正确分类" class="headerlink" title="工作原理：找到一个线性超平面（即一条直线或一个超平面）来将数据分为两类（+1 和 -1）。通过不断调整权重 $ \omega $ 和偏置 $ b $，使得训练数据被正确分类"></a>工作原理：找到一个线性超平面（即一条直线或一个超平面）来将数据分为两类（+1 和 -1）。通过不断调整权重 $ \omega $ 和偏置 $ b $，使得训练数据被正确分类</h4><h4 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h4><blockquote><h4 id="它的学习规则是一种迭代算法，所谓的学习就是确定合适的参数的过程"><a href="#它的学习规则是一种迭代算法，所谓的学习就是确定合适的参数的过程" class="headerlink" title="它的学习规则是一种迭代算法，所谓的学习就是确定合适的参数的过程"></a>它的学习规则是一种迭代算法，所谓的学习就是确定合适的参数的过程</h4><blockquote><h4 id="初始化：随机初始化权重-omega-和偏置-b"><a href="#初始化：随机初始化权重-omega-和偏置-b" class="headerlink" title="初始化：随机初始化权重 $ \omega $ 和偏置 $ b $"></a>初始化：随机初始化权重 $ \omega $ 和偏置 $ b $</h4><h4 id="逐个遍历样本：对于每个训练样本-x-i-y-i-，如果预测值与真实值不一致（即-y-i-omega-cdot-x-i-b-le-0-），就更新参数"><a href="#逐个遍历样本：对于每个训练样本-x-i-y-i-，如果预测值与真实值不一致（即-y-i-omega-cdot-x-i-b-le-0-），就更新参数" class="headerlink" title="逐个遍历样本：对于每个训练样本 $ (x_i,y_i) $，如果预测值与真实值不一致（即 $ y_i(\omega \cdot x_i+b) \le 0 $ ），就更新参数"></a>逐个遍历样本：对于每个训练样本 $ (x_i,y_i) $，如果预测值与真实值不一致（即 $ y_i(\omega \cdot x_i+b) \le 0 $ ），就更新参数</h4><p>$$<br>\omega \leftarrow \omega + \eta y_i x_i \<br>b \leftarrow b + \eta y_i<br>$$</p><h4 id="其中，-eta-是学习率"><a href="#其中，-eta-是学习率" class="headerlink" title="其中，$ \eta $ 是学习率"></a>其中，$ \eta $ 是学习率</h4></blockquote><h4 id="重复训练，直到所有样本被正确分类或达到最大迭代次数"><a href="#重复训练，直到所有样本被正确分类或达到最大迭代次数" class="headerlink" title="重复训练，直到所有样本被正确分类或达到最大迭代次数"></a>重复训练，直到所有样本被正确分类或达到最大迭代次数</h4></blockquote></blockquote><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><blockquote><h4 id="与门实现"><a href="#与门实现" class="headerlink" title="与门实现"></a>与门实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">AND</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    w1, w2, theta = <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.7</span></span><br><span class="line">    tmp = x1 * w1 + x2 * w2</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= theta:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> tmp &gt; theta:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(AND(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(AND(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(AND(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(AND(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="或门实现"><a href="#或门实现" class="headerlink" title="或门实现"></a>或门实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">OR</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    w1, w2, theta = <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.4</span></span><br><span class="line">    tmp = x1 * w1 + x2 * w2</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= theta:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(OR(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(OR(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(OR(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(OR(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="与非门实现"><a href="#与非门实现" class="headerlink" title="与非门实现"></a>与非门实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">NotAnd</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    <span class="comment"># 直接对与门取反</span></span><br><span class="line">    w1 , w2, theta = -<span class="number">0.5</span>, -<span class="number">0.5</span>, -<span class="number">0.7</span></span><br><span class="line">    tmp = w1 * x1 + w2 * x2</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= theta:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(NotAnd(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(NotAnd(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(NotAnd(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(NotAnd(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="或非门实现"><a href="#或非门实现" class="headerlink" title="或非门实现"></a>或非门实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">NotOr</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    <span class="comment"># 直接对或门取反</span></span><br><span class="line">    w1 , w2, theta = -<span class="number">0.5</span>, -<span class="number">0.5</span>, -<span class="number">0.4</span></span><br><span class="line">    tmp = w1 * x1 + w2 * x2</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= theta:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(NotOr(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(NotOr(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(NotOr(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(NotOr(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="导入权重和偏置之后"><a href="#导入权重和偏置之后" class="headerlink" title="导入权重和偏置之后"></a>导入权重和偏置之后</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">And</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([<span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">    b = -<span class="number">0.7</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w * x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(And(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(And(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(And(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(And(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">NOTAnd</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([-<span class="number">0.5</span>, -<span class="number">0.5</span>])</span><br><span class="line">    b = <span class="number">0.7</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w * x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(NOTAnd(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(NOTAnd(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(NOTAnd(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(NOTAnd(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="单层感知机无法表示异或门，单层感知机只能划分线性空间，无法划分非线性空间-单层感知机也叫朴素感知机"><a href="#单层感知机无法表示异或门，单层感知机只能划分线性空间，无法划分非线性空间-单层感知机也叫朴素感知机" class="headerlink" title="单层感知机无法表示异或门，单层感知机只能划分线性空间，无法划分非线性空间(单层感知机也叫朴素感知机)"></a>单层感知机无法表示异或门，单层感知机只能划分线性空间，无法划分非线性空间(单层感知机也叫朴素感知机)</h4><h4 id="多层感知机（神经网络）"><a href="#多层感知机（神经网络）" class="headerlink" title="多层感知机（神经网络）"></a>多层感知机（神经网络）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与非门、或门和与门实现异或门</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">XOR</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    s1 = NOTAnd(x1, x2)</span><br><span class="line">    s2 = OR(x1, x2)</span><br><span class="line">    y = And(s1, s2)</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(XOR(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(XOR(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(XOR(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(XOR(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> DL </tag>
            
            <tag> gnaw_book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RL之路---第二弹</title>
      <link href="/2025/05/30/19/"/>
      <url>/2025/05/30/19/</url>
      
        <content type="html"><![CDATA[<h1 id="贝尔曼方程"><a href="#贝尔曼方程" class="headerlink" title="贝尔曼方程"></a>贝尔曼方程</h1><h3 id="第一部分——return"><a href="#第一部分——return" class="headerlink" title="第一部分——return"></a>第一部分——return</h3><blockquote><h4 id="return-能够作为策略好坏的一个评估标准"><a href="#return-能够作为策略好坏的一个评估标准" class="headerlink" title="return 能够作为策略好坏的一个评估标准"></a>return 能够作为策略好坏的一个评估标准</h4><h4 id="下面通过三种情况来说明这个问题"><a href="#下面通过三种情况来说明这个问题" class="headerlink" title="下面通过三种情况来说明这个问题"></a>下面通过三种情况来说明这个问题</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/1.png"></p><h4 id="第一种策略"><a href="#第一种策略" class="headerlink" title="第一种策略"></a>第一种策略</h4><blockquote><h4 id="按照策略1，从-s1-出发，往下去-s3，再往右到达-s4，discounted-return计算如下"><a href="#按照策略1，从-s1-出发，往下去-s3，再往右到达-s4，discounted-return计算如下" class="headerlink" title="按照策略1，从 s1 出发，往下去 s3，再往右到达 s4，discounted return计算如下"></a>按照策略1，从 s1 出发，往下去 s3，再往右到达 s4，discounted return计算如下</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/2.png"></p><h4 id="gamma-是衰减系数"><a href="#gamma-是衰减系数" class="headerlink" title="gamma 是衰减系数"></a>gamma 是衰减系数</h4></blockquote><h4 id="第二种策略"><a href="#第二种策略" class="headerlink" title="第二种策略"></a>第二种策略</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/3.png"></h4><h4 id="第三种策略"><a href="#第三种策略" class="headerlink" title="第三种策略"></a>第三种策略</h4><blockquote><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/4.png"></p><h4 id="注意，严格说来，这个return3-已经不是我们所说的return了，因为return是针对一条轨迹定义的，针对一个trajectory定义的，这里实际上是有两个轨迹，这里所做的是求取平均值，也即求expectation（期望），这个return3就是state-value"><a href="#注意，严格说来，这个return3-已经不是我们所说的return了，因为return是针对一条轨迹定义的，针对一个trajectory定义的，这里实际上是有两个轨迹，这里所做的是求取平均值，也即求expectation（期望），这个return3就是state-value" class="headerlink" title="注意，严格说来，这个return3 已经不是我们所说的return了，因为return是针对一条轨迹定义的，针对一个trajectory定义的，这里实际上是有两个轨迹，这里所做的是求取平均值，也即求expectation（期望），这个return3就是state value"></a>注意，严格说来，这个return3 已经不是我们所说的return了，因为return是针对一条轨迹定义的，针对一个trajectory定义的，这里实际上是有两个轨迹，这里所做的是求取平均值，也即求expectation（期望），这个return3就是state value</h4></blockquote><h4 id="显然，return1-return3-return2，那么对应的就是策略1最好，策略3居中，策略2最差"><a href="#显然，return1-return3-return2，那么对应的就是策略1最好，策略3居中，策略2最差" class="headerlink" title="显然，return1 &gt; return3 &gt; return2，那么对应的就是策略1最好，策略3居中，策略2最差"></a>显然，return1 &gt; return3 &gt; return2，那么对应的就是策略1最好，策略3居中，策略2最差</h4></blockquote><h3 id="第二部分——return的计算"><a href="#第二部分——return的计算" class="headerlink" title="第二部分——return的计算"></a>第二部分——return的计算</h3><blockquote><h4 id="以图中的例子为例"><a href="#以图中的例子为例" class="headerlink" title="以图中的例子为例"></a>以图中的例子为例</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/5.png"></p><h4 id="用-v-i来表示从-s-i-出发对应的return"><a href="#用-v-i来表示从-s-i-出发对应的return" class="headerlink" title="用 v_i来表示从 s_i 出发对应的return"></a>用 v_i来表示从 s_i 出发对应的return</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/6.png"></p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/7.png"></p><h4 id="这里的方法二说明了什么一个问题呢，从当前状态出发，return的值，就等于当前的reward-下一状态的return-衰减因子gamma，也就是说从一个状态出发，它的return是依赖于其他状态的return的，这种思想在强化学习中被称之为-bootstrapping，这种思想是从自身出发，不断迭代所得到的结果"><a href="#这里的方法二说明了什么一个问题呢，从当前状态出发，return的值，就等于当前的reward-下一状态的return-衰减因子gamma，也就是说从一个状态出发，它的return是依赖于其他状态的return的，这种思想在强化学习中被称之为-bootstrapping，这种思想是从自身出发，不断迭代所得到的结果" class="headerlink" title="这里的方法二说明了什么一个问题呢，从当前状态出发，return的值，就等于当前的reward + 下一状态的return * 衰减因子gamma，也就是说从一个状态出发，它的return是依赖于其他状态的return的，这种思想在强化学习中被称之为 bootstrapping，这种思想是从自身出发，不断迭代所得到的结果"></a>这里的方法二说明了什么一个问题呢，从当前状态出发，return的值，就等于当前的reward + 下一状态的return * 衰减因子gamma，也就是说从一个状态出发，它的return是依赖于其他状态的return的，这种思想在强化学习中被称之为 bootstrapping，这种思想是从自身出发，不断迭代所得到的结果</h4><h4 id="通过矩阵的形式给出上面的四个式子"><a href="#通过矩阵的形式给出上面的四个式子" class="headerlink" title="通过矩阵的形式给出上面的四个式子"></a>通过矩阵的形式给出上面的四个式子</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/8.png"></p><h4 id="对该式子进行求解得到-v，实际上这个式子就是-贝尔曼方程，但这是一个非常简单的贝尔曼方程"><a href="#对该式子进行求解得到-v，实际上这个式子就是-贝尔曼方程，但这是一个非常简单的贝尔曼方程" class="headerlink" title="对该式子进行求解得到 v，实际上这个式子就是 贝尔曼方程，但这是一个非常简单的贝尔曼方程"></a>对该式子进行求解得到 v，实际上这个式子就是 贝尔曼方程，但这是一个非常简单的贝尔曼方程</h4></blockquote><h3 id="第三部分——state-value"><a href="#第三部分——state-value" class="headerlink" title="第三部分——state value"></a>第三部分——state value</h3><blockquote><h4 id="先来看一个单步的过程"><a href="#先来看一个单步的过程" class="headerlink" title="先来看一个单步的过程"></a>先来看一个单步的过程</h4><p>$$<br>S_t \xrightarrow{A_t} R_{t+1}, S_{t+1}<br>$$</p><h4 id="在这个过程中，都存在一个条件概率"><a href="#在这个过程中，都存在一个条件概率" class="headerlink" title="在这个过程中，都存在一个条件概率"></a>在这个过程中，都存在一个条件概率</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/9.png"></p><h4 id="再来看一个多步的过程-trajectory"><a href="#再来看一个多步的过程-trajectory" class="headerlink" title="再来看一个多步的过程 trajectory"></a>再来看一个多步的过程 trajectory</h4><p>$$<br>S_t \xrightarrow{A_t} R_{t+1}, S_{t+1} \xrightarrow{A_{t+1}} R_{t+2}, S_{t+2} \xrightarrow{A_{t+2}} R_{t+3}, \ldots<br>$$</p><h4 id="其对应的-discounted-return如下"><a href="#其对应的-discounted-return如下" class="headerlink" title="其对应的 discounted return如下"></a>其对应的 discounted return如下</h4><p>$$<br>G_t &#x3D; R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \ldots<br>$$</p><h4 id="这里的G-t-也是一个随机变量"><a href="#这里的G-t-也是一个随机变量" class="headerlink" title="这里的G_t 也是一个随机变量"></a>这里的G_t 也是一个随机变量</h4><h4 id="正式介绍-state-value"><a href="#正式介绍-state-value" class="headerlink" title="正式介绍 state value"></a>正式介绍 state value</h4><blockquote><h4 id="state-value-实际上就是-G-t-的期望值（expectation）或平均值"><a href="#state-value-实际上就是-G-t-的期望值（expectation）或平均值" class="headerlink" title="state value 实际上就是 G_t 的期望值（expectation）或平均值"></a>state value 实际上就是 G_t 的期望值（expectation）或平均值</h4><p>$$<br>v_\pi(s) &#x3D; \mathbb{E}[G_t | S_t &#x3D; s]<br>$$</p><h4 id="它是关于状态s的一个函数，所以在不同状态下，对应不同的G-t也对应不同的-state-value"><a href="#它是关于状态s的一个函数，所以在不同状态下，对应不同的G-t也对应不同的-state-value" class="headerlink" title="它是关于状态s的一个函数，所以在不同状态下，对应不同的G_t也对应不同的 state value"></a>它是关于状态s的一个函数，所以在不同状态下，对应不同的G_t也对应不同的 state value</h4><h4 id="另外，它也是关于策略pi的函数，也可以写为-v-s-pi-，不同的策略会得到不同的轨迹，从而得到不同的G-t"><a href="#另外，它也是关于策略pi的函数，也可以写为-v-s-pi-，不同的策略会得到不同的轨迹，从而得到不同的G-t" class="headerlink" title="另外，它也是关于策略pi的函数，也可以写为 v(s , pi)，不同的策略会得到不同的轨迹，从而得到不同的G_t"></a>另外，它也是关于策略pi的函数，也可以写为 v(s , pi)，不同的策略会得到不同的轨迹，从而得到不同的G_t</h4><h4 id="state-value不仅仅是一个数值，当其值很大时，说明当前状态具有很高的价值"><a href="#state-value不仅仅是一个数值，当其值很大时，说明当前状态具有很高的价值" class="headerlink" title="state value不仅仅是一个数值，当其值很大时，说明当前状态具有很高的价值"></a>state value不仅仅是一个数值，当其值很大时，说明当前状态具有很高的价值</h4></blockquote><h4 id="return-与-state-value的区别"><a href="#return-与-state-value的区别" class="headerlink" title="return 与 state value的区别"></a>return 与 state value的区别</h4><blockquote><h4 id="return是针对单个trajectory而言的，单个trajectory的return（对应的是一种确定性，如拓扑图）"><a href="#return是针对单个trajectory而言的，单个trajectory的return（对应的是一种确定性，如拓扑图）" class="headerlink" title="return是针对单个trajectory而言的，单个trajectory的return（对应的是一种确定性，如拓扑图）"></a>return是针对单个trajectory而言的，单个trajectory的return（对应的是一种确定性，如拓扑图）</h4><h4 id="state-value是针对多个trajectory而言的，它是多个trajectory的return的平均值（对应的是一种随机性）"><a href="#state-value是针对多个trajectory而言的，它是多个trajectory的return的平均值（对应的是一种随机性）" class="headerlink" title="state value是针对多个trajectory而言的，它是多个trajectory的return的平均值（对应的是一种随机性）"></a>state value是针对多个trajectory而言的，它是多个trajectory的return的平均值（对应的是一种随机性）</h4></blockquote></blockquote><h3 id="第四部分——贝尔曼公式的推导"><a href="#第四部分——贝尔曼公式的推导" class="headerlink" title="第四部分——贝尔曼公式的推导"></a>第四部分——贝尔曼公式的推导</h3><blockquote><h4 id="贝尔曼公式就是用来计算上一部分提到的state-value，它描述了不同状态下state-value之间的关系"><a href="#贝尔曼公式就是用来计算上一部分提到的state-value，它描述了不同状态下state-value之间的关系" class="headerlink" title="贝尔曼公式就是用来计算上一部分提到的state value，它描述了不同状态下state value之间的关系"></a>贝尔曼公式就是用来计算上一部分提到的state value，它描述了不同状态下state value之间的关系</h4><h4 id="考虑这样一个trajectory"><a href="#考虑这样一个trajectory" class="headerlink" title="考虑这样一个trajectory"></a>考虑这样一个trajectory</h4><p>$$<br>S_t \xrightarrow{A_t} R_{t+1}, S_{t+1} \xrightarrow{A_{t+1}} R_{t+2}, S_{t+2} \xrightarrow{A_{t+2}} R_{t+3}, \ldots<br>$$</p><h4 id="对应的G-t（discounted-return）可以表示为"><a href="#对应的G-t（discounted-return）可以表示为" class="headerlink" title="对应的G_t（discounted return）可以表示为"></a>对应的G_t（discounted return）可以表示为</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/10.png"></p><h4 id="对应的v-s-pi-（state-value）可以表示为（贝尔曼公式）"><a href="#对应的v-s-pi-（state-value）可以表示为（贝尔曼公式）" class="headerlink" title="对应的v( s, pi)（state value）可以表示为（贝尔曼公式）"></a>对应的v( s, pi)（state value）可以表示为（贝尔曼公式）</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/11.png"></p><h4 id="上面的表达式中的第一项的详细表示"><a href="#上面的表达式中的第一项的详细表示" class="headerlink" title="上面的表达式中的第一项的详细表示"></a>上面的表达式中的第一项的详细表示</h4><blockquote><h4 id="在状态s下，采取行动a之后所得到的即时奖励r的期望值"><a href="#在状态s下，采取行动a之后所得到的即时奖励r的期望值" class="headerlink" title="在状态s下，采取行动a之后所得到的即时奖励r的期望值"></a>在状态s下，采取行动a之后所得到的即时奖励r的期望值</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/12.png"></p><h4 id="在当前状态s下，有多个可采取的action，每个action对应的一个概率-pi"><a href="#在当前状态s下，有多个可采取的action，每个action对应的一个概率-pi" class="headerlink" title="在当前状态s下，有多个可采取的action，每个action对应的一个概率 pi"></a>在当前状态s下，有多个可采取的action，每个action对应的一个概率 pi</h4><h4 id="当采取action-a，所得到的value就是"><a href="#当采取action-a，所得到的value就是" class="headerlink" title="当采取action a，所得到的value就是"></a>当采取action a，所得到的value就是</h4><p>$$<br>\mathbb{E}[R_{t+1} | S_t &#x3D; s, A_t &#x3D; a]<br>$$</p><h4 id="也等同于"><a href="#也等同于" class="headerlink" title="也等同于"></a>也等同于</h4><p>$$<br>\sum_{r} p(r | s, a) r<br>$$</p><h4 id="它的意思是，在状态s下，采取动作a，得到的即时奖励r的概率为p，最后乘以r本身"><a href="#它的意思是，在状态s下，采取动作a，得到的即时奖励r的概率为p，最后乘以r本身" class="headerlink" title="它的意思是，在状态s下，采取动作a，得到的即时奖励r的概率为p，最后乘以r本身"></a>它的意思是，在状态s下，采取动作a，得到的即时奖励r的概率为p，最后乘以r本身</h4><h4 id="所以这整个第一项的期望就是这么求来的，它实际上就是所能得到的即时奖励r的期望值"><a href="#所以这整个第一项的期望就是这么求来的，它实际上就是所能得到的即时奖励r的期望值" class="headerlink" title="所以这整个第一项的期望就是这么求来的，它实际上就是所能得到的即时奖励r的期望值"></a>所以这整个第一项的期望就是这么求来的，它实际上就是所能得到的即时奖励r的期望值</h4></blockquote><h4 id="第二部分的详细表示"><a href="#第二部分的详细表示" class="headerlink" title="第二部分的详细表示"></a>第二部分的详细表示</h4><blockquote><h4 id="在当前状态s下，下一个时刻的return的期望值"><a href="#在当前状态s下，下一个时刻的return的期望值" class="headerlink" title="在当前状态s下，下一个时刻的return的期望值"></a>在当前状态s下，下一个时刻的return的期望值</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/13.png"></p><h4 id="这里隐含了一个马尔科夫性，即下一状态，只取决于当前状态，与当前状态之前的状态无关"><a href="#这里隐含了一个马尔科夫性，即下一状态，只取决于当前状态，与当前状态之前的状态无关" class="headerlink" title="这里隐含了一个马尔科夫性，即下一状态，只取决于当前状态，与当前状态之前的状态无关"></a>这里隐含了一个马尔科夫性，即下一状态，只取决于当前状态，与当前状态之前的状态无关</h4><h4 id="其余的变换都是概率论中的一些技巧"><a href="#其余的变换都是概率论中的一些技巧" class="headerlink" title="其余的变换都是概率论中的一些技巧"></a>其余的变换都是概率论中的一些技巧</h4></blockquote><h4 id="然后就是正式给出贝尔曼公式的表达式（看起来好复杂！）"><a href="#然后就是正式给出贝尔曼公式的表达式（看起来好复杂！）" class="headerlink" title="然后就是正式给出贝尔曼公式的表达式（看起来好复杂！）"></a>然后就是正式给出贝尔曼公式的表达式（看起来好复杂！）</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/14.png"></p><h4 id="它描述了不同状态的state-value之间的关系，如上面所示，左边是s的state-value，右边的式子包含s’的state-value"><a href="#它描述了不同状态的state-value之间的关系，如上面所示，左边是s的state-value，右边的式子包含s’的state-value" class="headerlink" title="它描述了不同状态的state value之间的关系，如上面所示，左边是s的state value，右边的式子包含s’的state value"></a>它描述了不同状态的state value之间的关系，如上面所示，左边是s的state value，右边的式子包含s’的state value</h4><h4 id="另外，这是针对一个状态空间而言的，对应的可能是多个式子多个s，而不是一个单一的式子"><a href="#另外，这是针对一个状态空间而言的，对应的可能是多个式子多个s，而不是一个单一的式子" class="headerlink" title="另外，这是针对一个状态空间而言的，对应的可能是多个式子多个s，而不是一个单一的式子"></a>另外，这是针对一个状态空间而言的，对应的可能是多个式子多个s，而不是一个单一的式子</h4><h4 id="其求解思想就是-bootstrapping，还依赖于几个概率，第一个是概率是policy，求解出-state-value就是在评估策略的好坏，后面两个概率对应的是两个model，dynamic-model或-environment-model，这里的model可能是已知的也可能是未知的（model-free-RL）"><a href="#其求解思想就是-bootstrapping，还依赖于几个概率，第一个是概率是policy，求解出-state-value就是在评估策略的好坏，后面两个概率对应的是两个model，dynamic-model或-environment-model，这里的model可能是已知的也可能是未知的（model-free-RL）" class="headerlink" title="其求解思想就是 bootstrapping，还依赖于几个概率，第一个是概率是policy，求解出 state value就是在评估策略的好坏，后面两个概率对应的是两个model，dynamic model或 environment model，这里的model可能是已知的也可能是未知的（model free RL）"></a>其求解思想就是 bootstrapping，还依赖于几个概率，第一个是概率是policy，求解出 state value就是在评估策略的好坏，后面两个概率对应的是两个model，dynamic model或 environment model，这里的model可能是已知的也可能是未知的（model free RL）</h4><h4 id="通过一个例子深入理解贝尔曼公式"><a href="#通过一个例子深入理解贝尔曼公式" class="headerlink" title="通过一个例子深入理解贝尔曼公式"></a>通过一个例子深入理解贝尔曼公式</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/15.png"></p><h4 id="先来s1的state-value"><a href="#先来s1的state-value" class="headerlink" title="先来s1的state value"></a>先来s1的state value</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/16.png"></p><h4 id="先看第一个式子，在状态s1下采取动作a3的概率是1，不采取a3的概率是0，也就是说必然采取a3，那么第一部分就等于-1"><a href="#先看第一个式子，在状态s1下采取动作a3的概率是1，不采取a3的概率是0，也就是说必然采取a3，那么第一部分就等于-1" class="headerlink" title="先看第一个式子，在状态s1下采取动作a3的概率是1，不采取a3的概率是0，也就是说必然采取a3，那么第一部分就等于 1"></a>先看第一个式子，在状态s1下采取动作a3的概率是1，不采取a3的概率是0，也就是说必然采取a3，那么第一部分就等于 1</h4><h4 id="第二个式子，在状态s1下采取动作a3后状态转换为s3的概率是1，不为s3的概率为0，也就是说状态必然转换为s3，所以第三部分的值为v-pi-s3-gamma"><a href="#第二个式子，在状态s1下采取动作a3后状态转换为s3的概率是1，不为s3的概率为0，也就是说状态必然转换为s3，所以第三部分的值为v-pi-s3-gamma" class="headerlink" title="第二个式子，在状态s1下采取动作a3后状态转换为s3的概率是1，不为s3的概率为0，也就是说状态必然转换为s3，所以第三部分的值为v_pi(s3)*gamma"></a>第二个式子，在状态s1下采取动作a3后状态转换为s3的概率是1，不为s3的概率为0，也就是说状态必然转换为s3，所以第三部分的值为v_pi(s3)*gamma</h4><h4 id="第三个式子，在状态s1下采取动作a3后获得的即时奖励r-0的概率是1，r不等于0的概率是0，所以第二部分的值为0"><a href="#第三个式子，在状态s1下采取动作a3后获得的即时奖励r-0的概率是1，r不等于0的概率是0，所以第二部分的值为0" class="headerlink" title="第三个式子，在状态s1下采取动作a3后获得的即时奖励r&#x3D;0的概率是1，r不等于0的概率是0，所以第二部分的值为0"></a>第三个式子，在状态s1下采取动作a3后获得的即时奖励r&#x3D;0的概率是1，r不等于0的概率是0，所以第二部分的值为0</h4><h4 id="此时s1的state-value对应的的贝尔曼公式为"><a href="#此时s1的state-value对应的的贝尔曼公式为" class="headerlink" title="此时s1的state value对应的的贝尔曼公式为"></a>此时s1的state value对应的的贝尔曼公式为</h4><p>$$<br>v_{\pi}(s_1) &#x3D; 0 + \gamma v_{\pi}(s_3)<br>$$</p><h4 id="这里所得到的形式，过程虽然复杂，但实际上就是跟-第二部分中（return的计算）方法二的表达式是一个道理，那么根据这个思想，就可以直接得出其他几个状态下的state-value的贝尔曼公式"><a href="#这里所得到的形式，过程虽然复杂，但实际上就是跟-第二部分中（return的计算）方法二的表达式是一个道理，那么根据这个思想，就可以直接得出其他几个状态下的state-value的贝尔曼公式" class="headerlink" title="这里所得到的形式，过程虽然复杂，但实际上就是跟 第二部分中（return的计算）方法二的表达式是一个道理，那么根据这个思想，就可以直接得出其他几个状态下的state value的贝尔曼公式"></a>这里所得到的形式，过程虽然复杂，但实际上就是跟 第二部分中（return的计算）方法二的表达式是一个道理，那么根据这个思想，就可以直接得出其他几个状态下的state value的贝尔曼公式</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/17.png"></p><h4 id="有了这几个方程组，就可以通过矩阵的思想来求解了（也可以采取其他办法），得到的结果如下"><a href="#有了这几个方程组，就可以通过矩阵的思想来求解了（也可以采取其他办法），得到的结果如下" class="headerlink" title="有了这几个方程组，就可以通过矩阵的思想来求解了（也可以采取其他办法），得到的结果如下"></a>有了这几个方程组，就可以通过矩阵的思想来求解了（也可以采取其他办法），得到的结果如下</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/18.png"></p><h4 id="当-gamma-取某个值时，上面的式子也会对应有一个确定的值，而这个值的大小就说明了那些状态是值得去探索的"><a href="#当-gamma-取某个值时，上面的式子也会对应有一个确定的值，而这个值的大小就说明了那些状态是值得去探索的" class="headerlink" title="当 gamma 取某个值时，上面的式子也会对应有一个确定的值，而这个值的大小就说明了那些状态是值得去探索的"></a>当 gamma 取某个值时，上面的式子也会对应有一个确定的值，而这个值的大小就说明了那些状态是值得去探索的</h4><h4 id="计算得到-state-value-之后，根据其反映出来的情况，就可以根据需要去改进策略（policy-evaluation），不断的改进策略以得到最优策略"><a href="#计算得到-state-value-之后，根据其反映出来的情况，就可以根据需要去改进策略（policy-evaluation），不断的改进策略以得到最优策略" class="headerlink" title="计算得到 state value 之后，根据其反映出来的情况，就可以根据需要去改进策略（policy evaluation），不断的改进策略以得到最优策略"></a>计算得到 state value 之后，根据其反映出来的情况，就可以根据需要去改进策略（policy evaluation），不断的改进策略以得到最优策略</h4></blockquote><h3 id="第五部分——贝尔曼公式的矩阵和向量形式"><a href="#第五部分——贝尔曼公式的矩阵和向量形式" class="headerlink" title="第五部分——贝尔曼公式的矩阵和向量形式"></a>第五部分——贝尔曼公式的矩阵和向量形式</h3><blockquote><h4 id="贝尔曼公式是针对一个状态空间而言的，所以自然而然的与矩阵产生关联"><a href="#贝尔曼公式是针对一个状态空间而言的，所以自然而然的与矩阵产生关联" class="headerlink" title="贝尔曼公式是针对一个状态空间而言的，所以自然而然的与矩阵产生关联"></a>贝尔曼公式是针对一个状态空间而言的，所以自然而然的与矩阵产生关联</h4><h4 id="将贝尔曼公式的形式进行一个变换，先看贝尔曼公式最初的形式"><a href="#将贝尔曼公式的形式进行一个变换，先看贝尔曼公式最初的形式" class="headerlink" title="将贝尔曼公式的形式进行一个变换，先看贝尔曼公式最初的形式"></a>将贝尔曼公式的形式进行一个变换，先看贝尔曼公式最初的形式</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/19.png"></p><h4 id="将其改写为"><a href="#将其改写为" class="headerlink" title="将其改写为"></a>将其改写为</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/20.png"></p><h4 id="改写后的式子，第一部分表示的是：从当前状态s出发，所能得到的即时奖励r的平均值（期望）"><a href="#改写后的式子，第一部分表示的是：从当前状态s出发，所能得到的即时奖励r的平均值（期望）" class="headerlink" title="改写后的式子，第一部分表示的是：从当前状态s出发，所能得到的即时奖励r的平均值（期望）"></a>改写后的式子，第一部分表示的是：从当前状态s出发，所能得到的即时奖励r的平均值（期望）</h4><h4 id="再将上面改写后的形式进一步简化为"><a href="#再将上面改写后的形式进一步简化为" class="headerlink" title="再将上面改写后的形式进一步简化为"></a>再将上面改写后的形式进一步简化为</h4><p>$$<br>v_{\pi} &#x3D; r_{\pi} + \gamma P_{\pi} v_{\pi}<br>$$</p><h4 id="其中"><a href="#其中" class="headerlink" title="其中"></a>其中</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/21.png"></p><h4 id="举一个n-4的例子"><a href="#举一个n-4的例子" class="headerlink" title="举一个n&#x3D;4的例子"></a>举一个n&#x3D;4的例子</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/22.png"></p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/23.png"></p><h4 id="上式右边第一部分-r-pi-表示：从状态s出发获得的即时奖励r的期望（平均值）"><a href="#上式右边第一部分-r-pi-表示：从状态s出发获得的即时奖励r的期望（平均值）" class="headerlink" title="上式右边第一部分 r_pi 表示：从状态s出发获得的即时奖励r的期望（平均值）"></a>上式右边第一部分 r_pi 表示：从状态s出发获得的即时奖励r的期望（平均值）</h4><h4 id="第二部分中前一个矩阵-P-pi-表示：从状态s-i转换为s-j的概率"><a href="#第二部分中前一个矩阵-P-pi-表示：从状态s-i转换为s-j的概率" class="headerlink" title="第二部分中前一个矩阵 P_pi 表示：从状态s_i转换为s_j的概率"></a>第二部分中前一个矩阵 P_pi 表示：从状态s_i转换为s_j的概率</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="给定一个policy，可以列出一个与之对应的贝尔曼公式，通过对贝尔曼公式进行求解得到-state-value，这样的过程就称之为-policy-evaluation，通过评估一个策略的优劣，进而去改进策略，最终得到最优策略"><a href="#给定一个policy，可以列出一个与之对应的贝尔曼公式，通过对贝尔曼公式进行求解得到-state-value，这样的过程就称之为-policy-evaluation，通过评估一个策略的优劣，进而去改进策略，最终得到最优策略" class="headerlink" title="给定一个policy，可以列出一个与之对应的贝尔曼公式，通过对贝尔曼公式进行求解得到 state value，这样的过程就称之为 policy evaluation，通过评估一个策略的优劣，进而去改进策略，最终得到最优策略"></a>给定一个policy，可以列出一个与之对应的贝尔曼公式，通过对贝尔曼公式进行求解得到 state value，这样的过程就称之为 policy evaluation，通过评估一个策略的优劣，进而去改进策略，最终得到最优策略</h4><h4 id="求解贝尔曼方程的常用方法（求逆的方法通常不推荐，因为当矩阵维数很大时，求逆的计算量很大）"><a href="#求解贝尔曼方程的常用方法（求逆的方法通常不推荐，因为当矩阵维数很大时，求逆的计算量很大）" class="headerlink" title="求解贝尔曼方程的常用方法（求逆的方法通常不推荐，因为当矩阵维数很大时，求逆的计算量很大）"></a>求解贝尔曼方程的常用方法（求逆的方法通常不推荐，因为当矩阵维数很大时，求逆的计算量很大）</h4><blockquote><h4 id="常用的是迭代法求解"><a href="#常用的是迭代法求解" class="headerlink" title="常用的是迭代法求解"></a>常用的是迭代法求解</h4><p>$$<br>v_{k+1} &#x3D; r_{\pi} + \gamma P_{\pi} v_{k}<br>$$</p><h4 id="从-v-0开始，可以先假定一个值，然后就可以求出v-1，通过v-1又求出v-2，以此类推，求得v-k，v-k-1，最后就会求出这样一个序列，v-0，v-1…v-k，当-k-趋近于无穷时，就有"><a href="#从-v-0开始，可以先假定一个值，然后就可以求出v-1，通过v-1又求出v-2，以此类推，求得v-k，v-k-1，最后就会求出这样一个序列，v-0，v-1…v-k，当-k-趋近于无穷时，就有" class="headerlink" title="从 v_0开始，可以先假定一个值，然后就可以求出v_1，通过v_1又求出v_2，以此类推，求得v_k，v_k+1，最后就会求出这样一个序列，v_0，v_1…v_k，当 k 趋近于无穷时，就有"></a>从 v_0开始，可以先假定一个值，然后就可以求出v_1，通过v_1又求出v_2，以此类推，求得v_k，v_k+1，最后就会求出这样一个序列，v_0，v_1…v_k，当 k 趋近于无穷时，就有</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/24.png"></p><h4 id="v-k收敛到了v-pi，证明如下"><a href="#v-k收敛到了v-pi，证明如下" class="headerlink" title="v_k收敛到了v_pi，证明如下"></a>v_k收敛到了v_pi，证明如下</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/25.png"></p><h4 id="其证明过程类似于李亚普诺夫函数的稳定性证明"><a href="#其证明过程类似于李亚普诺夫函数的稳定性证明" class="headerlink" title="其证明过程类似于李亚普诺夫函数的稳定性证明"></a>其证明过程类似于李亚普诺夫函数的稳定性证明</h4></blockquote><h4 id="在下面这样一个例子中，说明了一些情况"><a href="#在下面这样一个例子中，说明了一些情况" class="headerlink" title="在下面这样一个例子中，说明了一些情况"></a>在下面这样一个例子中，说明了一些情况</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/26.png"></p><h4 id="可以发现，越靠近目标区域的状态的state-value越大，反之则越小"><a href="#可以发现，越靠近目标区域的状态的state-value越大，反之则越小" class="headerlink" title="可以发现，越靠近目标区域的状态的state value越大，反之则越小"></a>可以发现，越靠近目标区域的状态的state value越大，反之则越小</h4><h4 id="另外就是，不同的策略可能会得到相同的state-value"><a href="#另外就是，不同的策略可能会得到相同的state-value" class="headerlink" title="另外就是，不同的策略可能会得到相同的state value"></a>另外就是，不同的策略可能会得到相同的state value</h4><h4 id="通过计算state-value可以评估一个策略的优劣"><a href="#通过计算state-value可以评估一个策略的优劣" class="headerlink" title="通过计算state value可以评估一个策略的优劣"></a>通过计算state value可以评估一个策略的优劣</h4></blockquote><h3 id="第六部分——Action-value"><a href="#第六部分——Action-value" class="headerlink" title="第六部分——Action value"></a>第六部分——Action value</h3><blockquote><h4 id="state-value-和-Action-value-的联系与区别"><a href="#state-value-和-Action-value-的联系与区别" class="headerlink" title="state value 和 Action value 的联系与区别"></a>state value 和 Action value 的联系与区别</h4><blockquote><h4 id="前者是agent从一个状态出发，所获得的return的平均值（期望）"><a href="#前者是agent从一个状态出发，所获得的return的平均值（期望）" class="headerlink" title="前者是agent从一个状态出发，所获得的return的平均值（期望）"></a>前者是agent从一个状态出发，所获得的return的平均值（期望）</h4><h4 id="后者是agent从一个状态出发并且选择了一个Action之后，所获得的returen的平均值（期望）"><a href="#后者是agent从一个状态出发并且选择了一个Action之后，所获得的returen的平均值（期望）" class="headerlink" title="后者是agent从一个状态出发并且选择了一个Action之后，所获得的returen的平均值（期望）"></a>后者是agent从一个状态出发并且选择了一个Action之后，所获得的returen的平均值（期望）</h4></blockquote><h4 id="为什么要引入action-value，因为一个状态的转换是选择了一个Action之后引起的"><a href="#为什么要引入action-value，因为一个状态的转换是选择了一个Action之后引起的" class="headerlink" title="为什么要引入action value，因为一个状态的转换是选择了一个Action之后引起的"></a>为什么要引入action value，因为一个状态的转换是选择了一个Action之后引起的</h4><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/27.png"></p><h4 id="它依赖策略pi"><a href="#它依赖策略pi" class="headerlink" title="它依赖策略pi"></a>它依赖策略pi</h4><h4 id="它与state-value-数学式上的联系，state-value可以表示为下面这个形式"><a href="#它与state-value-数学式上的联系，state-value可以表示为下面这个形式" class="headerlink" title="它与state value 数学式上的联系，state value可以表示为下面这个形式"></a>它与state value 数学式上的联系，state value可以表示为下面这个形式</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/28.png"></p><h4 id="在一个状态下，可能有多种可选的动作，每个动作都有对应的概率，上式右边部分表示，在状态s下，选择动作a后的所获得的return的平均值-在状态s下选择动作a的概率"><a href="#在一个状态下，可能有多种可选的动作，每个动作都有对应的概率，上式右边部分表示，在状态s下，选择动作a后的所获得的return的平均值-在状态s下选择动作a的概率" class="headerlink" title="在一个状态下，可能有多种可选的动作，每个动作都有对应的概率，上式右边部分表示，在状态s下，选择动作a后的所获得的return的平均值 * 在状态s下选择动作a的概率"></a>在一个状态下，可能有多种可选的动作，每个动作都有对应的概率，上式右边部分表示，在状态s下，选择动作a后的所获得的return的平均值 * 在状态s下选择动作a的概率</h4><h4 id="注意到，右边的前面一部分就是-action-value的定义，所以二者数学式的联系如下"><a href="#注意到，右边的前面一部分就是-action-value的定义，所以二者数学式的联系如下" class="headerlink" title="注意到，右边的前面一部分就是 action value的定义，所以二者数学式的联系如下"></a>注意到，右边的前面一部分就是 action value的定义，所以二者数学式的联系如下</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/29.png"></p><h4 id="这个式子说明什么呢，说明了已知一个状态的-action-value，对其求平均就可以求出其对应的-state-value"><a href="#这个式子说明什么呢，说明了已知一个状态的-action-value，对其求平均就可以求出其对应的-state-value" class="headerlink" title="这个式子说明什么呢，说明了已知一个状态的 action value，对其求平均就可以求出其对应的 state value"></a>这个式子说明什么呢，说明了已知一个状态的 action value，对其求平均就可以求出其对应的 state value</h4><h4 id="另外呢，根据前面第五部分开头的表达式可以进一步给出-action-value的表达式"><a href="#另外呢，根据前面第五部分开头的表达式可以进一步给出-action-value的表达式" class="headerlink" title="另外呢，根据前面第五部分开头的表达式可以进一步给出 action value的表达式"></a>另外呢，根据前面第五部分开头的表达式可以进一步给出 action value的表达式</h4><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/2th_part/30.png"></p><h4 id="而这个式子，它有说明了，已知一个状态的-state-value-可以求出其对应的-action-value"><a href="#而这个式子，它有说明了，已知一个状态的-state-value-可以求出其对应的-action-value" class="headerlink" title="而这个式子，它有说明了，已知一个状态的 state value 可以求出其对应的 action value"></a>而这个式子，它有说明了，已知一个状态的 state value 可以求出其对应的 action value</h4><h4 id="（没怎么懂，迷迷糊糊的！）"><a href="#（没怎么懂，迷迷糊糊的！）" class="headerlink" title="（没怎么懂，迷迷糊糊的！）"></a>（没怎么懂，迷迷糊糊的！）</h4></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> RL </tag>
            
            <tag> math-theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网？NO，是怒火中烧</title>
      <link href="/2025/05/28/18/"/>
      <url>/2025/05/28/18/</url>
      
        <content type="html"><![CDATA[<h1 id="老版本Ubuntu科学上网须知（boom！！！）"><a href="#老版本Ubuntu科学上网须知（boom！！！）" class="headerlink" title="老版本Ubuntu科学上网须知（boom！！！）"></a>老版本Ubuntu科学上网须知（boom！！！）</h1><h3 id="必须记录下来"><a href="#必须记录下来" class="headerlink" title="必须记录下来"></a>必须记录下来</h3><blockquote><h4 id="绝大多数版本的clash-verge或者其他形式的软件都不支持切换内核为meta了"><a href="#绝大多数版本的clash-verge或者其他形式的软件都不支持切换内核为meta了" class="headerlink" title="绝大多数版本的clash verge或者其他形式的软件都不支持切换内核为meta了"></a>绝大多数版本的clash verge或者其他形式的软件都不支持切换内核为meta了</h4><h4 id="为数不多的就是极低版本的，这里就是采用的-1-4-3-版本的"><a href="#为数不多的就是极低版本的，这里就是采用的-1-4-3-版本的" class="headerlink" title="为数不多的就是极低版本的，这里就是采用的 1.4.3 版本的"></a>为数不多的就是极低版本的，这里就是采用的 1.4.3 版本的</h4><h4 id="先来个地址"><a href="#先来个地址" class="headerlink" title="先来个地址"></a>先来个地址</h4><blockquote><p><a href="https://github.com/clash-verge-rev/clash-verge-rev/releases?page=5">https://github.com/clash-verge-rev/clash-verge-rev/releases?page=5</a></p></blockquote><h4 id="直接下载对应版本的-deb-，然后-dpkg-安装"><a href="#直接下载对应版本的-deb-，然后-dpkg-安装" class="headerlink" title="直接下载对应版本的 deb ，然后 dpkg 安装"></a>直接下载对应版本的 deb ，然后 dpkg 安装</h4><h4 id="安装好之后，命令框同样会报错，提示说缺少依赖，叫-lib-什么来着"><a href="#安装好之后，命令框同样会报错，提示说缺少依赖，叫-lib-什么来着" class="headerlink" title="安装好之后，命令框同样会报错，提示说缺少依赖，叫 lib 什么来着"></a>安装好之后，命令框同样会报错，提示说缺少依赖，叫 lib 什么来着</h4><h4 id="先不管报错，先打开软件"><a href="#先不管报错，先打开软件" class="headerlink" title="先不管报错，先打开软件"></a>先不管报错，先打开软件</h4><h4 id="在设置这一栏，找到-Clash-内核-这行"><a href="#在设置这一栏，找到-Clash-内核-这行" class="headerlink" title="在设置这一栏，找到 Clash 内核 这行"></a>在设置这一栏，找到 Clash 内核 这行</h4><p><img src="http://picbed.yanzu.tech/img/ticks/1/1.png"></p><h4 id="点击齿轮，点击授权-Clash-Meta，然后再选择它"><a href="#点击齿轮，点击授权-Clash-Meta，然后再选择它" class="headerlink" title="点击齿轮，点击授权 Clash Meta，然后再选择它"></a>点击齿轮，点击授权 Clash Meta，然后再选择它</h4><p><img src="http://picbed.yanzu.tech/img/ticks/1/2.png"></p><h4 id="授权成功会有提示"><a href="#授权成功会有提示" class="headerlink" title="授权成功会有提示"></a>授权成功会有提示</h4><p><img src="http://picbed.yanzu.tech/img/ticks/1/3.png"></p><h4 id="然后就是临门一脚了，添加订阅节点也很恼火，因为不同的梯子或者同一款梯子不同版本，它支持的机场是不一样的，具体在那里看支持那些机场我也不知道，反正我知道这个梯子支持这个机场"><a href="#然后就是临门一脚了，添加订阅节点也很恼火，因为不同的梯子或者同一款梯子不同版本，它支持的机场是不一样的，具体在那里看支持那些机场我也不知道，反正我知道这个梯子支持这个机场" class="headerlink" title="然后就是临门一脚了，添加订阅节点也很恼火，因为不同的梯子或者同一款梯子不同版本，它支持的机场是不一样的，具体在那里看支持那些机场我也不知道，反正我知道这个梯子支持这个机场"></a>然后就是临门一脚了，添加订阅节点也很恼火，因为不同的梯子或者同一款梯子不同版本，它支持的机场是不一样的，具体在那里看支持那些机场我也不知道，反正我知道这个梯子支持这个机场</h4><blockquote><p><a href="https://赔钱.com/#/register?code=dGEFYisq">https://xn--cp3a08l.com/#/register?code=dGEFYisq</a></p></blockquote><h4 id="我也不知道到底是不是这个地址，反正就叫这个名"><a href="#我也不知道到底是不是这个地址，反正就叫这个名" class="headerlink" title="我也不知道到底是不是这个地址，反正就叫这个名"></a>我也不知道到底是不是这个地址，反正就叫这个名</h4></blockquote><h4 id="1-4-3的链接-防止以后找不到这个版本了，自己存一份贴一个链接"><a href="#1-4-3的链接-防止以后找不到这个版本了，自己存一份贴一个链接" class="headerlink" title="1.4.3的链接(防止以后找不到这个版本了，自己存一份贴一个链接)"></a>1.4.3的链接(防止以后找不到这个版本了，自己存一份贴一个链接)</h4><blockquote><p><a href="https://pan.baidu.com/s/1CA6RacPEwuf_aaqnrNRHcA?pwd=7kx4">https://pan.baidu.com/s/1CA6RacPEwuf_aaqnrNRHcA?pwd=7kx4</a> 提取码: 7kx4</p></blockquote><h4 id="老版本ubuntu太难了，各种不友好，捣腾了好几天，才总算是整好了，不能科学上网，我真的，裂开，我只能说我连猫咖都去不了，dddd-啊"><a href="#老版本ubuntu太难了，各种不友好，捣腾了好几天，才总算是整好了，不能科学上网，我真的，裂开，我只能说我连猫咖都去不了，dddd-啊" class="headerlink" title="老版本ubuntu太难了，各种不友好，捣腾了好几天，才总算是整好了，不能科学上网，我真的，裂开，我只能说我连猫咖都去不了，dddd 啊"></a>老版本ubuntu太难了，各种不友好，捣腾了好几天，才总算是整好了，不能科学上网，我真的，裂开，我只能说我连猫咖都去不了，dddd 啊</h4><h4 id="真滴捞阿！！！！！！！！！！！！！！！！！！"><a href="#真滴捞阿！！！！！！！！！！！！！！！！！！" class="headerlink" title="真滴捞阿！！！！！！！！！！！！！！！！！！"></a>真滴捞阿！！！！！！！！！！！！！！！！！！</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 安装 </tag>
            
            <tag> 上网 </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看论文---第一弹</title>
      <link href="/2025/05/26/17/"/>
      <url>/2025/05/26/17/</url>
      
        <content type="html"><![CDATA[<h1 id="Goal-Driven-Autonomous-Exploration-Through-Deep-Reinforcement-Learning—通过深度强化学习实现目标驱动的自主探索"><a href="#Goal-Driven-Autonomous-Exploration-Through-Deep-Reinforcement-Learning—通过深度强化学习实现目标驱动的自主探索" class="headerlink" title="Goal-Driven Autonomous Exploration Through Deep Reinforcement  Learning—通过深度强化学习实现目标驱动的自主探索"></a>Goal-Driven Autonomous Exploration Through Deep Reinforcement  Learning—通过深度强化学习实现目标驱动的自主探索</h1><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><blockquote><h4 id="本文提出了一种基于深度强化学习（DRL）的自主导航系统，用于在未知环境中进行目标驱动的探索。系统从环境中获取可能的导航方向的兴趣点（POI），并基于可用数据选择一个最优的航路点。机器人根据这些航路点被引导向全局目标，缓解了反应式导航中的局部最优问题。随后，在仿真环境中通过DRL框架学习用于局部导航的运动策略。我们开发了一个导航系统，将该学习到的策略集成到运动规划系统中，作为局部导航层，用于驱动机器人在航路点之间移动，最终到达全局目标。整个自主导航过程中无需任何先验知识，同时在机器人移动过程中会记录环境地图。实验表明，该方法在无需地图或先验信息的情况下，在复杂的静态和动态环境中相较于其他探索方法具有优势。"><a href="#本文提出了一种基于深度强化学习（DRL）的自主导航系统，用于在未知环境中进行目标驱动的探索。系统从环境中获取可能的导航方向的兴趣点（POI），并基于可用数据选择一个最优的航路点。机器人根据这些航路点被引导向全局目标，缓解了反应式导航中的局部最优问题。随后，在仿真环境中通过DRL框架学习用于局部导航的运动策略。我们开发了一个导航系统，将该学习到的策略集成到运动规划系统中，作为局部导航层，用于驱动机器人在航路点之间移动，最终到达全局目标。整个自主导航过程中无需任何先验知识，同时在机器人移动过程中会记录环境地图。实验表明，该方法在无需地图或先验信息的情况下，在复杂的静态和动态环境中相较于其他探索方法具有优势。" class="headerlink" title="本文提出了一种基于深度强化学习（DRL）的自主导航系统，用于在未知环境中进行目标驱动的探索。系统从环境中获取可能的导航方向的兴趣点（POI），并基于可用数据选择一个最优的航路点。机器人根据这些航路点被引导向全局目标，缓解了反应式导航中的局部最优问题。随后，在仿真环境中通过DRL框架学习用于局部导航的运动策略。我们开发了一个导航系统，将该学习到的策略集成到运动规划系统中，作为局部导航层，用于驱动机器人在航路点之间移动，最终到达全局目标。整个自主导航过程中无需任何先验知识，同时在机器人移动过程中会记录环境地图。实验表明，该方法在无需地图或先验信息的情况下，在复杂的静态和动态环境中相较于其他探索方法具有优势。"></a>本文提出了一种基于深度强化学习（DRL）的自主导航系统，用于在未知环境中进行目标驱动的探索。系统从环境中获取可能的导航方向的兴趣点（POI），并基于可用数据选择一个最优的航路点。机器人根据这些航路点被引导向全局目标，缓解了反应式导航中的局部最优问题。随后，在仿真环境中通过DRL框架学习用于局部导航的运动策略。我们开发了一个导航系统，将该学习到的策略集成到运动规划系统中，作为局部导航层，用于驱动机器人在航路点之间移动，最终到达全局目标。整个自主导航过程中无需任何先验知识，同时在机器人移动过程中会记录环境地图。实验表明，该方法在无需地图或先验信息的情况下，在复杂的静态和动态环境中相较于其他探索方法具有优势。</h4></blockquote><h4 id="自主导航系统"><a href="#自主导航系统" class="headerlink" title="自主导航系统"></a>自主导航系统</h4><h4 id="用于通过DRL对未知环境进行目标驱动的探索"><a href="#用于通过DRL对未知环境进行目标驱动的探索" class="headerlink" title="用于通过DRL对未知环境进行目标驱动的探索"></a>用于通过DRL对未知环境进行目标驱动的探索</h4><h4 id="获取可能导航方向的兴趣点-POI"><a href="#获取可能导航方向的兴趣点-POI" class="headerlink" title="获取可能导航方向的兴趣点(POI)"></a>获取可能导航方向的兴趣点(POI)</h4><h4 id="根据可用数据选择最佳航路点"><a href="#根据可用数据选择最佳航路点" class="headerlink" title="根据可用数据选择最佳航路点"></a>根据可用数据选择最佳航路点</h4><h4 id="缓解反应式导航中的局部最优问题"><a href="#缓解反应式导航中的局部最优问题" class="headerlink" title="缓解反应式导航中的局部最优问题"></a>缓解反应式导航中的局部最优问题</h4><h4 id="采用的是TD3算法（双延迟深度确定性策略梯度）"><a href="#采用的是TD3算法（双延迟深度确定性策略梯度）" class="headerlink" title="采用的是TD3算法（双延迟深度确定性策略梯度）"></a>采用的是TD3算法（双延迟深度确定性策略梯度）</h4><blockquote><h4 id="它是在DDPG算法的基础上进行的扩展"><a href="#它是在DDPG算法的基础上进行的扩展" class="headerlink" title="它是在DDPG算法的基础上进行的扩展"></a>它是在DDPG算法的基础上进行的扩展</h4><h4 id="DDPG（Deep-Deterministic-Policy-Gradient）深度确定性策略梯度：它是一种同时学习Q函数和策略的方法，它使用非策略数据和贝尔曼方程来学习Q函数，并使用Q函数来学习策略"><a href="#DDPG（Deep-Deterministic-Policy-Gradient）深度确定性策略梯度：它是一种同时学习Q函数和策略的方法，它使用非策略数据和贝尔曼方程来学习Q函数，并使用Q函数来学习策略" class="headerlink" title="DDPG（Deep Deterministic Policy Gradient）深度确定性策略梯度：它是一种同时学习Q函数和策略的方法，它使用非策略数据和贝尔曼方程来学习Q函数，并使用Q函数来学习策略"></a>DDPG（Deep Deterministic Policy Gradient）深度确定性策略梯度：它是一种同时学习Q函数和策略的方法，它使用非策略数据和贝尔曼方程来学习Q函数，并使用Q函数来学习策略</h4><h4 id="详细介绍：https-spinningup-openai-com-en-latest-algorithms-ddpg-html-background"><a href="#详细介绍：https-spinningup-openai-com-en-latest-algorithms-ddpg-html-background" class="headerlink" title="详细介绍：https://spinningup.openai.com/en/latest/algorithms/ddpg.html#background"></a>详细介绍：<a href="https://spinningup.openai.com/en/latest/algorithms/ddpg.html#background">https://spinningup.openai.com/en/latest/algorithms/ddpg.html#background</a></h4><h4 id="DDPG-对超参数和其他调优手段非常敏感，表现常常不稳定，它的一个常见失败模式是：所学习的-Q-函数会严重高估-Q-值，进而导致策略崩溃，因为策略会利用-Q-函数中的误差"><a href="#DDPG-对超参数和其他调优手段非常敏感，表现常常不稳定，它的一个常见失败模式是：所学习的-Q-函数会严重高估-Q-值，进而导致策略崩溃，因为策略会利用-Q-函数中的误差" class="headerlink" title="DDPG 对超参数和其他调优手段非常敏感，表现常常不稳定，它的一个常见失败模式是：所学习的 Q 函数会严重高估 Q 值，进而导致策略崩溃，因为策略会利用 Q 函数中的误差"></a>DDPG 对超参数和其他调优手段<strong>非常敏感</strong>，表现常常不稳定，它的一个常见失败模式是：所学习的 Q 函数会<strong>严重高估 Q 值</strong>，进而导致策略崩溃，因为策略会利用 Q 函数中的误差</h4><h4 id="而双延迟深度确定性策略梯度算法（TD3）引入三个关键技巧来解决DDPG的问题："><a href="#而双延迟深度确定性策略梯度算法（TD3）引入三个关键技巧来解决DDPG的问题：" class="headerlink" title="而双延迟深度确定性策略梯度算法（TD3）引入三个关键技巧来解决DDPG的问题："></a>而双延迟深度确定性策略梯度算法（TD3）引入三个关键技巧来解决DDPG的问题：</h4><blockquote><ol><li><h4 id="截断的双Q学习：TD3-同时学习两个-Q-函数（因此称为“双”Q），在计算贝尔曼误差损失函数中的目标值时，取两个Q值中较小的一个，以降低过估计的风险"><a href="#截断的双Q学习：TD3-同时学习两个-Q-函数（因此称为“双”Q），在计算贝尔曼误差损失函数中的目标值时，取两个Q值中较小的一个，以降低过估计的风险" class="headerlink" title="截断的双Q学习：TD3 同时学习两个 Q 函数（因此称为“双”Q），在计算贝尔曼误差损失函数中的目标值时，取两个Q值中较小的一个，以降低过估计的风险"></a>截断的双Q学习：TD3 同时学习两个 Q 函数（因此称为“双”Q），在计算贝尔曼误差损失函数中的目标值时，取两个Q值中较小的一个，以降低过估计的风险</h4></li><li><h4 id="延迟的策略更新：TD3-中，策略网络（Actor）和目标网络的更新频率低于-Q-函数的更新频率，建议是，更新两次-Q-网络，只更新-一次策略网络，以提高训练稳定性"><a href="#延迟的策略更新：TD3-中，策略网络（Actor）和目标网络的更新频率低于-Q-函数的更新频率，建议是，更新两次-Q-网络，只更新-一次策略网络，以提高训练稳定性" class="headerlink" title="延迟的策略更新：TD3 中，策略网络（Actor）和目标网络的更新频率低于 Q 函数的更新频率，建议是，更新两次 Q 网络，只更新 一次策略网络，以提高训练稳定性"></a>延迟的策略更新：TD3 中，策略网络（Actor）和目标网络的更新频率<strong>低于 Q 函数</strong>的更新频率，建议是，更新两次 Q 网络，只更新 <strong>一次策略网络</strong>，以提高训练稳定性</h4></li><li><h4 id="目标策略平滑：TD3-在计算目标-Q-值时，会在目标动作上添加噪声，一般是高斯噪声，使得动作空间内的-Q-值更平滑，从而防止策略去“钻空子”利用-Q-函数中的误差"><a href="#目标策略平滑：TD3-在计算目标-Q-值时，会在目标动作上添加噪声，一般是高斯噪声，使得动作空间内的-Q-值更平滑，从而防止策略去“钻空子”利用-Q-函数中的误差" class="headerlink" title="目标策略平滑：TD3 在计算目标 Q 值时，会在目标动作上添加噪声，一般是高斯噪声，使得动作空间内的 Q 值更平滑，从而防止策略去“钻空子”利用 Q 函数中的误差"></a>目标策略平滑：TD3 在计算目标 Q 值时，会在目标动作上添加噪声，一般是高斯噪声，使得动作空间内的 Q 值更平滑，从而防止策略去“钻空子”利用 Q 函数中的误差</h4></li></ol></blockquote><h4 id="详细介绍：https-spinningup-openai-com-en-latest-algorithms-td3-html"><a href="#详细介绍：https-spinningup-openai-com-en-latest-algorithms-td3-html" class="headerlink" title="详细介绍：https://spinningup.openai.com/en/latest/algorithms/td3.html"></a>详细介绍：<a href="https://spinningup.openai.com/en/latest/algorithms/td3.html">https://spinningup.openai.com/en/latest/algorithms/td3.html</a></h4></blockquote></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><h4 id="完全自主的目标驱动探索是一个包含两个方面的问题"><a href="#完全自主的目标驱动探索是一个包含两个方面的问题" class="headerlink" title="完全自主的目标驱动探索是一个包含两个方面的问题"></a><strong>完全自主的目标驱动探索</strong>是一个包含两个方面的问题</h4><blockquote><h4 id="首先，探索机器人需要决策去哪一个方向，以最大可能性到达全局目标。在没有先验信息或无法观测到全局目标的情况下，系统需要直接从传感器数据中指示可能的导航方向。从这些兴趣点（POI）中，需要选择一个最优点作为航路点，以最优的方式引导机器人接近全局目标。"><a href="#首先，探索机器人需要决策去哪一个方向，以最大可能性到达全局目标。在没有先验信息或无法观测到全局目标的情况下，系统需要直接从传感器数据中指示可能的导航方向。从这些兴趣点（POI）中，需要选择一个最优点作为航路点，以最优的方式引导机器人接近全局目标。" class="headerlink" title="首先，探索机器人需要决策去哪一个方向，以最大可能性到达全局目标。在没有先验信息或无法观测到全局目标的情况下，系统需要直接从传感器数据中指示可能的导航方向。从这些兴趣点（POI）中，需要选择一个最优点作为航路点，以最优的方式引导机器人接近全局目标。"></a>首先，探索机器人需要决策去哪一个方向，以最大可能性到达全局目标。在没有先验信息或无法观测到全局目标的情况下，系统需要直接从传感器数据中指示可能的导航方向。从这些兴趣点（POI）中，需要选择一个最优点作为航路点，以最优的方式引导机器人接近全局目标。</h4><h4 id="其次，在不依赖地图数据的前提下，还需要获得一种适用于不确定环境的机器人运动策略。"><a href="#其次，在不依赖地图数据的前提下，还需要获得一种适用于不确定环境的机器人运动策略。" class="headerlink" title="其次，在不依赖地图数据的前提下，还需要获得一种适用于不确定环境的机器人运动策略。"></a>其次，在不依赖地图数据的前提下，还需要获得一种适用于不确定环境的机器人运动策略。</h4><h4 id="这就引入了DRL"><a href="#这就引入了DRL" class="headerlink" title="这就引入了DRL"></a>这就引入了DRL</h4><h4 id="但是DRL存在一个问题：DRL具有反应性特征且缺乏全局信息，其容易陷入局部最优问题尤其是在大规模导航任务中表现尤为明显。"><a href="#但是DRL存在一个问题：DRL具有反应性特征且缺乏全局信息，其容易陷入局部最优问题尤其是在大规模导航任务中表现尤为明显。" class="headerlink" title="但是DRL存在一个问题：DRL具有反应性特征且缺乏全局信息，其容易陷入局部最优问题尤其是在大规模导航任务中表现尤为明显。"></a>但是DRL存在一个问题：DRL具有反应性特征且缺乏全局信息，其容易陷入局部最优问题尤其是在大规模导航任务中表现尤为明显。</h4><blockquote><h4 id="DRL的反应性特征"><a href="#DRL的反应性特征" class="headerlink" title="DRL的反应性特征"></a>DRL的反应性特征</h4><blockquote><h4 id="DRL中的大多策略都是基于当前状态做出决策的，也即-reactive-policy（反应式策略），也就是具有马尔可夫性"><a href="#DRL中的大多策略都是基于当前状态做出决策的，也即-reactive-policy（反应式策略），也就是具有马尔可夫性" class="headerlink" title="DRL中的大多策略都是基于当前状态做出决策的，也即 reactive policy（反应式策略），也就是具有马尔可夫性"></a>DRL中的大多策略都是基于当前状态做出决策的，也即 reactive policy（反应式策略），也就是具有马尔可夫性</h4><h4 id="这会导致："><a href="#这会导致：" class="headerlink" title="这会导致："></a>这会导致：</h4><ul><li><h4 id="agent只依据当前观测（摄像头图像、雷达扫描）来决定或判断下一动作"><a href="#agent只依据当前观测（摄像头图像、雷达扫描）来决定或判断下一动作" class="headerlink" title="agent只依据当前观测（摄像头图像、雷达扫描）来决定或判断下一动作"></a>agent只依据当前观测（摄像头图像、雷达扫描）来决定或判断下一动作</h4></li><li><h4 id="没有全局地图或任务结果的长期记忆，缺少更高层次的计划或决策能力"><a href="#没有全局地图或任务结果的长期记忆，缺少更高层次的计划或决策能力" class="headerlink" title="没有全局地图或任务结果的长期记忆，缺少更高层次的计划或决策能力"></a>没有全局地图或任务结果的长期记忆，缺少更高层次的计划或决策能力</h4></li><li><h4 id="动作的选择往往基于短期奖励最大化，而非长期全局最优"><a href="#动作的选择往往基于短期奖励最大化，而非长期全局最优" class="headerlink" title="动作的选择往往基于短期奖励最大化，而非长期全局最优"></a>动作的选择往往基于短期奖励最大化，而非长期全局最优</h4></li></ul><h4 id="这种策略适用于快速反应、实时避障等场景"><a href="#这种策略适用于快速反应、实时避障等场景" class="headerlink" title="这种策略适用于快速反应、实时避障等场景"></a>这种策略适用于快速反应、实时避障等场景</h4></blockquote><h4 id="全局信息的缺乏"><a href="#全局信息的缺乏" class="headerlink" title="全局信息的缺乏"></a>全局信息的缺乏</h4><blockquote><h4 id="大多数DRL系统的输入都是局部传感器数据（当前位置的摄像头图像、雷达扫描），因此DRL也只能感知局部环境。另外，强化学习RL本身就是一种局部策略的学习方法，它更适合解决的是马尔可夫决策过程MDP问题。还有就是，DRL的训练目标就是最大化累计奖励，而非构建认知地图。"><a href="#大多数DRL系统的输入都是局部传感器数据（当前位置的摄像头图像、雷达扫描），因此DRL也只能感知局部环境。另外，强化学习RL本身就是一种局部策略的学习方法，它更适合解决的是马尔可夫决策过程MDP问题。还有就是，DRL的训练目标就是最大化累计奖励，而非构建认知地图。" class="headerlink" title="大多数DRL系统的输入都是局部传感器数据（当前位置的摄像头图像、雷达扫描），因此DRL也只能感知局部环境。另外，强化学习RL本身就是一种局部策略的学习方法，它更适合解决的是马尔可夫决策过程MDP问题。还有就是，DRL的训练目标就是最大化累计奖励，而非构建认知地图。"></a>大多数DRL系统的输入都是局部传感器数据（当前位置的摄像头图像、雷达扫描），因此DRL也只能感知局部环境。另外，强化学习RL本身就是一种局部策略的学习方法，它更适合解决的是马尔可夫决策过程MDP问题。还有就是，DRL的训练目标就是最大化累计奖励，而非构建认知地图。</h4></blockquote><h4 id="局部最优问题"><a href="#局部最优问题" class="headerlink" title="局部最优问题"></a>局部最优问题</h4><blockquote><h4 id="系统在当前状态下选择了一个看似收益最大（或最短路径）的行为，但这个选择却可能阻碍了其通向真正全局最优解的路径。"><a href="#系统在当前状态下选择了一个看似收益最大（或最短路径）的行为，但这个选择却可能阻碍了其通向真正全局最优解的路径。" class="headerlink" title="系统在当前状态下选择了一个看似收益最大（或最短路径）的行为，但这个选择却可能阻碍了其通向真正全局最优解的路径。"></a>系统在当前状态下选择了一个看似收益最大（或最短路径）的行为，但这个选择却可能阻碍了其通向真正全局最优解的路径。</h4></blockquote></blockquote></blockquote><h4 id="本文提出一种完全自主的探索系统，用于在无需人工控制或环境先验信息的情况下实现导航至全局目标。"><a href="#本文提出一种完全自主的探索系统，用于在无需人工控制或环境先验信息的情况下实现导航至全局目标。" class="headerlink" title="本文提出一种完全自主的探索系统，用于在无需人工控制或环境先验信息的情况下实现导航至全局目标。"></a>本文提出一种完全自主的探索系统，用于在无需人工控制或环境先验信息的情况下实现导航至全局目标。</h4><h4 id="该系统从机器人周围的局部环境中提取兴趣点（POI），对其进行评估，并从中选取一个作为航路点（waypoint）。"><a href="#该系统从机器人周围的局部环境中提取兴趣点（POI），对其进行评估，并从中选取一个作为航路点（waypoint）。" class="headerlink" title="该系统从机器人周围的局部环境中提取兴趣点（POI），对其进行评估，并从中选取一个作为航路点（waypoint）。"></a>该系统从机器人周围的局部环境中提取<strong>兴趣点（POI）</strong>，对其进行评估，并从中选取一个作为航路点（waypoint）。</h4><h4 id="这些航路点用于引导基于深度强化学习（DRL）的运动策略朝向全局目标，从而缓解局部最优问题。"><a href="#这些航路点用于引导基于深度强化学习（DRL）的运动策略朝向全局目标，从而缓解局部最优问题。" class="headerlink" title="这些航路点用于引导基于深度强化学习（DRL）的运动策略朝向全局目标，从而缓解局部最优问题。"></a>这些航路点用于引导基于深度强化学习（DRL）的运动策略朝向全局目标，从而缓解局部最优问题。</h4><h4 id="机器人依据该策略进行运动，无需对周围环境进行完整建图。"><a href="#机器人依据该策略进行运动，无需对周围环境进行完整建图。" class="headerlink" title="机器人依据该策略进行运动，无需对周围环境进行完整建图。"></a>机器人依据该策略进行运动，无需对周围环境进行完整建图。</h4><h4 id="POI"><a href="#POI" class="headerlink" title="POI"></a>POI</h4><blockquote><h4 id="这里所说的-POI-兴趣点，是指机器人环境中那些具有导航价值的特定点或位置，这些点通常是机器人决策“去哪儿”的候选目标。它们帮助机器人在未知环境里选择下一步行动方向，特别是在没有完整地图信息时。POI-可以作为导航路径的候选点，也即中间航路点waypoint。"><a href="#这里所说的-POI-兴趣点，是指机器人环境中那些具有导航价值的特定点或位置，这些点通常是机器人决策“去哪儿”的候选目标。它们帮助机器人在未知环境里选择下一步行动方向，特别是在没有完整地图信息时。POI-可以作为导航路径的候选点，也即中间航路点waypoint。" class="headerlink" title="这里所说的 POI 兴趣点，是指机器人环境中那些具有导航价值的特定点或位置，这些点通常是机器人决策“去哪儿”的候选目标。它们帮助机器人在未知环境里选择下一步行动方向，特别是在没有完整地图信息时。POI 可以作为导航路径的候选点，也即中间航路点waypoint。"></a>这里所说的 POI 兴趣点，是指机器人环境中那些具有导航价值的特定点或位置，这些点通常是机器人决策“去哪儿”的候选目标。它们帮助机器人在未知环境里选择下一步行动方向，特别是在没有完整地图信息时。POI 可以作为导航路径的候选点，也即中间航路点waypoint。</h4><h4 id="POI的确定"><a href="#POI的确定" class="headerlink" title="POI的确定"></a>POI的确定</h4><blockquote><h4 id="激光读数间隙产生的POI：当连续两束激光雷达测距数值差距较大时，说明可能有一个开口或通道，这个位置就被视作一个-POI。"><a href="#激光读数间隙产生的POI：当连续两束激光雷达测距数值差距较大时，说明可能有一个开口或通道，这个位置就被视作一个-POI。" class="headerlink" title="激光读数间隙产生的POI：当连续两束激光雷达测距数值差距较大时，说明可能有一个开口或通道，这个位置就被视作一个 POI。"></a>激光读数间隙产生的POI：当连续两束激光雷达测距数值差距较大时，说明可能有一个开口或通道，这个位置就被视作一个 POI。</h4><h4 id="非数值激光读数产生的POI：激光雷达超出测量范围时返回非数值，代表远处有自由空间，这些边缘位置也被标记为兴趣点。"><a href="#非数值激光读数产生的POI：激光雷达超出测量范围时返回非数值，代表远处有自由空间，这些边缘位置也被标记为兴趣点。" class="headerlink" title="非数值激光读数产生的POI：激光雷达超出测量范围时返回非数值，代表远处有自由空间，这些边缘位置也被标记为兴趣点。"></a>非数值激光读数产生的POI：激光雷达超出测量范围时返回非数值，代表远处有自由空间，这些边缘位置也被标记为兴趣点。</h4></blockquote></blockquote><h4 id="导航系统的实现：左侧展示了机器人的设置，中间和右侧分别可视化了全局导航与局部导航的组成部分及其数据流。"><a href="#导航系统的实现：左侧展示了机器人的设置，中间和右侧分别可视化了全局导航与局部导航的组成部分及其数据流。" class="headerlink" title="导航系统的实现：左侧展示了机器人的设置，中间和右侧分别可视化了全局导航与局部导航的组成部分及其数据流。"></a>导航系统的实现：左侧展示了机器人的设置，中间和右侧分别可视化了全局导航与局部导航的组成部分及其数据流。</h4><p><img src="http://picbed.yanzu.tech/img/paper_read/1/1.jpg"></p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><h4 id="导航结构分两部分："><a href="#导航结构分两部分：" class="headerlink" title="导航结构分两部分："></a>导航结构分两部分：</h4><blockquote><h4 id="具有最优航路点选择机制的全局导航与建图模块"><a href="#具有最优航路点选择机制的全局导航与建图模块" class="headerlink" title="具有最优航路点选择机制的全局导航与建图模块"></a>具有<strong>最优航路点选择机制</strong>的<strong>全局导航与建图</strong>模块</h4><h4 id="基于深度强化学习的局部导航模块"><a href="#基于深度强化学习的局部导航模块" class="headerlink" title="基于深度强化学习的局部导航模块"></a>基于<strong>深度强化学习</strong>的<strong>局部导航</strong>模块</h4></blockquote><h4 id="系统首先从环境中提取兴趣点（POI），并依据设定的评估标准选择一个最优航路点。"><a href="#系统首先从环境中提取兴趣点（POI），并依据设定的评估标准选择一个最优航路点。" class="headerlink" title="系统首先从环境中提取兴趣点（POI），并依据设定的评估标准选择一个最优航路点。"></a>系统首先从环境中提取<strong>兴趣点（POI）</strong>，并依据设定的评估标准选择一个<strong>最优航路点</strong>。</h4><h4 id="在每一个导航步骤中，系统会将该航路点以相对于机器人当前位置与朝向的极坐标形式输入神经网络。"><a href="#在每一个导航步骤中，系统会将该航路点以相对于机器人当前位置与朝向的极坐标形式输入神经网络。" class="headerlink" title="在每一个导航步骤中，系统会将该航路点以相对于机器人当前位置与朝向的极坐标形式输入神经网络。"></a>在每一个导航步骤中，系统会将该航路点以<strong>相对于机器人当前位置与朝向的极坐标形式</strong>输入神经网络。</h4><h4 id="随后，网络基于当前的传感器数据计算并执行一个动作，以朝向该航路点运动。"><a href="#随后，网络基于当前的传感器数据计算并执行一个动作，以朝向该航路点运动。" class="headerlink" title="随后，网络基于当前的传感器数据计算并执行一个动作，以朝向该航路点运动。"></a>随后，网络基于当前的传感器数据计算并执行一个动作，以朝向该航路点运动。</h4><h4 id="在机器人沿着多个航路点逐步向全局目标移动的过程中，同时完成对环境的地图构建（建图）。"><a href="#在机器人沿着多个航路点逐步向全局目标移动的过程中，同时完成对环境的地图构建（建图）。" class="headerlink" title="在机器人沿着多个航路点逐步向全局目标移动的过程中，同时完成对环境的地图构建（建图）。"></a>在机器人沿着多个航路点逐步向全局目标移动的过程中，同时完成对环境的<strong>地图构建（建图）</strong>。</h4><h3 id="A-全局导航"><a href="#A-全局导航" class="headerlink" title="A.全局导航"></a>A.全局导航</h3><blockquote><h4 id="为了使机器人能够朝向全局目标导航，必须从当前可用的兴趣点（POI）中选择用于局部导航的中间航路点。"><a href="#为了使机器人能够朝向全局目标导航，必须从当前可用的兴趣点（POI）中选择用于局部导航的中间航路点。" class="headerlink" title="为了使机器人能够朝向全局目标导航，必须从当前可用的兴趣点（POI）中选择用于局部导航的中间航路点。"></a>为了使机器人能够朝向全局目标导航，必须从当前可用的兴趣点（POI）中选择<strong>用于局部导航的中间航路点</strong>。</h4><h4 id="机器人不仅需要被引导前往目标，还必须在行进过程中探索周围环境，以便在遇到死路时能够识别出可能的替代路径。"><a href="#机器人不仅需要被引导前往目标，还必须在行进过程中探索周围环境，以便在遇到死路时能够识别出可能的替代路径。" class="headerlink" title="机器人不仅需要被引导前往目标，还必须在行进过程中探索周围环境，以便在遇到死路时能够识别出可能的替代路径。"></a>机器人不仅需要被引导前往目标，还必须在行进过程中<strong>探索周围环境</strong>，以便在遇到死路时能够识别出可能的替代路径。</h4><h4 id="鉴于没有预先提供的环境信息，所有可能的-POI-必须从机器人当前的周边环境中提取，并存储在内存中以供后续使用。"><a href="#鉴于没有预先提供的环境信息，所有可能的-POI-必须从机器人当前的周边环境中提取，并存储在内存中以供后续使用。" class="headerlink" title="鉴于没有预先提供的环境信息，所有可能的 POI 必须从机器人当前的周边环境中提取，并存储在内存中以供后续使用。"></a>鉴于没有预先提供的环境信息，所有可能的 POI 必须从<strong>机器人当前的周边环境中提取</strong>，并<strong>存储在内存中</strong>以供后续使用。</h4><h4 id="如果在后续步骤中发现某个兴趣点（POI）位于障碍物附近，则该点会从内存中删除。"><a href="#如果在后续步骤中发现某个兴趣点（POI）位于障碍物附近，则该点会从内存中删除。" class="headerlink" title="如果在后续步骤中发现某个兴趣点（POI）位于障碍物附近，则该点会从内存中删除。"></a>如果在后续步骤中发现某个兴趣点（POI）位于障碍物附近，则该点会从内存中删除。</h4><h4 id="在机器人已经访问过的位置，激光雷达不会再提取新的-POI。"><a href="#在机器人已经访问过的位置，激光雷达不会再提取新的-POI。" class="headerlink" title="在机器人已经访问过的位置，激光雷达不会再提取新的 POI。"></a>在机器人已经访问过的位置，激光雷达不会再提取新的 POI。</h4><h4 id="此外，如果某个-POI-被选为航路点但在若干步内始终无法到达，它也会被删除，并重新选择一个新的航路点。"><a href="#此外，如果某个-POI-被选为航路点但在若干步内始终无法到达，它也会被删除，并重新选择一个新的航路点。" class="headerlink" title="此外，如果某个 POI 被选为航路点但在若干步内始终无法到达，它也会被删除，并重新选择一个新的航路点。"></a>此外，如果某个 POI 被选为航路点但在若干步内始终无法到达，它也会被删除，并重新选择一个新的航路点。</h4><h4 id="获取新的POI的方法：就是上面提到的POI的确定"><a href="#获取新的POI的方法：就是上面提到的POI的确定" class="headerlink" title="获取新的POI的方法：就是上面提到的POI的确定"></a>获取新的POI的方法：就是上面提到的POI的确定</h4><h4 id="从当前环境中提取POI，蓝色圆圈表示通过相应方法提取的兴趣点，绿色圆圈表示当前的航路点。"><a href="#从当前环境中提取POI，蓝色圆圈表示通过相应方法提取的兴趣点，绿色圆圈表示当前的航路点。" class="headerlink" title="从当前环境中提取POI，蓝色圆圈表示通过相应方法提取的兴趣点，绿色圆圈表示当前的航路点。"></a>从当前环境中提取POI，蓝色圆圈表示通过相应方法提取的兴趣点，绿色圆圈表示当前的航路点。</h4><h4 id="a-蓝色-POI-是通过激光雷达测距数据之间的间隙提取的；"><a href="#a-蓝色-POI-是通过激光雷达测距数据之间的间隙提取的；" class="headerlink" title="(a) 蓝色 POI 是通过激光雷达测距数据之间的间隙提取的；"></a>(a) 蓝色 POI 是通过激光雷达测距数据之间的间隙提取的；</h4><h4 id="b-蓝色-POI-是从非数值型的激光读数中提取的。"><a href="#b-蓝色-POI-是从非数值型的激光读数中提取的。" class="headerlink" title="(b)蓝色 POI 是从非数值型的激光读数中提取的。"></a>(b)蓝色 POI 是从非数值型的激光读数中提取的。</h4><p><img src="http://picbed.yanzu.tech/img/paper_read/1/2.jpg"></p><h4 id="在时刻-t，从当前可用的兴趣点（POI）中，使用基于信息的距离受限探索方法（Information-based-Distance-Limited-Exploration，简称-IDLE）来选择最优的航路点。IDLE-方法通过以下方式评估每个候选-POI-的适应度："><a href="#在时刻-t，从当前可用的兴趣点（POI）中，使用基于信息的距离受限探索方法（Information-based-Distance-Limited-Exploration，简称-IDLE）来选择最优的航路点。IDLE-方法通过以下方式评估每个候选-POI-的适应度：" class="headerlink" title="在时刻 t，从当前可用的兴趣点（POI）中，使用基于信息的距离受限探索方法（Information-based Distance Limited Exploration，简称 IDLE）来选择最优的航路点。IDLE 方法通过以下方式评估每个候选 POI 的适应度："></a>在时刻 <em>t</em>，从当前可用的兴趣点（POI）中，使用<strong>基于信息的距离受限探索方法</strong>（Information-based Distance Limited Exploration，简称 <strong>IDLE</strong>）来选择最优的航路点。IDLE 方法通过以下方式评估每个候选 POI 的适应度：</h4><p>$$<br>h(c_i) &#x3D; \tanh\left(\frac{e^{\left(\frac{d(p_t, c_i)}{l_2 - l_1}\right)^2}}{e^{\left(\frac{l_2}{l_2 - l_1}\right)^2}}\right) l_2 + d(c_i, g) + e^{I_{i,t}}<br>\tag{1}<br>$$</p><h4 id="每个候选兴趣点-c-索引为-i-的得分-h-由三部分组成"><a href="#每个候选兴趣点-c-索引为-i-的得分-h-由三部分组成" class="headerlink" title="每个候选兴趣点 c (索引为 i) 的得分 h 由三部分组成"></a>每个候选兴趣点 c (索引为 i) 的得分 h 由三部分组成</h4><h4 id="其中，机器人在时刻-t-的位置-p-t-与候选兴趣点-c-i-之间的欧几里得距离分量-d-p-t-c-i-被表示为一个双曲正切函数（tanh）形式："><a href="#其中，机器人在时刻-t-的位置-p-t-与候选兴趣点-c-i-之间的欧几里得距离分量-d-p-t-c-i-被表示为一个双曲正切函数（tanh）形式：" class="headerlink" title="其中，机器人在时刻 t 的位置 p_t 与候选兴趣点 c_i 之间的欧几里得距离分量 d(p_t, c_i) 被表示为一个双曲正切函数（tanh）形式："></a>其中，机器人在时刻 t 的位置 p_t 与候选兴趣点 <em>c_i</em> 之间的欧几里得距离分量 d(p_t, c_i) 被表示为一个双曲正切函数（tanh）形式：</h4><p>$$<br>\tanh\left(\frac{e^{\left(\frac{d(p_t, c_i)}{l_2 - l_1}\right)^2}}{e^{\left(\frac{l_2}{l_2 - l_1}\right)^2}}\right) l_2<br>\tag{2}<br>$$</p><h4 id="其中，e-是自然对数的底（欧拉数），l-1-和-l-2-是两个距离阈值，用于对得分进行衰减。这两个距离阈值根据深度强化学习（DRL）训练环境的区域大小设定。-这部分是一个距离惩罚项"><a href="#其中，e-是自然对数的底（欧拉数），l-1-和-l-2-是两个距离阈值，用于对得分进行衰减。这两个距离阈值根据深度强化学习（DRL）训练环境的区域大小设定。-这部分是一个距离惩罚项" class="headerlink" title="其中，e 是自然对数的底（欧拉数），l_1 和 l_2 是两个距离阈值，用于对得分进行衰减。这两个距离阈值根据深度强化学习（DRL）训练环境的区域大小设定。 这部分是一个距离惩罚项"></a>其中，<em>e</em> 是自然对数的底（欧拉数），<em>l_1</em> 和 <em>l_2</em> 是两个距离阈值，用于对得分进行衰减。这两个距离阈值根据深度强化学习（DRL）训练环境的区域大小设定。 这部分是一个距离惩罚项</h4><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><blockquote><h4 id="分子中指数部分的-d-p-t-c-i-l-2-l-1-这是在对距离-d-做归一化处理，把距离尺度转化为无单位的比值，l-2-l-1-是距离窗口，也就是期望-d-落在这个区间里，这样做的目的是让距离-d-的大小相对于“允许的距离范围”-（l-2-l-1）-来表达，而不是绝对距离大小，方便在指数和平方计算中保持数值的合理范围。"><a href="#分子中指数部分的-d-p-t-c-i-l-2-l-1-这是在对距离-d-做归一化处理，把距离尺度转化为无单位的比值，l-2-l-1-是距离窗口，也就是期望-d-落在这个区间里，这样做的目的是让距离-d-的大小相对于“允许的距离范围”-（l-2-l-1）-来表达，而不是绝对距离大小，方便在指数和平方计算中保持数值的合理范围。" class="headerlink" title="分子中指数部分的 d(p_t,c_i)&#x2F;(l_2 - l_1) 这是在对距离 d 做归一化处理，把距离尺度转化为无单位的比值，l_2 - l_1 是距离窗口，也就是期望 d 落在这个区间里，这样做的目的是让距离 d 的大小相对于“允许的距离范围” （l_2 - l_1） 来表达，而不是绝对距离大小，方便在指数和平方计算中保持数值的合理范围。"></a>分子中指数部分的 d(p_t,c_i)&#x2F;(l_2 - l_1) 这是在对距离 d 做归一化处理，把距离尺度转化为无单位的比值，l_2 - l_1 是距离窗口，也就是期望 d 落在这个区间里，这样做的目的是让距离 d 的大小相对于“允许的距离范围” （l_2 - l_1） 来表达，而不是绝对距离大小，方便在指数和平方计算中保持数值的合理范围。</h4><h4 id="l-2-l-2-l-1-是对-l-2-进行归一化处理，这个值确定了指数表达式的“最大值”或者“参考值”，它让指数中的分子和分母在相同的尺度下进行比较，实现对距离得分的合理缩放和归一化。本质上也是实现了e-x-e-y-这个分式的归一化处理。"><a href="#l-2-l-2-l-1-是对-l-2-进行归一化处理，这个值确定了指数表达式的“最大值”或者“参考值”，它让指数中的分子和分母在相同的尺度下进行比较，实现对距离得分的合理缩放和归一化。本质上也是实现了e-x-e-y-这个分式的归一化处理。" class="headerlink" title="l_2 &#x2F; (l_2 - l_1) 是对 l_2 进行归一化处理，这个值确定了指数表达式的“最大值”或者“参考值”，它让指数中的分子和分母在相同的尺度下进行比较，实现对距离得分的合理缩放和归一化。本质上也是实现了e^x &#x2F; e^y 这个分式的归一化处理。"></a>l_2 &#x2F; (l_2 - l_1) 是对 l_2 进行归一化处理，这个值确定了指数表达式的“最大值”或者“参考值”，它让指数中的分子和分母在相同的尺度下进行比较，实现对距离得分的合理缩放和归一化。本质上也是实现了e^x &#x2F; e^y 这个分式的归一化处理。</h4><h4 id="通过平方，可以让距离差异更敏感，远离阈值的点权重变化更大。"><a href="#通过平方，可以让距离差异更敏感，远离阈值的点权重变化更大。" class="headerlink" title="通过平方，可以让距离差异更敏感，远离阈值的点权重变化更大。"></a>通过平方，可以让距离差异更敏感，远离阈值的点权重变化更大。</h4><h4 id="通过指数放大这个变化，距离较远或较近的点的得分迅速减小或增大，达到对距离分量的平滑衰减效果。"><a href="#通过指数放大这个变化，距离较远或较近的点的得分迅速减小或增大，达到对距离分量的平滑衰减效果。" class="headerlink" title="通过指数放大这个变化，距离较远或较近的点的得分迅速减小或增大，达到对距离分量的平滑衰减效果。"></a>通过指数放大这个变化，距离较远或较近的点的得分迅速减小或增大，达到对距离分量的<strong>平滑衰减</strong>效果。</h4><h4 id="这种平滑衰减避免了距离直接线性权重导致的极端值影响，使得分分布更合理和稳定。"><a href="#这种平滑衰减避免了距离直接线性权重导致的极端值影响，使得分分布更合理和稳定。" class="headerlink" title="这种平滑衰减避免了距离直接线性权重导致的极端值影响，使得分分布更合理和稳定。"></a>这种平滑衰减避免了距离直接线性权重导致的极端值影响，使得分分布更合理和稳定。</h4><h4 id="使用双曲正切函数-tanh-将指数结果映射到-0-1-之间，起到非线性缩放和平滑归一化的作用。"><a href="#使用双曲正切函数-tanh-将指数结果映射到-0-1-之间，起到非线性缩放和平滑归一化的作用。" class="headerlink" title="使用双曲正切函数 tanh() 将指数结果映射到 (0, 1) 之间，起到非线性缩放和平滑归一化的作用。"></a>使用双曲正切函数 tanh() 将指数结果映射到 (0, 1) 之间，起到非线性缩放和平滑归一化的作用。</h4><h4 id="最后乘以-l-2-对距离分量进行尺度调整，映射到-0-l-2-之间"><a href="#最后乘以-l-2-对距离分量进行尺度调整，映射到-0-l-2-之间" class="headerlink" title="最后乘以 l_2 对距离分量进行尺度调整，映射到 (0, l_2)之间"></a>最后乘以 l_2 对距离分量进行尺度调整，映射到 (0, l_2)之间</h4><h4 id="这一部分得到的值，是一个非线性压缩过的距离得分项，目的就是使距离处于-l-1-l-2-之间的候选兴趣点的得分平滑上升，有利于选点策略更稳定"><a href="#这一部分得到的值，是一个非线性压缩过的距离得分项，目的就是使距离处于-l-1-l-2-之间的候选兴趣点的得分平滑上升，有利于选点策略更稳定" class="headerlink" title="这一部分得到的值，是一个非线性压缩过的距离得分项，目的就是使距离处于 l_1~l_2 之间的候选兴趣点的得分平滑上升，有利于选点策略更稳定"></a>这一部分得到的值，是一个非线性压缩过的距离得分项，目的就是使距离处于 l_1~l_2 之间的候选兴趣点的得分平滑上升，有利于选点策略更稳定</h4></blockquote><h4 id="第二个分量-d-c-i-g-表示候选兴趣点-c-i-与全局目标点-g-之间的欧几里得距离（全局目标距离）。"><a href="#第二个分量-d-c-i-g-表示候选兴趣点-c-i-与全局目标点-g-之间的欧几里得距离（全局目标距离）。" class="headerlink" title="第二个分量 d(c_i, g) 表示候选兴趣点 c_i 与全局目标点 g 之间的欧几里得距离（全局目标距离）。"></a>第二个分量 d(c_i, g) 表示候选兴趣点 c_i 与全局目标点 g 之间的欧几里得距离（全局目标距离）。</h4><h4 id="最后，时刻-t-的地图信息得分（信息增益激励项）表示为："><a href="#最后，时刻-t-的地图信息得分（信息增益激励项）表示为：" class="headerlink" title="最后，时刻 t 的地图信息得分（信息增益激励项）表示为："></a>最后，时刻 t 的地图信息得分（信息增益激励项）表示为：</h4><p>$$<br>e^{I_{i,t}}<br>\tag{3}<br>$$</p><h4 id="其中，I-i-t-的计算方式如下："><a href="#其中，I-i-t-的计算方式如下：" class="headerlink" title="其中，I_{i,t} 的计算方式如下："></a>其中，<em>I_{i,t}</em> 的计算方式如下：</h4><p>$$<br>I_{i,t} &#x3D; \frac{\sum\limits_{w&#x3D;-\frac{k}{2}}^{\frac{k}{2}} \sum\limits_{h&#x3D;-\frac{k}{2}}^{\frac{k}{2}} C(x+w)(y+h)}{k^2}<br>\tag{4}<br>$$</p><h4 id="其中，k-表示用于计算候选点周围信息的卷积核大小，候选点的坐标为-x-和-y-，而-w-和-h-分别表示卷积核的宽度和高度。"><a href="#其中，k-表示用于计算候选点周围信息的卷积核大小，候选点的坐标为-x-和-y-，而-w-和-h-分别表示卷积核的宽度和高度。" class="headerlink" title="其中，k 表示用于计算候选点周围信息的卷积核大小，候选点的坐标为 x 和 y ，而 w 和 h 分别表示卷积核的宽度和高度。"></a>其中，k 表示用于计算候选点周围信息的卷积核大小，候选点的坐标为 x 和 y ，而 w 和 h 分别表示卷积核的宽度和高度。</h4><h4 id="在公式-1-中，具有最小-IDLE-得分的兴趣点（POI）被选为用于局部导航的最优航路点。"><a href="#在公式-1-中，具有最小-IDLE-得分的兴趣点（POI）被选为用于局部导航的最优航路点。" class="headerlink" title="在公式 (1) 中，具有最小 IDLE 得分的兴趣点（POI）被选为用于局部导航的最优航路点。"></a>在公式 (1) 中，具有最小 IDLE 得分的兴趣点（POI）被选为用于局部导航的最优航路点。</h4><h4 id="注：-1"><a href="#注：-1" class="headerlink" title="注："></a>注：</h4><blockquote><h4 id="I-i-t-表示候选兴趣点（POI）c-i-在时间-t-的信息得分，它用于衡量此点周围环境的“信息丰富度”或“探索潜力”，得分越高，说明此-POI-附近还有未探索、未知或值得探索的区域。"><a href="#I-i-t-表示候选兴趣点（POI）c-i-在时间-t-的信息得分，它用于衡量此点周围环境的“信息丰富度”或“探索潜力”，得分越高，说明此-POI-附近还有未探索、未知或值得探索的区域。" class="headerlink" title="I_{i,t} 表示候选兴趣点（POI）c_i 在时间 t 的信息得分，它用于衡量此点周围环境的“信息丰富度”或“探索潜力”，得分越高，说明此 POI 附近还有未探索、未知或值得探索的区域。"></a>I_{i,t} 表示候选兴趣点（POI）c_i 在时间 t 的<strong>信息得分</strong>，它用于衡量此点周围环境的“信息丰富度”或“探索潜力”，得分越高，说明此 POI 附近还有<strong>未探索、未知或值得探索的区域</strong>。</h4><h4 id="C-x-y-是地图上-x-y-点的置信值或不确定度值，可能来源于占据栅格地图中的熵值、不确定度、未知区域标记、置信概率等，通常，这个值越高，表示该位置的信息越少、越值得探索。"><a href="#C-x-y-是地图上-x-y-点的置信值或不确定度值，可能来源于占据栅格地图中的熵值、不确定度、未知区域标记、置信概率等，通常，这个值越高，表示该位置的信息越少、越值得探索。" class="headerlink" title="C(x, y) 是地图上 (x, y) 点的置信值或不确定度值，可能来源于占据栅格地图中的熵值、不确定度、未知区域标记、置信概率等，通常，这个值越高，表示该位置的信息越少、越值得探索。"></a>C(x, y) 是地图上 (x, y) 点的<strong>置信值或不确定度值</strong>，可能来源于占据栅格地图中的熵值、不确定度、未知区域标记、置信概率等，通常，这个值越高，表示该位置的信息越少、越值得探索。</h4><h4 id="双重求和：它是在点-x-y-的周围取了一个大小为-k-k-的滑动窗口，然后对该窗口内所有位置的-C-值进行求和，也就是在以候选点为中心的邻域中，统计该邻域“信息量”。"><a href="#双重求和：它是在点-x-y-的周围取了一个大小为-k-k-的滑动窗口，然后对该窗口内所有位置的-C-值进行求和，也就是在以候选点为中心的邻域中，统计该邻域“信息量”。" class="headerlink" title="双重求和：它是在点 (x, y) 的周围取了一个大小为 k * k 的滑动窗口，然后对该窗口内所有位置的 C 值进行求和，也就是在以候选点为中心的邻域中，统计该邻域“信息量”。"></a>双重求和：它是在点 (x, y) 的周围取了一个大小为 k * k 的滑动窗口，然后对该窗口内所有位置的 C 值进行求和，也就是在以候选点为中心的邻域中，统计该邻域“信息量”。</h4><h4 id="除以-k-2-是做了一个均值操作，即把窗口内的信息总量归一化为平均信息值，得到的值落在-0-1-内，便于指数函数处理。"><a href="#除以-k-2-是做了一个均值操作，即把窗口内的信息总量归一化为平均信息值，得到的值落在-0-1-内，便于指数函数处理。" class="headerlink" title="除以 k^2 是做了一个均值操作，即把窗口内的信息总量归一化为平均信息值，得到的值落在 [0, 1]内，便于指数函数处理。"></a>除以 k^2 是做了一个<strong>均值操作</strong>，即把窗口内的信息总量归一化为平均信息值，得到的值落在 [0, 1]内，便于指数函数处理。</h4><h4 id="其目的就是鼓励探索未知区域"><a href="#其目的就是鼓励探索未知区域" class="headerlink" title="其目的就是鼓励探索未知区域"></a>其目的就是鼓励探索未知区域</h4></blockquote><h4 id="注意到，h-的三个组成部分好像不能直接相加，第一部分得到的是一个得分值，第二部分是一个距离值，第三部分是一个信息增益激励值，貌似是不能直接相加的，但第一部分进行了一个-l-2-的操作，是一个伪距离，最后一部分也进行了指数化操作，所以是可以相加的"><a href="#注意到，h-的三个组成部分好像不能直接相加，第一部分得到的是一个得分值，第二部分是一个距离值，第三部分是一个信息增益激励值，貌似是不能直接相加的，但第一部分进行了一个-l-2-的操作，是一个伪距离，最后一部分也进行了指数化操作，所以是可以相加的" class="headerlink" title="注意到，h 的三个组成部分好像不能直接相加，第一部分得到的是一个得分值，第二部分是一个距离值，第三部分是一个信息增益激励值，貌似是不能直接相加的，但第一部分进行了一个 *l_2 的操作，是一个伪距离，最后一部分也进行了指数化操作，所以是可以相加的"></a>注意到，h 的三个组成部分好像不能直接相加，第一部分得到的是一个得分值，第二部分是一个距离值，第三部分是一个信息增益激励值，貌似是不能直接相加的，但第一部分进行了一个 *l_2 的操作，是一个伪距离，最后一部分也进行了指数化操作，所以是可以相加的</h4></blockquote><h3 id="B-局部导航"><a href="#B-局部导航" class="headerlink" title="B.局部导航"></a>B.局部导航</h3><blockquote><h4 id="使用基于-双延迟深度确定性策略梯度-TD3，一种-Actor-Critic-架构-的神经网络架构来训练运动策略"><a href="#使用基于-双延迟深度确定性策略梯度-TD3，一种-Actor-Critic-架构-的神经网络架构来训练运动策略" class="headerlink" title="使用基于 双延迟深度确定性策略梯度(TD3，一种 Actor-Critic 架构)的神经网络架构来训练运动策略"></a>使用基于 双延迟深度确定性策略梯度(TD3，一种 Actor-Critic 架构)的神经网络架构来训练运动策略</h4><h4 id="局部环境信息和目标航点相对于-agent-位置的极坐标一起，作为状态输入-s-传入-TD3-的Actor-网络中"><a href="#局部环境信息和目标航点相对于-agent-位置的极坐标一起，作为状态输入-s-传入-TD3-的Actor-网络中" class="headerlink" title="局部环境信息和目标航点相对于 agent 位置的极坐标一起，作为状态输入 s 传入 TD3 的Actor 网络中"></a>局部环境信息和目标航点相对于 agent 位置的极坐标一起，作为状态输入 s 传入 TD3 的Actor 网络中</h4><h4 id="该-Actor-网络由两个全连接（FC）层组成，每一层后面都接有-ReLU（修正线性单元）激活函数。"><a href="#该-Actor-网络由两个全连接（FC）层组成，每一层后面都接有-ReLU（修正线性单元）激活函数。" class="headerlink" title="该 Actor 网络由两个全连接（FC）层组成，每一层后面都接有 ReLU（修正线性单元）激活函数。"></a>该 Actor 网络由两个<strong>全连接（FC）层</strong>组成，每一层后面都接有 <strong>ReLU（修正线性单元）激活函数</strong>。</h4><h4 id="最后一层与输出层相连，输出两个动作参数-a，分别表示机器人的线速度-a-1-和角速度-a-2"><a href="#最后一层与输出层相连，输出两个动作参数-a，分别表示机器人的线速度-a-1-和角速度-a-2" class="headerlink" title="最后一层与输出层相连，输出两个动作参数 a，分别表示机器人的线速度 a_1 和角速度 a_2"></a>最后一层与输出层相连，输出两个动作参数 a，分别表示机器人的线速度 a_1 和角速度 a_2</h4><h4 id="输出层采用-tanh-激活函数，将输出限制在区间-−1-1-内"><a href="#输出层采用-tanh-激活函数，将输出限制在区间-−1-1-内" class="headerlink" title="输出层采用 tanh 激活函数，将输出限制在区间 (−1,1) 内"></a>输出层采用 <strong>tanh 激活函数</strong>，将输出限制在区间 (−1,1) 内</h4><h4 id="在将动作应用于环境之前，它们会按以下方式缩放为实际速度值："><a href="#在将动作应用于环境之前，它们会按以下方式缩放为实际速度值：" class="headerlink" title="在将动作应用于环境之前，它们会按以下方式缩放为实际速度值："></a>在将动作应用于环境之前，它们会按以下方式缩放为实际速度值：</h4><p>$$<br>a &#x3D; \left[ v_{\max} \left( \frac{a_1 + 1}{2} \right), \omega_{\max} a_2 \right],<br>\tag{5}<br>$$</p><h4 id="最大线速度-v-max，最大角速度-ω-max"><a href="#最大线速度-v-max，最大角速度-ω-max" class="headerlink" title="最大线速度 v_max，最大角速度 ω_max"></a>最大线速度 v_max，最大角速度 ω_max</h4><h4 id="由于激光雷达只记录机器人前方的数据，因此不考虑向后的运动，并将线速度调整为仅为正值。"><a href="#由于激光雷达只记录机器人前方的数据，因此不考虑向后的运动，并将线速度调整为仅为正值。" class="headerlink" title="由于激光雷达只记录机器人前方的数据，因此不考虑向后的运动，并将线速度调整为仅为正值。"></a>由于激光雷达只记录机器人前方的数据，因此<strong>不考虑向后的运动</strong>，并将<strong>线速度调整为仅为正值</strong>。</h4><h4 id="状态-动作对的-Q-值-Q-s-a-由两个-Critic-网络进行评估。这两个-Critic-网络具有相同的结构，但其参数更新是延迟进行的，从而允许它们在参数上产生差异（避免完全同步）。"><a href="#状态-动作对的-Q-值-Q-s-a-由两个-Critic-网络进行评估。这两个-Critic-网络具有相同的结构，但其参数更新是延迟进行的，从而允许它们在参数上产生差异（避免完全同步）。" class="headerlink" title="状态-动作对的 Q 值 Q(s,a) 由两个 Critic 网络进行评估。这两个 Critic 网络具有相同的结构，但其参数更新是延迟进行的，从而允许它们在参数上产生差异（避免完全同步）。"></a>状态-动作对的 Q 值 Q(s,a) 由两个 <strong>Critic 网络</strong>进行评估。这两个 Critic 网络具有相同的结构，但其参数更新是<strong>延迟进行</strong>的，从而允许它们在参数上产生差异（避免完全同步）。</h4><h4 id="Critic-网络以状态-s-和动作-a-的组合作为输入"><a href="#Critic-网络以状态-s-和动作-a-的组合作为输入" class="headerlink" title="Critic 网络以状态 s 和动作 a 的组合作为输入"></a>Critic 网络以状态 s 和动作 a 的组合作为输入</h4><h4 id="其中，状态-s-首先被送入一个全连接层，并接上一个-ReLU-激活函数，输出为-L-s"><a href="#其中，状态-s-首先被送入一个全连接层，并接上一个-ReLU-激活函数，输出为-L-s" class="headerlink" title="其中，状态 s 首先被送入一个全连接层，并接上一个 ReLU 激活函数，输出为 L_s"></a>其中，状态 s 首先被送入一个<strong>全连接层</strong>，并接上一个 ReLU 激活函数，输出为 L_s</h4><h4 id="该层的输出-L-s-以及动作-a，将分别送入两个大小相同的变换全连接层（TFC）中，分别对应变换结果为-τ1-和-τ2，随后，这两个结果按如下方式进行组合："><a href="#该层的输出-L-s-以及动作-a，将分别送入两个大小相同的变换全连接层（TFC）中，分别对应变换结果为-τ1-和-τ2，随后，这两个结果按如下方式进行组合：" class="headerlink" title="该层的输出 L_s 以及动作 a，将分别送入两个大小相同的变换全连接层（TFC）中，分别对应变换结果为 τ1 和 τ2，随后，这两个结果按如下方式进行组合："></a>该层的输出 L_s 以及动作 a，将分别送入两个大小相同的变换全连接层（TFC）中，分别对应变换结果为 τ1 和 τ2，随后，这两个结果按如下方式进行组合：</h4><p>$$<br>L_c &#x3D; L_sW_{\tau_1} + aW_{\tau_2} + b_{\tau_2},<br>\tag{6}<br>$$</p><h4 id="其中，L-c-是组合全连接层（CFC）的输出，W-τ-1-和-W-τ-2-分别是-τ1-和-τ2-的权重，b-τ-2-是-τ-2-的偏执项，然后在这个组合层上使用ReLU激活函数，接着，该输出连接到一个最终输出节点，该节点包含一个参数，表示对应状态-动作对的-Q-值。最终，从两个-Critic-网络中选择较小的-Q-值，作为最后的-Critic-输出，以此来限制对状态-动作值的过高估计。"><a href="#其中，L-c-是组合全连接层（CFC）的输出，W-τ-1-和-W-τ-2-分别是-τ1-和-τ2-的权重，b-τ-2-是-τ-2-的偏执项，然后在这个组合层上使用ReLU激活函数，接着，该输出连接到一个最终输出节点，该节点包含一个参数，表示对应状态-动作对的-Q-值。最终，从两个-Critic-网络中选择较小的-Q-值，作为最后的-Critic-输出，以此来限制对状态-动作值的过高估计。" class="headerlink" title="其中，L_c 是组合全连接层（CFC）的输出，W_τ_1 和 W_τ_2 分别是 τ1 和 τ2 的权重，b_τ_2 是 τ_2 的偏执项，然后在这个组合层上使用ReLU激活函数，接着，该输出连接到一个最终输出节点，该节点包含一个参数，表示对应状态-动作对的 Q 值。最终，从两个 Critic 网络中选择较小的 Q 值，作为最后的 Critic 输出，以此来限制对状态-动作值的过高估计。"></a>其中，L_c 是组合全连接层（CFC）的输出，W_τ_1 和 W_τ_2 分别是 τ1 和 τ2 的权重，b_τ_2 是 τ_2 的偏执项，然后在这个组合层上使用ReLU激活函数，接着，该输出连接到一个最终输出节点，该节点包含<strong>一个参数</strong>，表示对应状态-动作对的 <strong>Q 值</strong>。最终，从两个 Critic 网络中<strong>选择较小的 Q 值</strong>，作为最后的 Critic 输出，以此来<strong>限制对状态-动作值的过高估计</strong>。</h4><h4 id="完整的网络架构如图"><a href="#完整的网络架构如图" class="headerlink" title="完整的网络架构如图"></a>完整的网络架构如图</h4><p><img src="http://picbed.yanzu.tech/img/paper_read/1/3.jpg"></p><h4 id="TD3-网络结构包括-actor-和-critic-两个部分。每一层的类型以及其对应的参数数量在层中都有描述。TFC-层指的是变换全连接层-τ，CFC-层指的是组合全连接层-Lc。"><a href="#TD3-网络结构包括-actor-和-critic-两个部分。每一层的类型以及其对应的参数数量在层中都有描述。TFC-层指的是变换全连接层-τ，CFC-层指的是组合全连接层-Lc。" class="headerlink" title="TD3 网络结构包括 actor 和 critic 两个部分。每一层的类型以及其对应的参数数量在层中都有描述。TFC 层指的是变换全连接层 τ，CFC 层指的是组合全连接层 Lc。"></a>TD3 网络结构包括 actor 和 critic 两个部分。每一层的类型以及其对应的参数数量在层中都有描述。TFC 层指的是变换全连接层 τ，CFC 层指的是组合全连接层 Lc。</h4><h4 id="策略的奖励依据以下函数进行评估-奖励函数"><a href="#策略的奖励依据以下函数进行评估-奖励函数" class="headerlink" title="策略的奖励依据以下函数进行评估(奖励函数)"></a>策略的奖励依据以下函数进行评估(奖励函数)</h4><p>$$<br>r(s_t, a_t) &#x3D;<br>\begin{cases}<br>r_g &amp; \text{if } D_t &lt; \eta D \<br>r_c &amp; \text{if collision} \<br>v - |\omega| &amp; \text{otherwise},<br>\end{cases},<br>\tag{7}<br>$$</p><h4 id="在时间步-t时，状态-动作对-s-t-a-t-的奖励-r-取决于以下三种情况："><a href="#在时间步-t时，状态-动作对-s-t-a-t-的奖励-r-取决于以下三种情况：" class="headerlink" title="在时间步 t时，状态-动作对 (s_t, a_t) 的奖励 r 取决于以下三种情况："></a>在时间步 t时，状态-动作对 (s_t, a_t) 的奖励 r 取决于以下三种情况：</h4><ul><li><h4 id="如果当前时间步与目标点的距离-D-t-小于阈值-η-D，则给予一个正的目标奖励-r-g（也就是鼓励）"><a href="#如果当前时间步与目标点的距离-D-t-小于阈值-η-D，则给予一个正的目标奖励-r-g（也就是鼓励）" class="headerlink" title="如果当前时间步与目标点的距离 D_t 小于阈值 η_D，则给予一个正的目标奖励 r_g（也就是鼓励）"></a>如果当前时间步与目标点的距离 D_t 小于阈值 η_D，则给予一个正的目标奖励 r_g（也就是鼓励）</h4></li><li><h4 id="如果检测到碰撞，则给予一个负的碰撞惩罚-r-c（惩罚）"><a href="#如果检测到碰撞，则给予一个负的碰撞惩罚-r-c（惩罚）" class="headerlink" title="如果检测到碰撞，则给予一个负的碰撞惩罚 r_c（惩罚）"></a>如果检测到碰撞，则给予一个负的碰撞惩罚 r_c（惩罚）</h4></li><li><h4 id="如果以上两种情况均未发生，则根据当前的线速度-v-和角速度-ω-给予即时奖励。"><a href="#如果以上两种情况均未发生，则根据当前的线速度-v-和角速度-ω-给予即时奖励。" class="headerlink" title="如果以上两种情况均未发生，则根据当前的线速度 v 和角速度 ω 给予即时奖励。"></a>如果以上两种情况均未发生，则根据当前的线速度 v 和角速度 ω 给予即时奖励。</h4></li></ul><h4 id="为了引导导航策略朝向给定目标，一个延迟归因奖励方法被采用，其计算如下："><a href="#为了引导导航策略朝向给定目标，一个延迟归因奖励方法被采用，其计算如下：" class="headerlink" title="为了引导导航策略朝向给定目标，一个延迟归因奖励方法被采用，其计算如下："></a>为了引导导航策略朝向给定目标，一个延迟归因奖励方法被采用，其计算如下：</h4><p>$$<br>r_{t-i} &#x3D; r(s_{t-i}, a_{t-i}) + \frac{r_g}{i}, \quad \forall i \in {1, 2, 3, \ldots, n},<br>\tag{8}<br>$$</p><h4 id="其中，n-表示前-n-个时间步中需要更新奖励的步数。这意味着，正的目标奖励不仅被分配给达到目标的那个状态-动作对，还以递减的方式分配给其之前的-n-个时间步。通过这种方式，网络学习到了一种局部导航策略，该策略能够仅依赖激光输入，避开障碍物的同时到达局部目标。"><a href="#其中，n-表示前-n-个时间步中需要更新奖励的步数。这意味着，正的目标奖励不仅被分配给达到目标的那个状态-动作对，还以递减的方式分配给其之前的-n-个时间步。通过这种方式，网络学习到了一种局部导航策略，该策略能够仅依赖激光输入，避开障碍物的同时到达局部目标。" class="headerlink" title="其中，n 表示前 n 个时间步中需要更新奖励的步数。这意味着，正的目标奖励不仅被分配给达到目标的那个状态-动作对，还以递减的方式分配给其之前的 n 个时间步。通过这种方式，网络学习到了一种局部导航策略，该策略能够仅依赖激光输入，避开障碍物的同时到达局部目标。"></a>其中，n 表示前 n 个时间步中需要更新奖励的步数。这意味着，正的目标奖励不仅被分配给达到目标的那个状态-动作对，还以递减的方式分配给其之前的 n 个时间步。通过这种方式，网络学习到了一种局部导航策略，该策略能够仅依赖激光输入，避开障碍物的同时到达局部目标。</h4></blockquote><h3 id="C-探索与建图"><a href="#C-探索与建图" class="headerlink" title="C.探索与建图"></a>C.探索与建图</h3><blockquote><h4 id="机器人沿着路径点被引导向全局目标前进。一旦靠近全局目标，机器人将自主导航至该目标。在此过程中，环境被逐步探索和建图。建图依赖于激光雷达和机器人里程计传感器数据，生成环境的占据栅格地图。完整的自主探索与建图算法的伪代码在算法1中进行了描述。"><a href="#机器人沿着路径点被引导向全局目标前进。一旦靠近全局目标，机器人将自主导航至该目标。在此过程中，环境被逐步探索和建图。建图依赖于激光雷达和机器人里程计传感器数据，生成环境的占据栅格地图。完整的自主探索与建图算法的伪代码在算法1中进行了描述。" class="headerlink" title="机器人沿着路径点被引导向全局目标前进。一旦靠近全局目标，机器人将自主导航至该目标。在此过程中，环境被逐步探索和建图。建图依赖于激光雷达和机器人里程计传感器数据，生成环境的占据栅格地图。完整的自主探索与建图算法的伪代码在算法1中进行了描述。"></a>机器人沿着路径点被引导向全局目标前进。一旦靠近全局目标，机器人将自主导航至该目标。在此过程中，环境被逐步探索和建图。建图依赖于激光雷达和机器人里程计传感器数据，生成环境的占据栅格地图。完整的自主探索与建图算法的伪代码在算法1中进行了描述。</h4></blockquote></blockquote><h3 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h3><blockquote><h4 id="算法过程："><a href="#算法过程：" class="headerlink" title="算法过程："></a>算法过程：</h4><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 输入参数</span><br><span class="line">global_goal# 全局目标点，即最终导航的目标位置</span><br><span class="line">δ# 导航至全局目标的距离阈值,用于判断机器人是否“足够接近”目标点</span><br><span class="line"></span><br><span class="line"># 主循环 直到达到全局目标</span><br><span class="line">while(reached_global_goal != True)&#123;# 判断是否已达到全局目标</span><br><span class="line"></span><br><span class="line">read sensor data # 读取传感器数据：如激光雷达、相机、里程计等</span><br><span class="line"></span><br><span class="line">update map from sensor data # 根据传感器数据更新地图：构建或完善占据栅格地图</span><br><span class="line"></span><br><span class="line">Obtain new POI # 获取新的兴趣点 POI,可能是探索边界或未知区域的候选目标点</span><br><span class="line"></span><br><span class="line"># 判断当前是否已接近目标区域</span><br><span class="line">if (D_t &lt; δ_D)&#123;# 如果 agent与目标的距离处于接近目标区域</span><br><span class="line"></span><br><span class="line">if(waypoint = global_goal)# 若当前导航的子目标 waypoint 已经是 global_goal</span><br><span class="line">reachedGlobalGoal = True# 那么任务完成</span><br><span class="line"></span><br><span class="line">else&#123;# 否则，进一步判断当前是否靠近全局目标</span><br><span class="line"></span><br><span class="line">if(d(p_t, g) &lt; δ)# 如果当前位置p_t与目标g的距离d(p_t,g) 小于 δ</span><br><span class="line">waypoint &lt;-- global_goal# 那么就把当前的 waypoint 设置为 global_goal</span><br><span class="line"></span><br><span class="line">else# 否则，从所有兴趣点中选择下一个最优子目标点</span><br><span class="line">for i in POI# 遍历POI中所有的兴趣点</span><br><span class="line">caculate h(i) from (1) # 根据式子(1)计算每个兴趣点的启发值h(i)</span><br><span class="line">waypoint &lt;-- POI_min(h(i))# 将h(i)值最小对应的兴趣点作为新的 waypoint</span><br><span class="line">end if</span><br><span class="line">end if</span><br><span class="line">end if</span><br><span class="line"></span><br><span class="line">Obtain an action from TD3# 从 TD3 策略网络中获取当前动作,利用强化学习模型TD3预测最优动作</span><br><span class="line">Perform action# 执行该动作</span><br><span class="line">end while</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4></blockquote><h3 id="A-系统设置"><a href="#A-系统设置" class="headerlink" title="A.系统设置"></a>A.系统设置</h3><blockquote><h4 id="原作者系统配置："><a href="#原作者系统配置：" class="headerlink" title="原作者系统配置："></a>原作者系统配置：</h4><blockquote><h4 id="显卡：NVIDIA-GTX-1080"><a href="#显卡：NVIDIA-GTX-1080" class="headerlink" title="显卡：NVIDIA GTX 1080"></a>显卡：NVIDIA GTX 1080</h4><h4 id="运行内存：32G"><a href="#运行内存：32G" class="headerlink" title="运行内存：32G"></a>运行内存：32G</h4><h4 id="CPU：-Intel-Core-i7-6800K"><a href="#CPU：-Intel-Core-i7-6800K" class="headerlink" title="CPU： Intel Core i7-6800K"></a>CPU： Intel Core i7-6800K</h4></blockquote><h4 id="训练参数设置"><a href="#训练参数设置" class="headerlink" title="训练参数设置"></a>训练参数设置</h4><blockquote><h4 id="TD3网络在Gazebo上进行训练，并通过ROS进行控制，训练了800回合，约8h"><a href="#TD3网络在Gazebo上进行训练，并通过ROS进行控制，训练了800回合，约8h" class="headerlink" title="TD3网络在Gazebo上进行训练，并通过ROS进行控制，训练了800回合，约8h"></a>TD3网络在Gazebo上进行训练，并通过ROS进行控制，训练了800回合，约8h</h4><h4 id="每个训练回合在机器人到达目标、发生碰撞或执行了-500-步动作后结束"><a href="#每个训练回合在机器人到达目标、发生碰撞或执行了-500-步动作后结束" class="headerlink" title="每个训练回合在机器人到达目标、发生碰撞或执行了 500 步动作后结束"></a>每个训练回合在机器人到达目标、发生碰撞或执行了 500 步动作后结束</h4><h4 id="最大线速度-v-max-和最大角速度-ω-max-分别设置为-0-5-m-s-和-1rad-s"><a href="#最大线速度-v-max-和最大角速度-ω-max-分别设置为-0-5-m-s-和-1rad-s" class="headerlink" title="最大线速度 v_max 和最大角速度 ω_max 分别设置为 0.5 m&#x2F;s 和 1rad&#x2F;s"></a>最大线速度 v_max 和最大角速度 ω_max 分别设置为 0.5 m&#x2F;s 和 1rad&#x2F;s</h4><h4 id="延迟奖励在最后-n-10-步中更新，参数更新延迟设置为每-2-个回合"><a href="#延迟奖励在最后-n-10-步中更新，参数更新延迟设置为每-2-个回合" class="headerlink" title="延迟奖励在最后 n&#x3D;10 步中更新，参数更新延迟设置为每 2 个回合"></a>延迟奖励在最后 n&#x3D;10 步中更新，参数更新延迟设置为每 2 个回合</h4></blockquote><h4 id="训练在一个-10x10-米的模拟环境中进行，如图所示"><a href="#训练在一个-10x10-米的模拟环境中进行，如图所示" class="headerlink" title="训练在一个 10x10 米的模拟环境中进行，如图所示"></a>训练在一个 10x10 米的模拟环境中进行，如图所示</h4><p><img src="http://picbed.yanzu.tech/img/paper_read/1/4.jpg"></p><h4 id="训练环境示例。蓝色区域表示输入的激光雷达读数和测距。四个箱形障碍物在每一轮训练中都会改变位置，如图-a-、-b-和-c-所示，以实现训练数据的随机化。"><a href="#训练环境示例。蓝色区域表示输入的激光雷达读数和测距。四个箱形障碍物在每一轮训练中都会改变位置，如图-a-、-b-和-c-所示，以实现训练数据的随机化。" class="headerlink" title="训练环境示例。蓝色区域表示输入的激光雷达读数和测距。四个箱形障碍物在每一轮训练中都会改变位置，如图(a)、(b)和(c)所示，以实现训练数据的随机化。"></a>训练环境示例。蓝色区域表示输入的激光雷达读数和测距。四个箱形障碍物在每一轮训练中都会改变位置，如图(a)、(b)和(c)所示，以实现训练数据的随机化。</h4><h4 id="为促进策略的泛化与探索，向传感器读数和动作值中添加了高斯噪声。为了构建多样化的训练环境，在每个回合开始时，箱形障碍物的位置会被随机化。其位置变化的示例如图-a-、-b-、-c-所示。同时，机器人的起始位置与目标位置也在每一回合中被随机设置。"><a href="#为促进策略的泛化与探索，向传感器读数和动作值中添加了高斯噪声。为了构建多样化的训练环境，在每个回合开始时，箱形障碍物的位置会被随机化。其位置变化的示例如图-a-、-b-、-c-所示。同时，机器人的起始位置与目标位置也在每一回合中被随机设置。" class="headerlink" title="为促进策略的泛化与探索，向传感器读数和动作值中添加了高斯噪声。为了构建多样化的训练环境，在每个回合开始时，箱形障碍物的位置会被随机化。其位置变化的示例如图 (a)、(b)、(c) 所示。同时，机器人的起始位置与目标位置也在每一回合中被随机设置。"></a>为促进策略的泛化与探索，向传感器读数和动作值中添加了高斯噪声。为了构建多样化的训练环境，在每个回合开始时，箱形障碍物的位置会被随机化。其位置变化的示例如图 (a)、(b)、(c) 所示。同时，机器人的起始位置与目标位置也在每一回合中被随机设置。</h4><h4 id="ROS-中的-SLAM-Toolbox-软件包用于生成和更新环境的全局地图，并用于机器人在地图中的定位"><a href="#ROS-中的-SLAM-Toolbox-软件包用于生成和更新环境的全局地图，并用于机器人在地图中的定位" class="headerlink" title="ROS 中的 SLAM Toolbox 软件包用于生成和更新环境的全局地图，并用于机器人在地图中的定位"></a>ROS 中的 SLAM Toolbox 软件包用于生成和更新环境的全局地图，并用于机器人在地图中的定位</h4><h4 id="ROS的本地规划器包（TrajectoryPlanner）代替了神经网络"><a href="#ROS的本地规划器包（TrajectoryPlanner）代替了神经网络" class="headerlink" title="ROS的本地规划器包（TrajectoryPlanner）代替了神经网络"></a>ROS的本地规划器包（TrajectoryPlanner）代替了神经网络</h4><h4 id="目标驱动自主探索（GDAE-Goal-Driven-Autonomous-Exploration）"><a href="#目标驱动自主探索（GDAE-Goal-Driven-Autonomous-Exploration）" class="headerlink" title="目标驱动自主探索（GDAE, Goal-Driven Autonomous Exploration）"></a>目标驱动自主探索（GDAE, Goal-Driven Autonomous Exploration）</h4><h4 id="最近前沿探索策略（Nearest-Frontier-NF）"><a href="#最近前沿探索策略（Nearest-Frontier-NF）" class="headerlink" title="最近前沿探索策略（Nearest Frontier, NF）"></a>最近前沿探索策略（Nearest Frontier, NF）</h4><h4 id="目标驱动强化学习（GD-RL-Goal-Driven-Reinforcement-Learning）"><a href="#目标驱动强化学习（GD-RL-Goal-Driven-Reinforcement-Learning）" class="headerlink" title="目标驱动强化学习（GD-RL, Goal-Driven Reinforcement Learning）"></a>目标驱动强化学习（GD-RL, Goal-Driven Reinforcement Learning）</h4><h4 id="本地规划器自主探索（LP-AE，Local-Planner-Autonomous-Exploration）"><a href="#本地规划器自主探索（LP-AE，Local-Planner-Autonomous-Exploration）" class="headerlink" title="本地规划器自主探索（LP-AE，Local Planner Autonomous Exploration）"></a>本地规划器自主探索（LP-AE，Local Planner Autonomous Exploration）</h4><h4 id="路径规划器（PP，Path-Planner）它是基于-Dijkstra-的生成路径的方法"><a href="#路径规划器（PP，Path-Planner）它是基于-Dijkstra-的生成路径的方法" class="headerlink" title="路径规划器（PP，Path Planner）它是基于 Dijkstra 的生成路径的方法"></a>路径规划器（PP，Path Planner）它是基于 Dijkstra 的生成路径的方法</h4></blockquote><h3 id="B-定量实验"><a href="#B-定量实验" class="headerlink" title="B.定量实验"></a>B.定量实验</h3><h3 id="C-定性实验"><a href="#C-定性实验" class="headerlink" title="C.定性实验"></a>C.定性实验</h3></blockquote><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><h4 id="基于深度强化学习（DRL）的目标驱动型全自主探索系统（GDAE）"><a href="#基于深度强化学习（DRL）的目标驱动型全自主探索系统（GDAE）" class="headerlink" title="基于深度强化学习（DRL）的目标驱动型全自主探索系统（GDAE）"></a>基于深度强化学习（DRL）的目标驱动型全自主探索系统（GDAE）</h4><h4 id="无需人工干预，即可导航至指定目标并记录环境信息（导航去目标点的过程中建图）"><a href="#无需人工干预，即可导航至指定目标并记录环境信息（导航去目标点的过程中建图）" class="headerlink" title="无需人工干预，即可导航至指定目标并记录环境信息（导航去目标点的过程中建图）"></a>无需人工干预，即可导航至指定目标并记录环境信息（导航去目标点的过程中建图）</h4><h4 id="系统有效结合了反应式的本地导航策略和全局导航策略"><a href="#系统有效结合了反应式的本地导航策略和全局导航策略" class="headerlink" title="系统有效结合了反应式的本地导航策略和全局导航策略"></a>系统有效结合了反应式的本地导航策略和全局导航策略</h4><h4 id="将神经网络模块引入端到端系统：机器人无需生成显式路径即可移动，而这一机制的不足则通过引入全局导航策略得到了弥补"><a href="#将神经网络模块引入端到端系统：机器人无需生成显式路径即可移动，而这一机制的不足则通过引入全局导航策略得到了弥补" class="headerlink" title="将神经网络模块引入端到端系统：机器人无需生成显式路径即可移动，而这一机制的不足则通过引入全局导航策略得到了弥补"></a>将神经网络模块引入端到端系统：机器人无需生成显式路径即可移动，而这一机制的不足则通过引入全局导航策略得到了弥补</h4><h4 id="系统的导航性能接近于基于已知地图路径规划器所得的最优解"><a href="#系统的导航性能接近于基于已知地图路径规划器所得的最优解" class="headerlink" title="系统的导航性能接近于基于已知地图路径规划器所得的最优解"></a>系统的导航性能接近于基于已知地图路径规划器所得的最优解</h4><h4 id="GDAE-系统依赖直接的传感器输入而非从不确定地图生成路径，因此在可靠性方面表现更佳"><a href="#GDAE-系统依赖直接的传感器输入而非从不确定地图生成路径，因此在可靠性方面表现更佳" class="headerlink" title="GDAE 系统依赖直接的传感器输入而非从不确定地图生成路径，因此在可靠性方面表现更佳"></a>GDAE 系统依赖<strong>直接的传感器输入</strong>而非从不确定地图生成路径，因此在可靠性方面表现更佳</h4><h4 id="若希望进一步泛化至不同类型的机器人，可以将机器人动力学作为神经网络的一个输入状态，并据此开展训练。只需提供机器人动力学信息，即可在不同平台上实现最优的本地导航。"><a href="#若希望进一步泛化至不同类型的机器人，可以将机器人动力学作为神经网络的一个输入状态，并据此开展训练。只需提供机器人动力学信息，即可在不同平台上实现最优的本地导航。" class="headerlink" title="若希望进一步泛化至不同类型的机器人，可以将机器人动力学作为神经网络的一个输入状态，并据此开展训练。只需提供机器人动力学信息，即可在不同平台上实现最优的本地导航。"></a>若希望进一步<strong>泛化至不同类型的机器人</strong>，可以将<strong>机器人动力学作为神经网络的一个输入状态</strong>，并据此开展训练。只需提供机器人动力学信息，即可在不同平台上实现最优的本地导航。</h4><h4 id="接下来的研究："><a href="#接下来的研究：" class="headerlink" title="接下来的研究："></a>接下来的研究：</h4><h4 id="引入长短时记忆（LSTM）结构也可能有助于缓解局部最优问题，并辅助规避当前传感器视野之外的障碍物"><a href="#引入长短时记忆（LSTM）结构也可能有助于缓解局部最优问题，并辅助规避当前传感器视野之外的障碍物" class="headerlink" title="引入长短时记忆（LSTM）结构也可能有助于缓解局部最优问题，并辅助规避当前传感器视野之外的障碍物"></a>引入<strong>长短时记忆（LSTM）结构</strong>也可能有助于缓解局部最优问题，并辅助规避当前传感器视野之外的障碍物</h4></blockquote><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><blockquote><h4 id="两个量的定义"><a href="#两个量的定义" class="headerlink" title="两个量的定义"></a>两个量的定义</h4><h4 id="Episode："><a href="#Episode：" class="headerlink" title="Episode："></a>Episode：</h4><blockquote><h4 id="它是后续步骤的集合，直到达到其中一个终止条件（终止条件：达到目标、与障碍物碰撞或达到最大步数max-ep）"><a href="#它是后续步骤的集合，直到达到其中一个终止条件（终止条件：达到目标、与障碍物碰撞或达到最大步数max-ep）" class="headerlink" title="它是后续步骤的集合，直到达到其中一个终止条件（终止条件：达到目标、与障碍物碰撞或达到最大步数max_ep）"></a>它是后续步骤的集合，直到达到其中一个终止条件（终止条件：达到目标、与障碍物碰撞或达到最大步数max_ep）</h4><h4 id="它可以理解是一个训练过程，如果达到终止条件就开始新的一个训练过程，并且伴随着环境的改变，包括区域内的墙体位置改变、障碍物的位置改变、agent的初始位置改变和目标点位置的改变"><a href="#它可以理解是一个训练过程，如果达到终止条件就开始新的一个训练过程，并且伴随着环境的改变，包括区域内的墙体位置改变、障碍物的位置改变、agent的初始位置改变和目标点位置的改变" class="headerlink" title="它可以理解是一个训练过程，如果达到终止条件就开始新的一个训练过程，并且伴随着环境的改变，包括区域内的墙体位置改变、障碍物的位置改变、agent的初始位置改变和目标点位置的改变"></a>它可以理解是一个训练过程，如果达到终止条件就开始新的一个训练过程，并且伴随着环境的改变，包括区域内的墙体位置改变、障碍物的位置改变、agent的初始位置改变和目标点位置的改变</h4></blockquote><h4 id="Epoch："><a href="#Epoch：" class="headerlink" title="Epoch："></a>Epoch：</h4><blockquote><h4 id="执行评估之间的后续事件数（episode）或者时间步长（timesteps）"><a href="#执行评估之间的后续事件数（episode）或者时间步长（timesteps）" class="headerlink" title="执行评估之间的后续事件数（episode）或者时间步长（timesteps）"></a>执行评估之间的后续事件数（episode）或者时间步长（timesteps）</h4><h4 id="一个epoch运行5000个步骤step（对应代码中的-eval-freq-这个参数），步长为0-1秒，也就是说一个epoch大概要运行8分多钟"><a href="#一个epoch运行5000个步骤step（对应代码中的-eval-freq-这个参数），步长为0-1秒，也就是说一个epoch大概要运行8分多钟" class="headerlink" title="一个epoch运行5000个步骤step（对应代码中的 eval_freq 这个参数），步长为0.1秒，也就是说一个epoch大概要运行8分多钟"></a>一个epoch运行5000个步骤step（对应代码中的 eval_freq 这个参数），步长为0.1秒，也就是说一个epoch大概要运行8分多钟</h4></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> ROS1 </tag>
            
            <tag> RL </tag>
            
            <tag> paper-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RL之路---第一弹</title>
      <link href="/2025/05/22/16/"/>
      <url>/2025/05/22/16/</url>
      
        <content type="html"><![CDATA[<h1 id="RL的基本数学原理—基本概念"><a href="#RL的基本数学原理—基本概念" class="headerlink" title="RL的基本数学原理—基本概念"></a>RL的基本数学原理—基本概念</h1><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote><p>它是agent相对于当前环境的一个状态，如当前的坐标 (x,y)，速度、加速度等</p><p>所有的状态构成的一个集合称之为状态空间，如下图，s1~s9构成了一个状态空间，这里是2D的，那么状态主要就是location （x, y）</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/1.png"></p></blockquote><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote><p>在每一个状态下，都会有对应的一系列的动作Action，如2D平面上，在一个状态下可以采取的Action有前进、后退、左右移动、原地不动</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/2.png"></p><p>所有的Action构成的一个集合就称之为动作空间 Action space</p><p>Action 和 state 是相互依赖的，不同的状态下对应不同的动作<br>$$<br>A(s_i) &#x3D; {a_i}<br>$$<br>上式意为，在状态 s_i 下，可采取的动作 a_i</p></blockquote><h3 id="State-transition"><a href="#State-transition" class="headerlink" title="State transition"></a>State transition</h3><blockquote><p>状态转换，在当前状态 s1 下，采取动作 a2(有概率采取动作 a2)，会转换到下一状态 s2，而这个下一状态 s2，其实是不确定的，它根据采取的动作而定，而且只是有概率转移到某个状态 s<br>$$<br>s_1 \xrightarrow{a_2} s_2<br>$$<br>状态转换定义了 agent 与环境交互的一种行为</p><p>在某个状态下，采取某个动作就直接确定的转换到某个状态，这种情况就类似于拓扑图，但实际上不是这样</p><p>实际中，在一个状态下，采取的动作都是有概率的，如在 s1 下，可以采取 a1、a2、a3 三种动作，但是这三个动作都是有概率的，p(a1)&#x3D;p(a2)&#x3D;0.3，p(a3)&#x3D;0.4，并且每个动作对应的转换状态(下一状态)也可能是多个且一样的有概率，如采取 a1，对应的状态有s2、s3、s4，概率也是0.3、0.3、0.4，这样，事情就变得复杂多样了</p></blockquote><h3 id="State-transition-probability"><a href="#State-transition-probability" class="headerlink" title="State transition probability"></a>State transition probability</h3><blockquote><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/3.png"></p><p>这里采用了条件概率来描述 state transistion 的过程，这是一个随机性的例子(deterministic case)</p></blockquote><h3 id="Policy"><a href="#Policy" class="headerlink" title="Policy"></a>Policy</h3><blockquote><p>它的作用是“指示” agent 在某个状态 s 下应该采取什么 Action</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/4.png"></p><p>这样一条路径path或者说 trajectory 就是一种策略 policy</p><p>策略同样还是用条件概率来表示<br><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/5.png"></p><p>不过上面的策略是一种确定性的策略，也就是在状态 s1 下，一定会采取动作 a2，并非随机性的，下面的就是随机性的策略了</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/6.png"></p><p>其条件概率就是这样的了</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/7.png"></p><p>通常概率为零的就会省略掉，策略可以通过一个表格来表示，这种表格既能描述确定性的情况，也能描述随机性的情况</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/8.png"></p><p>对应的代码实现，通常是用数组或者矩阵来存储这个表格以表示某个策略，通过对（0，1）这个区间进行随机采样，以 s1 为例，若 x 属于 (0,0.5) 就采取a2，若 x 属于 (0.5,1) 就采取 a3</p></blockquote><h3 id="Reward"><a href="#Reward" class="headerlink" title="Reward"></a>Reward</h3><blockquote><p>首先它是一个数，一个标量，agent 在当前状态下采取了一个动作Action，会得到一个奖励 reward，如果 reward 值为正，代表鼓励该行为（Action），否则就是惩罚该行为（Action）</p><p>reward 是 agent 与人交互的一种手段，因为这个奖励机制是人为设定的，通过设定合适奖励机制引导 agent 达到预期的效果，同样的可以用条件概率来表示<br>$$<br>p(r&#x3D;-1|s_1,a_1)&#x3D;0.6,p(r \neq -1|s_1,a_1)&#x3D;0.4<br>$$<br>获得 reward 的多少不是一层不变的，通常会有一个衰减系数来控制</p><p>reward 依赖于当前状态 s 以及在当前状态下采取的动作Action</p></blockquote><h3 id="Trajectory-and-return"><a href="#Trajectory-and-return" class="headerlink" title="Trajectory and return"></a>Trajectory and return</h3><blockquote><p>Trajectory 是一条 状态 state–&gt;动作 Action–&gt;奖励 reward 的链，具体例子如下图所示</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/9.png"></p><p>return 就是一个 trajectory 上所有 reward 之和，上面的 return &#x3D; 0 + 0 + 0 + 1 &#x3D; 1</p><p>trajectory的优劣或者说策略policy的优劣是与其对应的return相关的</p></blockquote><h3 id="discounted-return"><a href="#discounted-return" class="headerlink" title="discounted return"></a>discounted return</h3><blockquote><p>为了获得尽可能多的奖励 reward 和总的奖励 return，一条trajectory可能会无限进行下去，return最终会发散，如下图</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/10.png"></p><p>这就引入一个discount rate，通常用 γ 表示，γ 在[0,1)之间，discount rate 与 return 结合就得到了 discount return</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/11.png"></p><p>当 γ &lt; 1 时，这个无穷数列的和就等效于右边的 1&#x2F;( 1 - γ)</p><p>通过引入这个衰减因子 γ，就使得 return 从一个发散状态，变成一个有限值 discount return。</p><p>另外，当 γ 趋于 0 时，那么随着 γ 的次幂越来越高，会很快的衰减至0，return 的值就主要取决于前面几项；而 γ 趋于 1 时，后面的项衰减会慢很多。换句话说，γ 越小，越注重当前或者未来临近的状态-动作-奖励，而 γ 越大，则是注重更长远的策略</p></blockquote><h3 id="episode"><a href="#episode" class="headerlink" title="episode"></a>episode</h3><blockquote><p>episode属于trajectory的一种，当 agent 采用某种策略时，它可能达到最终状态（terminal state）后就停下来了，不会一直进行下去，更不会使return发散，它是有限的，这样的任务也称之为 episodic tasks</p><p>有些任务是没有最终状态，它会无限的进行下去，称之为 continuing tasks</p></blockquote><h3 id="MDP"><a href="#MDP" class="headerlink" title="MDP"></a>MDP</h3><blockquote><p>马尔可夫框架</p><p>三个集合：状态集合 S、动作集合A(s)、奖励集合R(s,a)</p><p>两个概率分布（条件概率？）：状态转换的条件概率 p( s’ | s, a)、奖励的条件概率 p( r | s, a)</p><p>策略：Π( a | s )</p><p>马尔可夫性质：memoryless property，历史无关性</p><p><img src="http://picbed.yanzu.tech/img/RL/math_theory/first_part/12.png"></p><p>下一状态只取决于当前状态，以及当期状态下采取的动作，奖励也是如此</p><p>如果马尔可夫过程 Markov process 的策略确定下来了，那马尔可夫过程就变成了马尔可夫决策过程 Markov decision process</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> RL </tag>
            
            <tag> math-theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DL之路---第一弹</title>
      <link href="/2025/05/21/15/"/>
      <url>/2025/05/21/15/</url>
      
        <content type="html"><![CDATA[<h1 id="Anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h1><h3 id="1-下载安装包，直接国内镜像资源，这里下载的是-Anaconda3-2022-10-Windows-x86-64-exe-版本"><a href="#1-下载安装包，直接国内镜像资源，这里下载的是-Anaconda3-2022-10-Windows-x86-64-exe-版本" class="headerlink" title="1.下载安装包，直接国内镜像资源，这里下载的是 Anaconda3-2022.10-Windows-x86_64.exe 版本"></a>1.下载安装包，直接国内镜像资源，这里下载的是 Anaconda3-2022.10-Windows-x86_64.exe 版本</h3><blockquote><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p></blockquote><h3 id="2-安装好之后配置环境变量—系统变量中的path，Anaconda是安装在E-Anaconda3文件下的"><a href="#2-安装好之后配置环境变量—系统变量中的path，Anaconda是安装在E-Anaconda3文件下的" class="headerlink" title="2.安装好之后配置环境变量—系统变量中的path，Anaconda是安装在E:\Anaconda3文件下的"></a>2.安装好之后配置环境变量—系统变量中的path，Anaconda是安装在E:\Anaconda3文件下的</h3><blockquote><p>分别添加以下三个变量<br>E:\Anaconda3<br>E:\Anaconda3\Scripts<br>E:\Anaconda3\Library\bin</p></blockquote><h3 id="3-在base环境下添加一个虚拟环境"><a href="#3-在base环境下添加一个虚拟环境" class="headerlink" title="3.在base环境下添加一个虚拟环境"></a>3.在base环境下添加一个虚拟环境</h3><blockquote><p>打开 Anaconda Prompt（Anaconda3）这个命令框</p><p>列出当前所有的环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure><p>创建一个虚拟环境，并指定python版本，这里新建的虚拟环境默认是会保存在Anaconda&#x2F;envs&#x2F; 路径下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create  -n env_name python=3.9</span><br></pre></td></tr></table></figure><p>如果不是保存在Anaconda&#x2F;envs&#x2F;下，就要手动指定位置了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create  --prefix=path\env_name python=3.9</span><br></pre></td></tr></table></figure><p>删除某个虚拟环境，但这个叫 env_name 的文件还在，需要手动删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n env_name --all</span><br></pre></td></tr></table></figure><p>进入某个虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-进入某个虚拟环境"><a href="#4-进入某个虚拟环境" class="headerlink" title="4.进入某个虚拟环境"></a>4.进入某个虚拟环境</h3><blockquote><p>列出当前虚拟环境下的所有库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><p>安装Numpy，并指定版本为1.21.5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy==1.21.5 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>安装pandas，并指定版本为1.2.4</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Pandas==1.2.4 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>安装Matplotlib，并指定版本为3.5.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Matplotlib==3.5.1 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>查看当前虚拟环境下某个库的版本，如 numpy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show numpy</span><br></pre></td></tr></table></figure><p>退出当前虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-安装cuda"><a href="#5-安装cuda" class="headerlink" title="5.安装cuda"></a>5.安装cuda</h3><blockquote><p>这里安装的是11.3版本的<br><a href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a><br>点击跳转后，选择操作系统依次选择</p><blockquote><p>Windows<br>x86_64<br>10<br>exe(local)</p></blockquote><p>2.7G，慢慢下吧</p><p>下载好之后，将其放在E:\CUDA\下，并创建一个Temp文件用于存储临时缓存<br>开始安装<br>选择路径为E:\CUDA\Temp\</p><p>然后等待完成<br>安装选项 — 选择自定义<br>自定义安装选项 — 只勾选 CUDA 且取消勾选CUDA中的 VS 选项<br>完成选择默认路径保存—也就是C盘（裂开）<br>安装完成后，可以E:\CUDA\这个文件删除了</p><p>配置环境变量</p><blockquote><p>依次添加以下四个系统变量<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.3\lib\x64<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.3\bin<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.3\libnvvp</p></blockquote><p>最后在命令行中输入以下命令查看CUDA版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-安装pytorch"><a href="#6-安装pytorch" class="headerlink" title="6.安装pytorch"></a>6.安装pytorch</h3><blockquote><p>pytorch 分为三部分：torch、torchversion、torchaudio，其中torch是主要的<br>先进入该页面<br><a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></p><p>ctrl + f 搜索 pip install torch&#x3D;&#x3D;1.12.0<br>找到 CUDA 11.3版本的安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==1.12.0+cu113 torchvision==0.13.0+cu113 torchaudio==0.12.0 --extra-index-url https://download.pytorch.org/whl/cu113</span><br></pre></td></tr></table></figure><p>这里并不直接执行该命令下载安装，而是手动安装</p><p>打开 <a href="https://download.pytorch.org/whl/cu113">https://download.pytorch.org/whl/cu113</a> 页面<br>根据命令中，三个库的版本去分别下载<br>如，找到 torch 文件，打开，搜索 1.12.0+cu113<br><img src="http://picbed.yanzu.tech/img/DL/1/1.png"></p><p>选择cp39，也即是python3.9版本的win</p><p>其余两个同理</p><p>下载好之后，将三个 .whl 文件放在 E:\whl\下</p><p>然后将其安装到之前创建的虚拟环境 DL 下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate DL</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install E:\whl\torch-1.12.0+cu113-cp39-cp39-win_amd64.whl</span><br><span class="line">pip install E:\whl\torchaudio-0.12.0+cu113-cp39-cp39-win_amd64.whl</span><br><span class="line">pip install E:\whl\torchvision-0.13.0+cu113-cp39-cp39-win_amd64.whl</span><br></pre></td></tr></table></figure><p>安装好之后，可以查看是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/DL/1/2.png"></p><p>也可以在当前虚拟环境下进入python编辑器，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p>进入python编辑器后，导入torch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><p>导入成功就说明安装成功了的，否则就得再折腾<br>再执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><p>会输出 True</p></blockquote><h3 id="7-修改-Jupyter-的默认工作路径"><a href="#7-修改-Jupyter-的默认工作路径" class="headerlink" title="7.修改 Jupyter 的默认工作路径"></a>7.修改 Jupyter 的默认工作路径</h3><blockquote><p>Jupyter 默认的工作路径是 C:\Uses\用户名，将其改为 E:\Jupyter</p><p>打开 Anaconda Prompt，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>进入生成的文件的地址，编辑 jupyter_notebook_config.py 文件</p><p>查找 c.NotebookApp.notebook_dir 这一行<br>将其取消注释，然后 ‘’ 里的内容就是新的文件路径，这里是 E:\Jupyter ，这个文件要事先创建好<br>最后，jupyter的桌面快捷方式右键属性，快捷方式 –&gt; 目标，将末尾的 %USERPROFILE% 删除，以及前面的空格，就可以了</p></blockquote><h3 id="8-修改-Jupyter-的字体"><a href="#8-修改-Jupyter-的字体" class="headerlink" title="8.修改 Jupyter 的字体"></a>8.修改 Jupyter 的字体</h3><blockquote><p>打开文件<br>E:\Anaconda3\Lib\site-packages\notebook\static\components\codemirror\lib<br>编辑 codemirror.css 文件<br>找到 font-family: </p><p>将其改为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: <span class="string">&#x27;Fira Code Light&#x27;</span>,<span class="string">&#x27;Consolas&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote><h3 id="9-虚拟环境连接-Jupyter"><a href="#9-虚拟环境连接-Jupyter" class="headerlink" title="9.虚拟环境连接 Jupyter"></a>9.虚拟环境连接 Jupyter</h3><blockquote><p>打开 Anaconda Prompt，进入虚拟环境 DL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate DL</span><br></pre></td></tr></table></figure><p>安装 ipykernel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ipykernel -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>将虚拟环境导入到 Jupyter 的 kernel 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ipykernel install --user --name=DL</span><br></pre></td></tr></table></figure><p>再次打开 Jupyter 就可以选择 DL 环境了<br><img src="http://picbed.yanzu.tech/img/DL/1/3.png"></p></blockquote><h3 id="10-虚拟环境连接pycharm"><a href="#10-虚拟环境连接pycharm" class="headerlink" title="10.虚拟环境连接pycharm"></a>10.虚拟环境连接pycharm</h3><blockquote><p>创建一个新文件夹 E:\project_of_py</p><p>打开 pycharm</p><p>选择新建 New project<br>这里是最新版本的pycharm，25版的</p><p>点击 location，选择新创建的文件夹<br>再点击 Base conda，选择 Anaconda\Scripts\下的 conda.exe<br>然后直接点击 Create</p><p><img src="http://picbed.yanzu.tech/img/DL/1/4.png"></p><p>创建之后会进入项目界面<br>点击右下角的解释器名称<br>点击 Add New Interpreter –&gt; Add Local Interpreter<br><img src="http://picbed.yanzu.tech/img/DL/1/5.png"></p><p>点击 Select existing<br>Type 选择 Conda<br><img src="http://picbed.yanzu.tech/img/DL/1/6.png"></p><p>选择 Anaconda\Scripts\下的 conda.exe，然后点击 Reload environments，它会检测到已经创建的虚拟环境，这里是叫 DL，然后 OK<br><img src="http://picbed.yanzu.tech/img/DL/1/7.png"></p><p>右下角就会显示当前的解释器是DL</p><p><img src="http://picbed.yanzu.tech/img/DL/1/8.png"></p><p>随便创建一个 py 文件，测试一下这个环境能否正常执行 py 文件</p><p><img src="http://picbed.yanzu.tech/img/DL/1/9.png"></p><p>勾选 Run with python Console<br>依次点击 demo_00 –&gt; Edit Configurations<br><img src="http://picbed.yanzu.tech/img/DL/1/10.png"></p><p>再点击 Modify options，然后勾选 Run with python Console<br><img src="http://picbed.yanzu.tech/img/DL/1/11.png"></p><p>运行demo_00之后右下角就有各变量的情况<br><img src="http://picbed.yanzu.tech/img/DL/1/12.png"></p><p>这个demo_00顺便检测了一下，pycharm 是否与 GPU 版本的 pytorch 连接成功</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> DL </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>autoware.universe安装后的官方demo运行</title>
      <link href="/2025/04/26/14/"/>
      <url>/2025/04/26/14/</url>
      
        <content type="html"><![CDATA[<h1 id="autoware-universe安装后的官方demo运行"><a href="#autoware-universe安装后的官方demo运行" class="headerlink" title="autoware.universe安装后的官方demo运行"></a>autoware.universe安装后的官方demo运行</h1><blockquote><h3 id="先下载官网上的示例地图，autoware-map和autoware在同一路径下"><a href="#先下载官网上的示例地图，autoware-map和autoware在同一路径下" class="headerlink" title="先下载官网上的示例地图，autoware_map和autoware在同一路径下"></a>先下载官网上的示例地图，autoware_map和autoware在同一路径下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdown -O ~/autoware_map/ &#x27;https://docs.google.com/uc?export=download&amp;id=1499_nsbUbIeturZaDj7jhUownh5fvXHd&#x27;</span><br><span class="line">unzip -d ~/autoware_map ~/autoware_map/sample-map-planning.zip</span><br></pre></td></tr></table></figure><h3 id="然后刷新环境变量并运行"><a href="#然后刷新环境变量并运行" class="headerlink" title="然后刷新环境变量并运行"></a>然后刷新环境变量并运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash</span><br><span class="line">ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/autoware_map/sample-map-planning vehicle_model:=sample_vehicle sensor_model:=sample_sensor_kit</span><br></pre></td></tr></table></figure><h3 id="运行起来之后会打开一个叫做-rviz2-的界面，"><a href="#运行起来之后会打开一个叫做-rviz2-的界面，" class="headerlink" title="运行起来之后会打开一个叫做 rviz2 的界面，"></a>运行起来之后会打开一个叫做 rviz2 的界面，</h3><p><img src="http://picbed.yanzu.tech/img/autoware/1.png"></p><h3 id="使用-2D-Pose-Estimate-给定自动驾驶小车的初始位置，"><a href="#使用-2D-Pose-Estimate-给定自动驾驶小车的初始位置，" class="headerlink" title="使用 2D Pose Estimate 给定自动驾驶小车的初始位置，"></a>使用 2D Pose Estimate 给定自动驾驶小车的初始位置，</h3><p><img src="http://picbed.yanzu.tech/img/autoware/2.png"></p><h3 id="然后使用-2D-Goal-Pose-指定目标位置，前提是这个目标位置是从初始位置可达的才行，指定了目标位置之后，地图上会出现一条行驶轨迹"><a href="#然后使用-2D-Goal-Pose-指定目标位置，前提是这个目标位置是从初始位置可达的才行，指定了目标位置之后，地图上会出现一条行驶轨迹" class="headerlink" title="然后使用 2D Goal Pose 指定目标位置，前提是这个目标位置是从初始位置可达的才行，指定了目标位置之后，地图上会出现一条行驶轨迹"></a>然后使用 2D Goal Pose 指定目标位置，前提是这个目标位置是从初始位置可达的才行，指定了目标位置之后，地图上会出现一条行驶轨迹</h3><p><img src="http://picbed.yanzu.tech/img/autoware/3.png"></p><h3 id="在当前命令框路径下打开一个新的命令框，刷新一下环境变量后，执行以下命令就可以实现小车的自动驾驶了"><a href="#在当前命令框路径下打开一个新的命令框，刷新一下环境变量后，执行以下命令就可以实现小车的自动驾驶了" class="headerlink" title="在当前命令框路径下打开一个新的命令框，刷新一下环境变量后，执行以下命令就可以实现小车的自动驾驶了"></a>在当前命令框路径下打开一个新的命令框，刷新一下环境变量后，执行以下命令就可以实现小车的自动驾驶了</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash</span><br><span class="line">ros2 topic pub /autoware/engage autoware_vehicle_msgs/msg/Engage &#x27;&#123;engage: true&#125;&#x27; -1</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/autoware/4.png"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
            <tag> autoware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插曲一(ros1)</title>
      <link href="/2025/04/08/13/"/>
      <url>/2025/04/08/13/</url>
      
        <content type="html"><![CDATA[<h1 id="cpp节点编写-ros1"><a href="#cpp节点编写-ros1" class="headerlink" title="cpp节点编写(ros1)"></a>cpp节点编写(ros1)</h1><blockquote><h3 id="ROS1中，cpp对应的接口叫—roscpp"><a href="#ROS1中，cpp对应的接口叫—roscpp" class="headerlink" title="ROS1中，cpp对应的接口叫—roscpp"></a>ROS1中，cpp对应的接口叫—roscpp</h3><h3 id="与ROS2一样，创建一个功能包之后，在该包的src-source-文件下新建cpp文件，先在工作空间下的-src-下创建一个功能包"><a href="#与ROS2一样，创建一个功能包之后，在该包的src-source-文件下新建cpp文件，先在工作空间下的-src-下创建一个功能包" class="headerlink" title="与ROS2一样，创建一个功能包之后，在该包的src(source)文件下新建cpp文件，先在工作空间下的 src&#x2F; 下创建一个功能包"></a>与ROS2一样，创建一个功能包之后，在该包的src(source)文件下新建cpp文件，先在工作空间下的 src&#x2F; 下创建一个功能包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd ros_workspace/src/</span><br><span class="line">catkin_create_pkg test_pkg roscpp rospy std_msgs</span><br></pre></td></tr></table></figure><h3 id="进入-test-pkg-src-，创建一个cpp文件，"><a href="#进入-test-pkg-src-，创建一个cpp文件，" class="headerlink" title="进入 test_pkg&#x2F;src&#x2F; ，创建一个cpp文件，"></a>进入 test_pkg&#x2F;src&#x2F; ，创建一个cpp文件，</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd test_pkg/src</span><br><span class="line">touch test.cpp</span><br></pre></td></tr></table></figure><h3 id="然后开始编写第一个cpp节点"><a href="#然后开始编写第一个cpp节点" class="headerlink" title="然后开始编写第一个cpp节点"></a>然后开始编写第一个cpp节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span>        <span class="comment">// 包含ROS的核心头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span> <span class="comment">// 包含标准消息类型String的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>           <span class="comment">// 包含字符串流处理的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点，命名为&quot;talker&quot;</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个NodeHandle对象，用于与ROS系统通信</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个发布者对象，发布名为&quot;chatter&quot;的消息队列长度为1000</span></span><br><span class="line">    ros::Publisher chatter_pub = n.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置循环频率为10Hz</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器变量，用于在发布的消息中增加计数值</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入主循环，只要ROS系统正常运行就会一直执行</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">        <span class="comment">// 创建一个String类型的消息对象</span></span><br><span class="line">        std_msgs::String msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用字符串流创建消息内容，包含&quot;hello world&quot;和当前计数值</span></span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;hello world &quot;</span> &lt;&lt; count;</span><br><span class="line">        msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在控制台打印出即将发布的消息内容</span></span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息到&quot;chatter&quot;主题</span></span><br><span class="line">        chatter_pub.<span class="built_in">publish</span>(msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理回调函数，确保其他节点可以及时收到消息</span></span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照设定的频率休眠一段时间</span></span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加计数器值</span></span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主程序返回0，表示成功结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与-ros2-的cpp节点大致是一样的，都有节点的初始化，只是使用的方法不同了"><a href="#与-ros2-的cpp节点大致是一样的，都有节点的初始化，只是使用的方法不同了" class="headerlink" title="与 ros2 的cpp节点大致是一样的，都有节点的初始化，只是使用的方法不同了"></a>与 ros2 的cpp节点大致是一样的，都有节点的初始化，只是使用的方法不同了</h3><h3 id="创建并编写好结点之后，修改CMakeList文件"><a href="#创建并编写好结点之后，修改CMakeList文件" class="headerlink" title="创建并编写好结点之后，修改CMakeList文件"></a>创建并编写好结点之后，修改CMakeList文件</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 指定src/下需要编译为可执行文件的源文件，前面节点名可以直接自己指定</span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125;_node  src/test.cpp)</span><br><span class="line"></span><br><span class="line"># 指定所要使用的链接库</span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125;_node</span><br><span class="line">$&#123;catkin_LIBRARIES&#125;</span><br><span class="line">）</span><br></pre></td></tr></table></figure><h3 id="修改完CMakeList文件之后，就开始编译"><a href="#修改完CMakeList文件之后，就开始编译" class="headerlink" title="修改完CMakeList文件之后，就开始编译"></a>修改完CMakeList文件之后，就开始编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscd ros_workspace/</span><br><span class="line">catkin_make</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="执行，先打开一个命令框执行-roscore"><a href="#执行，先打开一个命令框执行-roscore" class="headerlink" title="执行，先打开一个命令框执行 roscore"></a>执行，先打开一个命令框执行 roscore</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros1/1.png"></p><h3 id="再打开一个窗口运行节点"><a href="#再打开一个窗口运行节点" class="headerlink" title="再打开一个窗口运行节点"></a>再打开一个窗口运行节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun test_pkg test_pkg_node</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros1/2.png"></p><h3 id="头文件的引用，在-ros1-下，cpp的-h-头文件要放在功能包目录下的include-pkg-name-路径下，"><a href="#头文件的引用，在-ros1-下，cpp的-h-头文件要放在功能包目录下的include-pkg-name-路径下，" class="headerlink" title="头文件的引用，在 ros1 下，cpp的 .h 头文件要放在功能包目录下的include&#x2F;pkg_name&#x2F; 路径下，"></a>头文件的引用，在 ros1 下，cpp的 .h 头文件要放在功能包目录下的include&#x2F;pkg_name&#x2F; 路径下，</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros1/3.png"></p><h3 id="创建好了头文件之后，需要引用头文件的cpp文件需要导入该头文件"><a href="#创建好了头文件之后，需要引用头文件的cpp文件需要导入该头文件" class="headerlink" title="创建好了头文件之后，需要引用头文件的cpp文件需要导入该头文件"></a>创建好了头文件之后，需要引用头文件的cpp文件需要导入该头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pkg_name/xxx.h&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="编译功能包时，cpp文件中引用的头文件，ros会在该功能包的-include-文件下开始找，给出以上路径后就可以精确找到被引用的头文件"><a href="#编译功能包时，cpp文件中引用的头文件，ros会在该功能包的-include-文件下开始找，给出以上路径后就可以精确找到被引用的头文件" class="headerlink" title="编译功能包时，cpp文件中引用的头文件，ros会在该功能包的 include&#x2F; 文件下开始找，给出以上路径后就可以精确找到被引用的头文件"></a>编译功能包时，cpp文件中引用的头文件，ros会在该功能包的 include&#x2F; 文件下开始找，给出以上路径后就可以精确找到被引用的头文件</h3><h3 id="如果要引用同一工作空间其他包的头文件，那么在创建功能包时，需要依赖要引用头文件所在的包"><a href="#如果要引用同一工作空间其他包的头文件，那么在创建功能包时，需要依赖要引用头文件所在的包" class="headerlink" title="如果要引用同一工作空间其他包的头文件，那么在创建功能包时，需要依赖要引用头文件所在的包"></a>如果要引用同一工作空间其他包的头文件，那么在创建功能包时，需要依赖要引用头文件所在的包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg my_pkg roscpp rospy std_msgs test_pkg</span><br></pre></td></tr></table></figure><h3 id="包创建好之后，他的CMakeList修改没有区别跟其他的包，被引用头文件的包的CMakeList文件需要修改"><a href="#包创建好之后，他的CMakeList修改没有区别跟其他的包，被引用头文件的包的CMakeList文件需要修改" class="headerlink" title="包创建好之后，他的CMakeList修改没有区别跟其他的包，被引用头文件的包的CMakeList文件需要修改"></a>包创建好之后，他的CMakeList修改没有区别跟其他的包，被引用头文件的包的CMakeList文件需要修改</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES test_pkg</span><br><span class="line">#  CATKIN_DEPENDS roscpp rospy std_msgs</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="这样修改之后，引用该包的头文件的包就能找到根据对应的路径找到需要引用的头文件了"><a href="#这样修改之后，引用该包的头文件的包就能找到根据对应的路径找到需要引用的头文件了" class="headerlink" title="这样修改之后，引用该包的头文件的包就能找到根据对应的路径找到需要引用的头文件了"></a>这样修改之后，引用该包的头文件的包就能找到根据对应的路径找到需要引用的头文件了</h3></blockquote><h3 id="launch文件的编写"><a href="#launch文件的编写" class="headerlink" title="launch文件的编写"></a>launch文件的编写</h3><blockquote><h3 id="因为，一个完整的ros程序，需要多个节点来完成所需实现的功能，而roslaunch一次性执行好多个节点的方法显然不够合理和高效，由此引出-launch文件。"><a href="#因为，一个完整的ros程序，需要多个节点来完成所需实现的功能，而roslaunch一次性执行好多个节点的方法显然不够合理和高效，由此引出-launch文件。" class="headerlink" title="因为，一个完整的ros程序，需要多个节点来完成所需实现的功能，而roslaunch一次性执行好多个节点的方法显然不够合理和高效，由此引出 launch文件。"></a>因为，一个完整的ros程序，需要多个节点来完成所需实现的功能，而roslaunch一次性执行好多个节点的方法显然不够合理和高效，由此引出 launch文件。</h3><h3 id="launch文件就是一个xml格式的脚本文件，把需要启动的节点都写进launch文件-中，这样就可以通过roslaunch工具来调用launch文件，执行这个脚本文件就一次性启动所有的节点程序。"><a href="#launch文件就是一个xml格式的脚本文件，把需要启动的节点都写进launch文件-中，这样就可以通过roslaunch工具来调用launch文件，执行这个脚本文件就一次性启动所有的节点程序。" class="headerlink" title="launch文件就是一个xml格式的脚本文件，把需要启动的节点都写进launch文件 中，这样就可以通过roslaunch工具来调用launch文件，执行这个脚本文件就一次性启动所有的节点程序。"></a>launch文件就是一个xml格式的脚本文件，把需要启动的节点都写进launch文件 中，这样就可以通过roslaunch工具来调用launch文件，执行这个脚本文件就一次性启动所有的节点程序。</h3><h3 id="创建一个包-robot-bringup，在其路径下创建一个文件-launch，在-launch-下创建并编辑-startup-launch-文件，用于同时启动多个节点"><a href="#创建一个包-robot-bringup，在其路径下创建一个文件-launch，在-launch-下创建并编辑-startup-launch-文件，用于同时启动多个节点" class="headerlink" title="创建一个包 robot_bringup，在其路径下创建一个文件 launch，在 launch&#x2F; 下创建并编辑 startup.launch 文件，用于同时启动多个节点"></a>创建一个包 robot_bringup，在其路径下创建一个文件 launch，在 launch&#x2F; 下创建并编辑 startup.launch 文件，用于同时启动多个节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg robot_bringup</span><br><span class="line">cd robot_bringup</span><br><span class="line">mkdir launch</span><br><span class="line">cd launch/</span><br><span class="line">touch startup.launch</span><br><span class="line">subl startup.launch</span><br></pre></td></tr></table></figure><h3 id="编辑使之能同时运行-test-pkg-node-和-my-pkg-node-两个节点"><a href="#编辑使之能同时运行-test-pkg-node-和-my-pkg-node-两个节点" class="headerlink" title="编辑使之能同时运行 test_pkg_node 和 my_pkg_node 两个节点"></a>编辑使之能同时运行 test_pkg_node 和 my_pkg_node 两个节点</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># <span class="tag">&lt;<span class="name">launch</span>&gt;</span> 是根标签</span><br><span class="line"># <span class="tag">&lt;<span class="name">node</span>&gt;</span> 是节点标签,至少要有三个属性 pkg type name, type是指节点名,name给所运行的节点指定名称,他会覆盖ros::init的节点名, output 可以将单个节点的标准输出到终端</span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;test_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;test_pkg_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test_pkg_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;my_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;my_pkg_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my_pkg_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编译并运行"><a href="#编译并运行" class="headerlink" title="编译并运行"></a>编译并运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br><span class="line">source ~/.bashrc</span><br><span class="line">roslaunch robot_bringup startup.launch</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros1/4.png"></p><h3 id="使用-include-标签，可以在当前-launch-文件中调用另外一个包的-launch文件"><a href="#使用-include-标签，可以在当前-launch-文件中调用另外一个包的-launch文件" class="headerlink" title="使用 include 标签，可以在当前 launch 文件中调用另外一个包的 launch文件"></a>使用 include 标签，可以在当前 launch 文件中调用另外一个包的 launch文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># find 命令可以直接搜索功能包的位置，代替直接使用绝对路径</span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>  <span class="attr">file</span>=<span class="string">&quot;$(find package-name)/launch-file-name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建新的功能包-third-pkg，在-src-中创建并编写-third-pkg-cpp"><a href="#创建新的功能包-third-pkg，在-src-中创建并编写-third-pkg-cpp" class="headerlink" title="创建新的功能包 third_pkg，在 src 中创建并编写 third_pkg.cpp"></a>创建新的功能包 third_pkg，在 src 中创建并编写 third_pkg.cpp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg third_pkg roscpp rospy std_msgs</span><br><span class="line">cd third_pkg/src</span><br><span class="line">touch third_pkg.cpp</span><br><span class="line">subl third_pkg.cpp</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;third_pkg&quot;</span>);</span><br><span class="line"></span><br><span class="line">ros::NodeHandle n;<span class="comment">// 更新话题的消息格式为自定义的消息格式</span></span><br><span class="line"></span><br><span class="line">ros::Publisher chatter_pub = n.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;third_pkg&quot;</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line"></span><br><span class="line">std_msgs::String msg;</span><br><span class="line"></span><br><span class="line">std::stringstream ss;</span><br><span class="line"></span><br><span class="line">ss&lt;&lt;<span class="string">&quot;third pkg:&quot;</span>&lt;&lt;count;</span><br><span class="line"></span><br><span class="line">msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>,msg.data.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">chatter_pub.<span class="built_in">publish</span>(msg);<span class="comment">//将消息发布到话题中</span></span><br><span class="line"></span><br><span class="line">ros::<span class="built_in">spinOnce</span>();</span><br><span class="line"></span><br><span class="line">loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line"></span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改CMakeList文件"><a href="#修改CMakeList文件" class="headerlink" title="修改CMakeList文件"></a>修改CMakeList文件</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_executable(third_pkg_node src/third_pkg.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(third_pkg_node</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="在-third-pkg-下创建一个-launch-文件夹，并在该文件中创建并编译-third-pkg-launch-文件"><a href="#在-third-pkg-下创建一个-launch-文件夹，并在该文件中创建并编译-third-pkg-launch-文件" class="headerlink" title="在 third_pkg&#x2F; 下创建一个 launch 文件夹，并在该文件中创建并编译 third_pkg.launch 文件"></a>在 third_pkg&#x2F; 下创建一个 launch 文件夹，并在该文件中创建并编译 third_pkg.launch 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir launch</span><br><span class="line">cd launch</span><br><span class="line">touch third_pkg.launch</span><br><span class="line">subl third_pkg.launch</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;third_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;third_pkg_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;third_pkg_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改-robot-bringup-launch-下的-launch-文件"><a href="#修改-robot-bringup-launch-下的-launch-文件" class="headerlink" title="修改 robot_bringup&#x2F;launch&#x2F; 下的 launch 文件"></a>修改 robot_bringup&#x2F;launch&#x2F; 下的 launch 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;test_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;test_pkg_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test_pkg_node&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;true&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;my_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;my_pkg_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my_pkg_node&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find third_pkg)/launch/third_pkg.launch&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="然后编译运行"><a href="#然后编译运行" class="headerlink" title="然后编译运行"></a>然后编译运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br><span class="line">source ~/.bashrc</span><br><span class="line">roslaunch robot_bringup startup.launch</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros1/5.png"></p></blockquote><h3 id="好久没更新了，damn"><a href="#好久没更新了，damn" class="headerlink" title="好久没更新了，damn!"></a>好久没更新了，damn!</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> ROS1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十弹</title>
      <link href="/2025/02/23/12/"/>
      <url>/2025/02/23/12/</url>
      
        <content type="html"><![CDATA[<h1 id="话题通信实践案例"><a href="#话题通信实践案例" class="headerlink" title="话题通信实践案例"></a>话题通信实践案例</h1><h2 id="自定义通信接口"><a href="#自定义通信接口" class="headerlink" title="自定义通信接口"></a>自定义通信接口</h2><blockquote><h3 id="在-chapter-3-下创建一个新的文件层，接着在-src-下创建功能包，并进入功能包，在其目录下创建文件-msg，再进入-msg-，创建文件SystemStatus-msg"><a href="#在-chapter-3-下创建一个新的文件层，接着在-src-下创建功能包，并进入功能包，在其目录下创建文件-msg，再进入-msg-，创建文件SystemStatus-msg" class="headerlink" title="在 chapter_3 下创建一个新的文件层，接着在 src&#x2F; 下创建功能包，并进入功能包，在其目录下创建文件 msg，再进入 msg&#x2F;，创建文件SystemStatus.msg"></a>在 chapter_3 下创建一个新的文件层，接着在 src&#x2F; 下创建功能包，并进入功能包，在其目录下创建文件 msg，再进入 msg&#x2F;，创建文件SystemStatus.msg</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ~/learn_ros2/chapter_3/</span><br><span class="line">mkdir -p topic_practice_ws/src</span><br><span class="line">cd src/</span><br><span class="line">ros2 pkg create status_interfaces --dependencies builtin_interfaces rosidl_default_generators --license Apache-2.0</span><br><span class="line">cd status_interfaces/</span><br><span class="line">mkdir msg</span><br><span class="line">cd msg</span><br><span class="line">touch SystemStatus.msg</span><br></pre></td></tr></table></figure><h3 id="编辑-msg-文件内容"><a href="#编辑-msg-文件内容" class="headerlink" title="编辑 .msg 文件内容"></a>编辑 .msg 文件内容</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">builtin_interfaces/Time stamp #记录时间戳</span><br><span class="line">string host_name # 主机名字</span><br><span class="line">float32 cpu_percent # cpu使用率</span><br><span class="line">float32 memory_percent # 内存使用率</span><br><span class="line">float32 memory_available # 内存总大小</span><br><span class="line">float64 net_sent # 网络发送数据总量</span><br><span class="line">float64 net_receive # 网络数据接收总量</span><br></pre></td></tr></table></figure><h3 id="在-CMakeLists-和-package-xml-文件中添加相应语句"><a href="#在-CMakeLists-和-package-xml-文件中添加相应语句" class="headerlink" title="在 CMakeLists 和 package.xml 文件中添加相应语句"></a>在 CMakeLists 和 package.xml 文件中添加相应语句</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake函数，来自与rosidl_default_generators，将msg等消息接口定义文件转换成库或者头文件类</span></span><br><span class="line"><span class="comment"># 它会根据提供的消息接口去生成对应的cpp文件</span></span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="string">&quot;msg/SystemStatus.msg&quot;</span></span><br><span class="line">DEPENDENCIES builtin_interfaces</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>Apache-2.0<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"># 添加这句</span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="然后编译并修改环境变量"><a href="#然后编译并修改环境变量" class="headerlink" title="然后编译并修改环境变量"></a>然后编译并修改环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/learn_ros2/chapter_3/topic_practice_ws/</span><br><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br></pre></td></tr></table></figure><h3 id="编译好之后，在-topic-practice-ws-installl-下，有一个与功能包同名的文件，在该文件下有一个-include-文件，该文件下也有一个与包名同名的文件，里面有个-msg文件，在该文件中，就是-msg-文件转换得来的-hpp-和-h-文件"><a href="#编译好之后，在-topic-practice-ws-installl-下，有一个与功能包同名的文件，在该文件下有一个-include-文件，该文件下也有一个与包名同名的文件，里面有个-msg文件，在该文件中，就是-msg-文件转换得来的-hpp-和-h-文件" class="headerlink" title="编译好之后，在 topic_practice_ws&#x2F;installl 下，有一个与功能包同名的文件，在该文件下有一个 include 文件，该文件下也有一个与包名同名的文件，里面有个 msg文件，在该文件中，就是 .msg 文件转换得来的 .hpp 和 .h 文件"></a>编译好之后，在 topic_practice_ws&#x2F;installl 下，有一个与功能包同名的文件，在该文件下有一个 include 文件，该文件下也有一个与包名同名的文件，里面有个 msg文件，在该文件中，就是 .msg 文件转换得来的 .hpp 和 .h 文件</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_29.png"></p><h3 id="另外，在-detail-文件中，system-status-struct-hpp-文件里有-msg文件中定义的属性"><a href="#另外，在-detail-文件中，system-status-struct-hpp-文件里有-msg文件中定义的属性" class="headerlink" title="另外，在 detail 文件中，system_status__struct.hpp 文件里有 .msg文件中定义的属性"></a>另外，在 detail 文件中，system_status__struct.hpp 文件里有 .msg文件中定义的属性</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_30.png"></p><h3 id="查看生成的头文件的定义"><a href="#查看生成的头文件的定义" class="headerlink" title="查看生成的头文件的定义"></a>查看生成的头文件的定义</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface show status_interfaces/msg/SystemStatus</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_31.png"></p></blockquote><h2 id="系统信息发布与获取"><a href="#系统信息发布与获取" class="headerlink" title="系统信息发布与获取"></a>系统信息发布与获取</h2><blockquote><h3 id="在-topic-practice-ws-src-下创建一个功能包-status-publisher，要依赖-status-interfaces，这里创建python的，因为要使用python的一个库-psutil，可以相对简单的得到系统当前的各种信息"><a href="#在-topic-practice-ws-src-下创建一个功能包-status-publisher，要依赖-status-interfaces，这里创建python的，因为要使用python的一个库-psutil，可以相对简单的得到系统当前的各种信息" class="headerlink" title="在 topic_practice_ws&#x2F;src&#x2F; 下创建一个功能包 status_publisher，要依赖 status_interfaces，这里创建python的，因为要使用python的一个库 psutil，可以相对简单的得到系统当前的各种信息"></a>在 topic_practice_ws&#x2F;src&#x2F; 下创建一个功能包 status_publisher，要依赖 status_interfaces，这里创建python的，因为要使用python的一个库 psutil，可以相对简单的得到系统当前的各种信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create status_publisher --build-type ament_python --dependencies rclpy status_interfaces --licence Apache-2.0</span><br></pre></td></tr></table></figure><h3 id="在-status-publisher-src-下创建文件-sys-status-pub-cpp，内容如下"><a href="#在-status-publisher-src-下创建文件-sys-status-pub-cpp，内容如下" class="headerlink" title="在 status_publisher&#x2F;src 下创建文件 sys_status_pub.cpp，内容如下"></a>在 status_publisher&#x2F;src 下创建文件 sys_status_pub.cpp，内容如下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy  <span class="comment"># 导入ROS 2的Python客户端库</span></span><br><span class="line"><span class="keyword">from</span> status_interfaces.msg <span class="keyword">import</span> SystemStatus  <span class="comment"># 导入自定义消息类型 SystemStatus</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node  <span class="comment"># 导入ROS2节点类</span></span><br><span class="line"><span class="keyword">import</span> psutil  <span class="comment"># 用于获取系统的硬件状态，如CPU、内存和网络等</span></span><br><span class="line"><span class="keyword">import</span> platform  <span class="comment"># 用于获取系统的基本信息，如主机名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个类 SysStatusPub，继承自 Node 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SysStatusPub</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node_name</span>):</span><br><span class="line">        <span class="comment"># 初始化节点，node_name是节点的名字</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(node_name)  </span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 创建一个发布器，用于发布类型为 SystemStatus 的消息到 &#x27;sys_status&#x27; 话题，队列大小为 10</span></span><br><span class="line">           <span class="variable language_">self</span>.status_publisher_ = <span class="variable language_">self</span>.create_publisher(SystemStatus, <span class="string">&#x27;sys_status&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 创建定时器，每隔1秒调用一次 timer_callback 方法</span></span><br><span class="line">           <span class="variable language_">self</span>.timer_ = <span class="variable language_">self</span>.create_timer(<span class="number">1.0</span>, <span class="variable language_">self</span>.timer_callback)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 定时器回调函数，每隔1秒被调用一次</span></span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>):</span><br><span class="line">           <span class="comment"># 获取CPU的使用率，返回值为浮动百分比</span></span><br><span class="line">           cpu_percent = psutil.cpu_percent()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取内存的使用信息，包括已使用、总量、可用等数据</span></span><br><span class="line">           memory_info = psutil.virtual_memory()</span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 获取网络I/O的发送和接收信息（字节数）</span></span><br><span class="line">           net_io_counters = psutil.net_io_counters()</span><br><span class="line">   </span><br><span class="line">           <span class="comment"># 创建一个SystemStatus消息对象</span></span><br><span class="line">           msg = SystemStatus()</span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 设置时间戳，获取当前时间并转换为消息格式</span></span><br><span class="line">        msg.stamp = <span class="variable language_">self</span>.get_clock().now().to_msg()</span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 获取主机名</span></span><br><span class="line">                msg.host_name = platform.node()</span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 获取并设置CPU使用率</span></span><br><span class="line">           msg.cpu_percent = cpu_percent</span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 获取并设置内存的使用百分比</span></span><br><span class="line">           msg.memory_percent = memory_info.percent</span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 获取并设置内存的总大小，转换为float类型</span></span><br><span class="line">        msg.memory_total = <span class="built_in">float</span>(memory_info.total)</span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 获取并设置内存的可用大小，转换为float类型</span></span><br><span class="line">           msg.memory_available = <span class="built_in">float</span>(memory_info.available)</span><br><span class="line">        </span><br><span class="line">           <span class="comment"># 获取并设置网络发送的字节数，单位转换为MB</span></span><br><span class="line">           msg.net_sent = net_io_counters.bytes_sent / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line">           </span><br><span class="line">        <span class="comment"># 获取并设置网络接收的字节数，单位转换为MB</span></span><br><span class="line">           msg.net_recv = net_io_counters.bytes_recv / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line">   </span><br><span class="line">           <span class="comment"># 记录日志，输出当前的SystemStatus消息</span></span><br><span class="line">           <span class="variable language_">self</span>.get_logger().info(<span class="string">f&#x27;发布: <span class="subst">&#123;<span class="built_in">str</span>(msg)&#125;</span>&#x27;</span>)</span><br><span class="line">           </span><br><span class="line">           <span class="comment"># 发布消息</span></span><br><span class="line">           <span class="variable language_">self</span>.status_publisher_.publish(msg)</span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">   <span class="comment"># main函数，程序入口</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">            <span class="comment"># 初始化rclpy客户端库</span></span><br><span class="line">       rclpy.init()</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 创建一个SysStatusPub节点对象，节点名称为 &#x27;sys_status_pub&#x27;</span></span><br><span class="line">       node = SysStatusPub(<span class="string">&#x27;sys_status_pub&#x27;</span>)</span><br><span class="line">       </span><br><span class="line">       <span class="comment"># 使节点进入循环，保持节点运行并监听定时器事件</span></span><br><span class="line">    rclpy.spin(node)</span><br><span class="line">   </span><br><span class="line">       <span class="comment"># 关闭节点并关闭rclpy</span></span><br><span class="line">       rclpy.shutdown()</span><br></pre></td></tr></table></figure><h3 id="在-setup-py-中添加相应语句"><a href="#在-setup-py-中添加相应语句" class="headerlink" title="在 setup.py 中添加相应语句"></a>在 setup.py 中添加相应语句</h3>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> find_packages, setup</span><br><span class="line"></span><br><span class="line">package_name = <span class="string">&#x27;status_publisher&#x27;</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=package_name,</span><br><span class="line">    version=<span class="string">&#x27;0.0.0&#x27;</span>,</span><br><span class="line"> packages=find_packages(exclude=[<span class="string">&#x27;test&#x27;</span>]),</span><br><span class="line">    data_files=[</span><br><span class="line">        (<span class="string">&#x27;share/ament_index/resource_index/packages&#x27;</span>,</span><br><span class="line">            [<span class="string">&#x27;resource/&#x27;</span> + package_name]),</span><br><span class="line">     (<span class="string">&#x27;share/&#x27;</span> + package_name, [<span class="string">&#x27;package.xml&#x27;</span>]),</span><br><span class="line">    ],</span><br><span class="line">    install_requires=[<span class="string">&#x27;setuptools&#x27;</span>],</span><br><span class="line">    zip_safe=<span class="literal">True</span>,</span><br><span class="line">    maintainer=<span class="string">&#x27;yanzu&#x27;</span>,</span><br><span class="line">    maintainer_email=<span class="string">&#x27;yanzu@todo.todo&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;TODO: Package description&#x27;</span>,</span><br><span class="line">         license=<span class="string">&#x27;Apache-2.0&#x27;</span>,</span><br><span class="line">    tests_require=[<span class="string">&#x27;pytest&#x27;</span>],</span><br><span class="line">    entry_points=&#123;</span><br><span class="line">        <span class="string">&#x27;console_scripts&#x27;</span>: [</span><br><span class="line">            <span class="comment"># 添加这句</span></span><br><span class="line">        <span class="string">&#x27;sys_status_pub = status_publisher.sys_status_pub:main&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line"> &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="然后编译运行"><a href="#然后编译运行" class="headerlink" title="然后编译运行"></a>然后编译运行</h3>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run status_publisher sys_status_pub</span><br></pre></td></tr></table></figure><p>   <img src="http://picbed.yanzu.tech/img/learn_ros2/pic_32.png"></p><h3 id="打印接口信息"><a href="#打印接口信息" class="headerlink" title="打印接口信息"></a>打印接口信息</h3>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic echo /sys_status</span><br></pre></td></tr></table></figure><p>   <img src="http://picbed.yanzu.tech/img/learn_ros2/pic_33.png"></p></blockquote><h2 id="在功能包中使用QT"><a href="#在功能包中使用QT" class="headerlink" title="在功能包中使用QT"></a>在功能包中使用QT</h2><blockquote><h3 id="在-topic-practice-ws-src-下创建功能包-status-display，且要依赖-status-interfaces"><a href="#在-topic-practice-ws-src-下创建功能包-status-display，且要依赖-status-interfaces" class="headerlink" title="在 topic_practice_ws&#x2F;src&#x2F; 下创建功能包 status_display，且要依赖 status_interfaces"></a>在 topic_practice_ws&#x2F;src&#x2F; 下创建功能包 status_display，且要依赖 status_interfaces</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create status_display --dependencies rclcpp status_interfaces --license Apache-2.0</span><br></pre></td></tr></table></figure><h3 id="在-status-display-src-下创建文件-hello-qt-cpp，内容如下"><a href="#在-status-display-src-下创建文件-hello-qt-cpp，内容如下" class="headerlink" title="在 status_display&#x2F;src&#x2F; 下创建文件 hello_qt.cpp，内容如下"></a>在 status_display&#x2F;src&#x2F; 下创建文件 hello_qt.cpp，内容如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">QString message = QString::<span class="built_in">fromStdString</span>(<span class="string">&quot;hello qt!&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setText</span>(message);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br><span class="line">app.<span class="built_in">exec</span>();<span class="comment">// 执行应用,阻塞代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-CMakeLists-中添加相应语句"><a href="#在-CMakeLists-中添加相应语句" class="headerlink" title="在 CMakeLists 中添加相应语句"></a>在 CMakeLists 中添加相应语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找 qt5 组件</span></span><br><span class="line">find_package(Qt5 REQUIRED COMPONENTS Widgets)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加可执行文件</span></span><br><span class="line">add_executable(hello_qt src/hello_qt.cpp)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加依赖库</span></span><br><span class="line">target_link_libraries(hello_qt Qt5::Widgets)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝节点到 install/lib</span></span><br><span class="line">install(TARGETS hello_qt</span><br><span class="line">DESTINATION lib/$&#123;PROJECT_NAME&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="然后编译执行"><a href="#然后编译执行" class="headerlink" title="然后编译执行"></a>然后编译执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run status_display hello_qt</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_34.png"></p></blockquote><h2 id="订阅数据并使用Qt显示"><a href="#订阅数据并使用Qt显示" class="headerlink" title="订阅数据并使用Qt显示"></a>订阅数据并使用Qt显示</h2><blockquote><h3 id="在-status-display-src-下创建文件-sys-status-display-cpp，内容如下"><a href="#在-status-display-src-下创建文件-sys-status-display-cpp，内容如下" class="headerlink" title="在 status_display&#x2F;src&#x2F; 下创建文件 sys_status_display.cpp，内容如下"></a>在 status_display&#x2F;src&#x2F; 下创建文件 sys_status_display.cpp，内容如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span>      <span class="comment">// 引入Qt应用程序库，用于创建GUI界面</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span>            <span class="comment">// 引入Qt标签控件，用于显示系统状态信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span>           <span class="comment">// 引入Qt字符串类，用于处理字符串</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rclcpp/rclcpp.hpp&gt;</span> <span class="comment">// 引入ROS2 C++客户端库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;status_interfaces/msg/system_status.hpp&quot;</span> <span class="comment">// 引入自定义消息类型 SystemStatus</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 SystemStatus 类型简写</span></span><br><span class="line"><span class="keyword">using</span> SystemStatus = status_interfaces::msg::SystemStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 SysStatusDisplay 类，继承自 ROS2 的 Node 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SysStatusDisplay</span> : <span class="keyword">public</span> rclcpp::Node &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义一个共享指针的订阅者，订阅 SystemStatus 类型的消息</span></span><br><span class="line">    rclcpp::Subscription&lt;SystemStatus&gt;::SharedPtr subscriber_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 QLabel 控件，用于显示系统状态信息</span></span><br><span class="line">    QLabel* label_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// SysStatusDisplay 构造函数，初始化节点名为 &quot;sys_status_display&quot;</span></span><br><span class="line">    <span class="built_in">SysStatusDisplay</span>() : <span class="built_in">Node</span>(<span class="string">&quot;sys_status_display&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 QLabel 控件</span></span><br><span class="line">        label_ = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个订阅者，订阅 &quot;sys_status&quot; 话题，消息队列大小为10</span></span><br><span class="line">        subscriber_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;SystemStatus&gt;(</span><br><span class="line">            <span class="string">&quot;sys_status&quot;</span>, <span class="number">10</span>, </span><br><span class="line">            [&amp;](<span class="type">const</span> SystemStatus::SharedPtr msg) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">                <span class="comment">// 每当接收到消息时，更新标签文本</span></span><br><span class="line">                label_-&gt;<span class="built_in">setText</span>(<span class="built_in">get_qstr_from_msg</span>(msg));</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化时，先显示一个默认的空状态</span></span><br><span class="line">        label_-&gt;<span class="built_in">setText</span>(<span class="built_in">get_qstr_from_msg</span>(std::<span class="built_in">make_shared</span>&lt;SystemStatus&gt;()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示 QLabel 控件</span></span><br><span class="line">        label_-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将接收到的 SystemStatus 消息转换为 QString 类型的文本</span></span><br><span class="line">    <span class="function">QString <span class="title">get_qstr_from_msg</span><span class="params">(<span class="type">const</span> SystemStatus::SharedPtr msg)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用字符串流构造格式化的字符串</span></span><br><span class="line">        std::stringstream show_str;</span><br><span class="line">        show_str &lt;&lt;</span><br><span class="line">        <span class="string">&quot;==========系统状态可视化工具==========\n&quot;</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;数 据 时 间：\t&quot;</span> &lt;&lt; msg-&gt;stamp.sec &lt;&lt; <span class="string">&quot;\ts\n&quot;</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;主 机 名 字：\t&quot;</span> &lt;&lt; msg-&gt;host_name &lt;&lt; <span class="string">&quot;\t\n&quot;</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;CPU使用率：\t&quot;</span> &lt;&lt; msg-&gt;cpu_percent &lt;&lt; <span class="string">&quot;\t%\n&quot;</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;内存使用率：\t&quot;</span> &lt;&lt; msg-&gt;memory_percent &lt;&lt; <span class="string">&quot;\t%\n&quot;</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;可 用 内 存：\t&quot;</span> &lt;&lt; msg-&gt;memory_available &lt;&lt; <span class="string">&quot;\tMB\n&quot;</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;网络发送数据量：\t&quot;</span> &lt;&lt; msg-&gt;net_sent &lt;&lt; <span class="string">&quot;\tMB\n&quot;</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;网络接收数据量：\t&quot;</span> &lt;&lt; msg-&gt;net_recv &lt;&lt; <span class="string">&quot;\tMB\n&quot;</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;====================================&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将构造的字符串转换为 QString 类型返回</span></span><br><span class="line">        <span class="keyword">return</span> QString::<span class="built_in">fromStdString</span>(show_str.<span class="built_in">str</span>());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数，程序入口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 ROS2 客户端库</span></span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Qt 应用程序</span></span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 SysStatusDisplay 对象（ROS2节点和GUI控件）</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SysStatusDisplay&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并启动一个新的线程，运行 ROS2 节点的 spin 方法</span></span><br><span class="line">    <span class="function">std::thread <span class="title">spin_thread</span><span class="params">([&amp;]()-&gt;<span class="type">void</span>&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 运行 ROS2 事件循环，处理订阅和回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">        rclcpp::spin(node);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="comment">// 分离线程，使其在后台继续执行</span></span><br><span class="line">    spin_thread.<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动 Qt 应用程序的事件循环，开始界面显示并处理用户交互</span></span><br><span class="line">    app.<span class="built_in">exec</span>(); <span class="comment">// 阻塞，直到应用程序结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-CMakeLists-中添加相应语句-1"><a href="#在-CMakeLists-中添加相应语句-1" class="headerlink" title="在 CMakeLists 中添加相应语句"></a>在 CMakeLists 中添加相应语句</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(sys_status_display src/sys_status_display.cpp)</span><br><span class="line"><span class="comment"># 添加依赖库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(sys_status_display Qt5::Widgets)</span><br><span class="line">ament_target_dependencies(sys_status_display rclcpp status_interfaces)</span><br><span class="line"><span class="comment"># 拷贝节点到 install/lib</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS hello_qt sys_status_display</span><br><span class="line">DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="然后构建运行-提前运行-sys-status-pub-节点"><a href="#然后构建运行-提前运行-sys-status-pub-节点" class="headerlink" title="然后构建运行(提前运行 sys_status_pub 节点)"></a>然后构建运行(提前运行 sys_status_pub 节点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run status_display sys_status_display</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_35.png"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九弹</title>
      <link href="/2025/02/20/11/"/>
      <url>/2025/02/20/11/</url>
      
        <content type="html"><![CDATA[<h1 id="cpp话题订阅与发布"><a href="#cpp话题订阅与发布" class="headerlink" title="cpp话题订阅与发布"></a>cpp话题订阅与发布</h1><h2 id="发布速度控制小海龟画圆"><a href="#发布速度控制小海龟画圆" class="headerlink" title="发布速度控制小海龟画圆"></a>发布速度控制小海龟画圆</h2><blockquote><h3 id="查看小海龟节点的话题列表"><a href="#查看小海龟节点的话题列表" class="headerlink" title="查看小海龟节点的话题列表"></a>查看小海龟节点的话题列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list -t</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_22.png"></p><h3 id="在-chapter-3-topic-ws-src-下创建包-demo-cpp-topic"><a href="#在-chapter-3-topic-ws-src-下创建包-demo-cpp-topic" class="headerlink" title="在 chapter_3&#x2F;topic_ws&#x2F;src&#x2F; 下创建包 demo_cpp_topic"></a>在 chapter_3&#x2F;topic_ws&#x2F;src&#x2F; 下创建包 demo_cpp_topic</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create demo_cpp_topic --build-type ament_cmake --dependencies rclcpp geometry_msgs turtlesim --license Apache-2.0</span><br></pre></td></tr></table></figure><h3 id="进入-demo-cpp-topic-src-创建-turtlesim-circle-cpp，其内容如下"><a href="#进入-demo-cpp-topic-src-创建-turtlesim-circle-cpp，其内容如下" class="headerlink" title="进入 demo_cpp_topic&#x2F;src 创建 turtlesim_circle.cpp，其内容如下"></a>进入 demo_cpp_topic&#x2F;src 创建 turtlesim_circle.cpp，其内容如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/twist.hpp&quot;</span><span class="comment">// 引入geometry_msgs中Twist消息类型，用于控制机器人速度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span><span class="comment">// 引入chrono库用于处理时间</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;<span class="comment">// 方便使用时间单位如1s, 100ms等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 rclcpp::Node，表示一个ROS2节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurtleCircleNode</span> : <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 定义定时器的智能指针，用于定时触发回调函数</span></span><br><span class="line">rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义发布者的智能指针，用于发布Twist消息</span></span><br><span class="line">rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化节点并创建定时器和发布者</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TurtleCircleNode</span><span class="params">(<span class="type">const</span> std::string &amp;node_name)</span> : Node(node_name)&#123;</span></span><br><span class="line"><span class="comment">// 创建发布者，负责将Twist消息发布到指定话题&quot;/turtle1/cmd_vel&quot;上，队列大小为10</span></span><br><span class="line">publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;geometry_msgs::msg::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 传入间隔周期，传入回调函数(可以使用成员函数作为回调函数，也可以使用 Lambda)</span></span><br><span class="line"><span class="comment">// 成员函数作为回调函数需要使用bind与当前对象进行绑定</span></span><br><span class="line"><span class="comment">// bind(param1, param2, param3) param1:函数的位置，param2:指向当前对象的指针, param3:参数列表占位符</span></span><br><span class="line">        <span class="comment">// 创建一个定时器，周期为1000ms（1秒），定时调用timer_callback()回调函数</span></span><br><span class="line">        <span class="comment">// 由于 timer_callback() 是一个不带参数的成员函数，所以参数列表中只有两个参数，如果成员函数有参数，那么bind的参数列表中也要相应的添加对应参数</span></span><br><span class="line">timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1000</span>ms, std::<span class="built_in">bind</span>(&amp;TurtleCircleNode::timer_callback, <span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里使用成员函数来作为回调函数</span></span><br><span class="line">    <span class="comment">// 定时器回调函数，按设定的周期触发</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_callback</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 创建Twist消息对象</span></span><br><span class="line"><span class="keyword">auto</span> msg = geometry_msgs::msg::<span class="built_in">Twist</span>();</span><br><span class="line">        <span class="comment">// 设置线速度：x轴方向速度为1.0，y轴方向为0.0（不移动）</span></span><br><span class="line">msg.linear.x = <span class="number">1.0</span>;</span><br><span class="line">msg.linear.y = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">// 设置角速度：z轴角速度为0.5，表示沿着Z轴旋转</span></span><br><span class="line">msg.angular.z = <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">// 发布消息，通过发布者将控制命令发布出去</span></span><br><span class="line">publisher_-&gt;<span class="built_in">publish</span>(msg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line"><span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;TurtleCircleNode&gt;(<span class="string">&quot;turtle_circle&quot;</span>);</span><br><span class="line">rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line"></span><br><span class="line">rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果上面的回调函数使用-Lambda-表达式实现，则写成这样"><a href="#如果上面的回调函数使用-Lambda-表达式实现，则写成这样" class="headerlink" title="如果上面的回调函数使用 Lambda 表达式实现，则写成这样"></a>如果上面的回调函数使用 Lambda 表达式实现，则写成这样</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(</span><br><span class="line">    <span class="number">1000</span>ms, </span><br><span class="line">    [<span class="keyword">this</span>]() &#123; </span><br><span class="line">        <span class="comment">// Lambda 捕获当前对象，并在 Lambda 内部调用成员函数</span></span><br><span class="line">        <span class="keyword">auto</span> msg = geometry_msgs::msg::<span class="built_in">Twist</span>();</span><br><span class="line">        msg.linear.x = <span class="number">1.0</span>;</span><br><span class="line">        msg.linear.y = <span class="number">0.0</span>;</span><br><span class="line">        msg.angular.z = <span class="number">0.5</span>;</span><br><span class="line">        publisher_-&gt;<span class="built_in">publish</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="在-CMakeLists-中添加相应语句"><a href="#在-CMakeLists-中添加相应语句" class="headerlink" title="在 CMakeLists 中添加相应语句"></a>在 CMakeLists 中添加相应语句</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(turtle_circle src/turtlesim_circle.cpp)</span><br><span class="line"><span class="comment"># 包含依赖</span></span><br><span class="line">ament_target_dependencies(turtle_circle rclcpp geometry_msgs)</span><br><span class="line"><span class="comment"># 拷贝节点到 install/lib 下</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS turtle_circle</span><br><span class="line">DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编译并运行-先运行小海龟节点"><a href="#编译并运行-先运行小海龟节点" class="headerlink" title="编译并运行(先运行小海龟节点)"></a>编译并运行(先运行小海龟节点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/learn_ros2/chapter_3/topic_ws/</span><br><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run demo_cpp_topic turtle_circle</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_23.png"></p><h3 id="运行起来之后，在新的终端可以查看相关信息"><a href="#运行起来之后，在新的终端可以查看相关信息" class="headerlink" title="运行起来之后，在新的终端可以查看相关信息"></a>运行起来之后，在新的终端可以查看相关信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list -t</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_24.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node info /turtle_circle</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_25.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic echo /turtle1/cmd_vel</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_26.png"></p></blockquote><h2 id="订阅pose实现闭环控制"><a href="#订阅pose实现闭环控制" class="headerlink" title="订阅pose实现闭环控制"></a>订阅pose实现闭环控制</h2><blockquote><h3 id="查看当前节点的话题列表"><a href="#查看当前节点的话题列表" class="headerlink" title="查看当前节点的话题列表"></a>查看当前节点的话题列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list -t</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_24.png"></p><h3 id="找到小海龟位置信息的话题，-turtle1-pose，对应的消息接口为-turtlesim-msg-Pose"><a href="#找到小海龟位置信息的话题，-turtle1-pose，对应的消息接口为-turtlesim-msg-Pose" class="headerlink" title="找到小海龟位置信息的话题，&#x2F;turtle1&#x2F;pose，对应的消息接口为 turtlesim&#x2F;msg&#x2F;Pose"></a>找到小海龟位置信息的话题，&#x2F;turtle1&#x2F;pose，对应的消息接口为 turtlesim&#x2F;msg&#x2F;Pose</h3><h3 id="查看消息接口的定义"><a href="#查看消息接口的定义" class="headerlink" title="查看消息接口的定义"></a>查看消息接口的定义</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface show turtlesim/msg/Pose</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_27.png"></p><h3 id="在-demo-cpp-topic-src-下创建文件-turtle-control-cpp，其内容如下"><a href="#在-demo-cpp-topic-src-下创建文件-turtle-control-cpp，其内容如下" class="headerlink" title="在 demo_cpp_topic&#x2F;src 下创建文件 turtle_control.cpp，其内容如下"></a>在 demo_cpp_topic&#x2F;src 下创建文件 turtle_control.cpp，其内容如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/twist.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/msg/pose.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurtleControlNode</span> : <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 发布者的智能指针</span></span><br><span class="line">rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_;</span><br><span class="line">rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr subscriber_;</span><br><span class="line"><span class="type">double</span> target_x_&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> target_y_&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> k_&#123;<span class="number">1.0</span>&#125;;<span class="comment">// 比例系数</span></span><br><span class="line"><span class="type">double</span> max_speed_&#123;<span class="number">3.0</span>&#125;;<span class="comment">// 最大速度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TurtleControlNode</span><span class="params">(<span class="type">const</span> std::string &amp;node_name)</span> : Node(node_name)&#123;</span></span><br><span class="line"><span class="comment">// 创建发布者</span></span><br><span class="line">publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;geometry_msgs::msg::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line">subscriber_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;turtlesim::msg::Pose&gt;(<span class="string">&quot;/turtle1/pose&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;TurtleControlNode::on_pose_received_, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_pose_received_</span><span class="params">(<span class="type">const</span> turtlesim::msg::Pose::SharedPtr pose)</span></span>&#123;</span><br><span class="line"><span class="comment">// 获取小海龟当前位置</span></span><br><span class="line"><span class="type">double</span> current_x = pose-&gt;x;</span><br><span class="line"><span class="type">double</span> current_y = pose-&gt;y;</span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;当前位置 x: %f,y: %f &quot;</span>, current_x, current_y);</span><br><span class="line"><span class="comment">// 计算当前位置与目标位置的距离差和角度差</span></span><br><span class="line"><span class="type">double</span> distance = std::<span class="built_in">sqrt</span>((target_x_ - current_x)*(target_x_ - current_x) + (target_y_ - current_y)*(target_y_ - current_y));</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> angle = std::<span class="built_in">atan2</span>((target_y_ - current_y), (target_x_ - current_x)) - pose-&gt;theta;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制策略</span></span><br><span class="line"><span class="keyword">auto</span> msg = geometry_msgs::msg::<span class="built_in">Twist</span>();</span><br><span class="line"><span class="keyword">if</span>(distance &gt; <span class="number">0.1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(angle) &gt; <span class="number">0.2</span>)&#123;</span><br><span class="line">msg.angular.z = <span class="built_in">fabs</span>(angle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">msg.linear.x = k_ * distance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 限制线速度最大值</span></span><br><span class="line"><span class="keyword">if</span>(msg.linear.x &gt; max_speed_)&#123;</span><br><span class="line">msg.linear.x = max_speed_;</span><br><span class="line">&#125;</span><br><span class="line">publisher_-&gt;<span class="built_in">publish</span>(msg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line"><span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;TurtleControlNode&gt;(<span class="string">&quot;turtle_control&quot;</span>);</span><br><span class="line">rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line"></span><br><span class="line">rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-CMakeLists-文件中添加相应语句"><a href="#在-CMakeLists-文件中添加相应语句" class="headerlink" title="在 CMakeLists 文件中添加相应语句"></a>在 CMakeLists 文件中添加相应语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加可执行文件</span></span><br><span class="line">add_executable(turtle_control src/turtle_control.cpp)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加依赖</span></span><br><span class="line">ament_target_dependencies(turtle_control rclcpp geometry_msgs turtlesim)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝节点到 install/lib</span></span><br><span class="line">install(TARGETS turtle_circle turtle_control</span><br><span class="line">DESTINATION lib/$&#123;PROJECT_NAME&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编译运行-先运行-turtle-节点"><a href="#编译运行-先运行-turtle-节点" class="headerlink" title="编译运行(先运行 turtle 节点)"></a>编译运行(先运行 turtle 节点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/learn_ros2/chapter_3/topic_ws/</span><br><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run demo_cpp_topic turtle_control</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_28.png"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八弹</title>
      <link href="/2025/02/20/10/"/>
      <url>/2025/02/20/10/</url>
      
        <content type="html"><![CDATA[<h1 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h1><h3 id="一个话题包含了发布节点、订阅节点、话题名称和话题类型四个方面"><a href="#一个话题包含了发布节点、订阅节点、话题名称和话题类型四个方面" class="headerlink" title="一个话题包含了发布节点、订阅节点、话题名称和话题类型四个方面"></a>一个话题包含了发布节点、订阅节点、话题名称和话题类型四个方面</h3><blockquote><h3 id="小海龟示例"><a href="#小海龟示例" class="headerlink" title="小海龟示例"></a>小海龟示例</h3><h3 id="启动小海龟模拟器"><a href="#启动小海龟模拟器" class="headerlink" title="启动小海龟模拟器"></a>启动小海龟模拟器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_15.png"></p><h3 id="然后在同一路径下打开一个新的终端"><a href="#然后在同一路径下打开一个新的终端" class="headerlink" title="然后在同一路径下打开一个新的终端"></a>然后在同一路径下打开一个新的终端</h3><h3 id="查看当前运行的节点列表"><a href="#查看当前运行的节点列表" class="headerlink" title="查看当前运行的节点列表"></a>查看当前运行的节点列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node list</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_16.png"></p><h3 id="查看当前运行节点的信息"><a href="#查看当前运行节点的信息" class="headerlink" title="查看当前运行节点的信息"></a>查看当前运行节点的信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node info /turtlesim</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_17.png"></p><h3 id="其中，订阅者里的-turtle1-cmd-vel-话题是负责控制小海龟的，发布者里的-turtle1-pose-是小海龟的实时位置信息"><a href="#其中，订阅者里的-turtle1-cmd-vel-话题是负责控制小海龟的，发布者里的-turtle1-pose-是小海龟的实时位置信息" class="headerlink" title="其中，订阅者里的 &#x2F;turtle1&#x2F;cmd_vel 话题是负责控制小海龟的，发布者里的 &#x2F;turtle1&#x2F;pose 是小海龟的实时位置信息"></a>其中，订阅者里的 &#x2F;turtle1&#x2F;cmd_vel 话题是负责控制小海龟的，发布者里的 &#x2F;turtle1&#x2F;pose 是小海龟的实时位置信息</h3><h3 id="输出小海龟位置信息"><a href="#输出小海龟位置信息" class="headerlink" title="输出小海龟位置信息"></a>输出小海龟位置信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic echo /turtle1/pose</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_18.png"></p><h3 id="小海龟的位置信息包含五个参数，坐标-x-y-，头的朝向的角度-theta，线速度-linear-velocity，角速度-angular-velocity"><a href="#小海龟的位置信息包含五个参数，坐标-x-y-，头的朝向的角度-theta，线速度-linear-velocity，角速度-angular-velocity" class="headerlink" title="小海龟的位置信息包含五个参数，坐标(x, y)，头的朝向的角度 theta，线速度 linear_velocity，角速度 angular_velocity"></a>小海龟的位置信息包含五个参数，坐标(x, y)，头的朝向的角度 theta，线速度 linear_velocity，角速度 angular_velocity</h3><h3 id="获取某个话题的消息接口"><a href="#获取某个话题的消息接口" class="headerlink" title="获取某个话题的消息接口"></a>获取某个话题的消息接口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic info /turtle1/cmd_vel</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_19.png"></p><h3 id="查看接口的详细定义"><a href="#查看接口的详细定义" class="headerlink" title="查看接口的详细定义"></a>查看接口的详细定义</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface show geometry_msgs/msg/Twist</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_20.png"></p><h3 id="在确认某个节点的消息接口之后，可以直接对话题发布数据"><a href="#在确认某个节点的消息接口之后，可以直接对话题发布数据" class="headerlink" title="在确认某个节点的消息接口之后，可以直接对话题发布数据"></a>在确认某个节点的消息接口之后，可以直接对话题发布数据</h3><h3 id="turtle1-cmd-vel-是话题名，geometry-msgs-msg-Twist-消息接口，后面是-yaml-格式的数据，"><a href="#turtle1-cmd-vel-是话题名，geometry-msgs-msg-Twist-消息接口，后面是-yaml-格式的数据，" class="headerlink" title="&#x2F;turtle1&#x2F;cmd_vel 是话题名，geometry_msgs&#x2F;msg&#x2F;Twist 消息接口，后面是 yaml 格式的数据，"></a>&#x2F;turtle1&#x2F;cmd_vel 是话题名，geometry_msgs&#x2F;msg&#x2F;Twist 消息接口，后面是 yaml 格式的数据，</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic pub /turtle1/cmd_vel geometry_msgs/msg/Twist &quot;&#123;linear: &#123;x: 0.5, y: 0.0&#125; , angular: &#123;z: 0.0&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="如果同一时刻，有多个终端对该消息接口发布数据，那么小海龟的运动就会变得奇怪起来"><a href="#如果同一时刻，有多个终端对该消息接口发布数据，那么小海龟的运动就会变得奇怪起来" class="headerlink" title="如果同一时刻，有多个终端对该消息接口发布数据，那么小海龟的运动就会变得奇怪起来"></a>如果同一时刻，有多个终端对该消息接口发布数据，那么小海龟的运动就会变得奇怪起来</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_21.png"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu使用</title>
      <link href="/2025/02/19/09/"/>
      <url>/2025/02/19/09/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu-换源"><a href="#Ubuntu-换源" class="headerlink" title="Ubuntu 换源"></a>Ubuntu 换源</h1><h3 id="在使用-sudo-apt-get-update-和-sudo-apt-get-upgrade-进行更新时，可能下载会很慢，这个时候使用国内的镜像资源可能会明显提升下载速度。"><a href="#在使用-sudo-apt-get-update-和-sudo-apt-get-upgrade-进行更新时，可能下载会很慢，这个时候使用国内的镜像资源可能会明显提升下载速度。" class="headerlink" title="在使用 sudo apt-get update 和 sudo apt-get upgrade 进行更新时，可能下载会很慢，这个时候使用国内的镜像资源可能会明显提升下载速度。"></a>在使用 sudo apt-get update 和 sudo apt-get upgrade 进行更新时，可能下载会很慢，这个时候使用国内的镜像资源可能会明显提升下载速度。</h3><blockquote><h3 id="先是要备份原来的源文件"><a href="#先是要备份原来的源文件" class="headerlink" title="先是要备份原来的源文件"></a>先是要备份原来的源文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h3 id="再编辑-sources-list-文件"><a href="#再编辑-sources-list-文件" class="headerlink" title="再编辑 sources.list 文件"></a>再编辑 sources.list 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure><h3 id="这里使用阿里云的镜像"><a href="#这里使用阿里云的镜像" class="headerlink" title="这里使用阿里云的镜像"></a>这里使用阿里云的镜像</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://mirrors.aliyun.com/ubuntu/</span><br></pre></td></tr></table></figure><h3 id="替换后，再进行更新"><a href="#替换后，再进行更新" class="headerlink" title="替换后，再进行更新"></a>替换后，再进行更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七弹</title>
      <link href="/2025/02/18/08/"/>
      <url>/2025/02/18/08/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程与回调函数"><a href="#多线程与回调函数" class="headerlink" title="多线程与回调函数"></a>多线程与回调函数</h1><h3 id="需要下载一个-cpp-httplib-，下载到-workspace-src-demo-one-pkg-include"><a href="#需要下载一个-cpp-httplib-，下载到-workspace-src-demo-one-pkg-include" class="headerlink" title="需要下载一个 cpp-httplib ，下载到 workspace&#x2F;src&#x2F;demo_one_pkg&#x2F;include&#x2F;"></a>需要下载一个 cpp-httplib ，下载到 workspace&#x2F;src&#x2F;demo_one_pkg&#x2F;include&#x2F;</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/ohhuo/cpp-httplib.git</span><br></pre></td></tr></table></figure><h3 id="下载后得到如下文件"><a href="#下载后得到如下文件" class="headerlink" title="下载后得到如下文件"></a>下载后得到如下文件</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_12.png"></p></blockquote><h3 id="下载好之后，修改-demo-one-pkg-的-CMakeLists-文件"><a href="#下载好之后，修改-demo-one-pkg-的-CMakeLists-文件" class="headerlink" title="下载好之后，修改 demo_one_pkg 的 CMakeLists 文件"></a>下载好之后，修改 demo_one_pkg 的 CMakeLists 文件</h3><blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含 cpp-httplib 的 include</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure></blockquote><h3 id="接着，在-demo-one-pkg-src-下创建-learn-thread-cpp，内容如下"><a href="#接着，在-demo-one-pkg-src-下创建-learn-thread-cpp，内容如下" class="headerlink" title="接着，在 demo_one_pkg&#x2F;src 下创建 learn_thread.cpp，内容如下"></a>接着，在 demo_one_pkg&#x2F;src 下创建 learn_thread.cpp，内容如下</h3><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span><span class="comment">// 多线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span><span class="comment">// 时间相关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span><span class="comment">// 函数包装器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cpp-httplib/httplib.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span><span class="comment">// 用于 std::async 处理异步任务</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Download</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 下载函数,负责下载文件并调用回调函数</span></span><br><span class="line"><span class="comment">// host 主机， path 路径，回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download</span><span class="params">(<span class="type">const</span> std::string&amp; host, <span class="type">const</span> std::string&amp; path, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;, <span class="type">const</span> std::string &amp;)&gt; &amp;callback_word_count)</span></span>&#123;</span><br><span class="line"><span class="comment">// 输出当前线程ID，便于调试</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;线程编号： &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 创建客户端对象，指定主机</span></span><br><span class="line"><span class="function">httplib::Client <span class="title">client</span><span class="params">(host)</span></span>;</span><br><span class="line"><span class="comment">// 发送 GET 请求，获取文件内容</span></span><br><span class="line"><span class="keyword">auto</span> response = client.<span class="built_in">Get</span>(path);</span><br><span class="line"><span class="comment">// 如果请求成功且状态码为200</span></span><br><span class="line"><span class="keyword">if</span>(response &amp;&amp; response-&gt;status == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="comment">// 调用回调函数并传递文件内容</span></span><br><span class="line"><span class="built_in">callback_word_count</span>(path, response-&gt;body);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动下载函数,使用 std::async 异步执行下载任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start_download</span><span class="params">(<span class="type">const</span> std::string&amp; host, <span class="type">const</span> std::string&amp; path, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;, <span class="type">const</span> std::string &amp;)&gt; &amp;callback_word_count)</span></span>&#123;</span><br><span class="line"><span class="comment">// 函数包装器进行包装</span></span><br><span class="line"><span class="comment">// auto download_fun = std::bind(&amp;Download::start_download, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);</span></span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="comment">// std::thread thread(download_fun, host, path, callback_word_count);</span></span><br><span class="line"><span class="comment">// 等待线程结束</span></span><br><span class="line"><span class="comment">// thread.join();</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 直接通过 std::async 可以异步执行任务，同时它会返回一个 std::future 对象，保证任务的异步执行，而主线程会等待任务完成</span></span><br><span class="line"><span class="comment">// std::launch::async 会指示 std::async 强制使用新的线程执行任务</span></span><br><span class="line"><span class="keyword">auto</span> future = std::<span class="built_in">async</span>(std::launch::async, [=]()&#123;</span><br><span class="line"><span class="built_in">download</span>(host, path, callback_word_count);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = <span class="built_in">Download</span>();</span><br><span class="line"><span class="comment">// 创建回调函数, path 地址， result 结果</span></span><br><span class="line"><span class="keyword">auto</span> word_count = [](<span class="type">const</span> std::string &amp;path, <span class="type">const</span> std::string &amp;result) -&gt; <span class="type">void</span>&#123;</span><br><span class="line"><span class="comment">// 输出文件路径，文件内容的长度，以及文件内容的前五个字符</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;下载完成 &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; result.<span class="built_in">length</span>() &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; result.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个下载任务，分别下载 novel1.txt、novel2.txt 和 novel3.txt</span></span><br><span class="line">d.<span class="built_in">start_download</span>(<span class="string">&quot;http://0.0.0.0:8080&quot;</span>, <span class="string">&quot;/novel1.txt&quot;</span>, word_count);</span><br><span class="line">d.<span class="built_in">start_download</span>(<span class="string">&quot;http://0.0.0.0:8080&quot;</span>, <span class="string">&quot;/novel2.txt&quot;</span>, word_count);</span><br><span class="line">d.<span class="built_in">start_download</span>(<span class="string">&quot;http://0.0.0.0:8080&quot;</span>, <span class="string">&quot;/novel3.txt&quot;</span>, word_count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程休眠10秒，确保所有异步线程有足够时间完成下载任务</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>*<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这里需要注意的是-std-async-的用法"><a href="#这里需要注意的是-std-async-的用法" class="headerlink" title="这里需要注意的是 std::async 的用法"></a>这里需要注意的是 std::async 的用法</h3><blockquote><h3 id="它是-C-11-引入的一个标准库函数，用于启动异步任务。它接受一个可调用对象（比如函数、函数指针、Lambda-表达式等）和一些参数，并返回一个-std-future-对象，表示异步操作的结果。"><a href="#它是-C-11-引入的一个标准库函数，用于启动异步任务。它接受一个可调用对象（比如函数、函数指针、Lambda-表达式等）和一些参数，并返回一个-std-future-对象，表示异步操作的结果。" class="headerlink" title="它是 C++11 引入的一个标准库函数，用于启动异步任务。它接受一个可调用对象（比如函数、函数指针、Lambda 表达式等）和一些参数，并返回一个 std::future 对象，表示异步操作的结果。"></a>它是 C++11 引入的一个标准库函数，用于启动异步任务。它接受一个可调用对象（比如函数、函数指针、Lambda 表达式等）和一些参数，并返回一个 std::future 对象，表示异步操作的结果。</h3><h3 id="语法如下"><a href="#语法如下" class="headerlink" title="语法如下"></a>语法如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::future&lt;T&gt; <span class="title">async</span><span class="params">(std::launch policy, F&amp;&amp; f, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="std-launch-指定任务的执行策略，如-std-launch-async-或-std-launch-deferred。前者是任务会异步启动并在独立的线程中执行后者是任务会被推迟执行，直到调用-future-get-时，才会在当前线程中执行。"><a href="#std-launch-指定任务的执行策略，如-std-launch-async-或-std-launch-deferred。前者是任务会异步启动并在独立的线程中执行后者是任务会被推迟执行，直到调用-future-get-时，才会在当前线程中执行。" class="headerlink" title="std::launch 指定任务的执行策略，如 std::launch::async 或 std::launch::deferred。前者是任务会异步启动并在独立的线程中执行后者是任务会被推迟执行，直到调用 future.get() 时，才会在当前线程中执行。"></a>std::launch 指定任务的执行策略，如 std::launch::async 或 std::launch::deferred。前者是任务会异步启动并在独立的线程中执行后者是任务会被推迟执行，直到调用 future.get() 时，才会在当前线程中执行。</h3><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) -&gt; 返回类型 &#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><h3 id="：按值捕获外部变量"><a href="#：按值捕获外部变量" class="headerlink" title="[&#x3D;] ：按值捕获外部变量"></a>[&#x3D;] ：按值捕获外部变量</h3><h3 id="按引用捕获外部变量"><a href="#按引用捕获外部变量" class="headerlink" title="[&amp;] : 按引用捕获外部变量"></a>[&amp;] : 按引用捕获外部变量</h3></blockquote></blockquote><h3 id="在-CMakeLists-文件中添加相应语句"><a href="#在-CMakeLists-文件中添加相应语句" class="headerlink" title="在 CMakeLists 文件中添加相应语句"></a>在 CMakeLists 文件中添加相应语句</h3><blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(learn_thread src/learn_thread.cpp)</span><br><span class="line"><span class="comment"># 将节点拷贝到install</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS demo_one_node person_node learn_shared_ptr learn_lambda learn_functional learn_thread</span><br><span class="line">DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></blockquote><h3 id="在-chapter2-ws-目录下创建三个-txt-文件，并写入简单的内容，然后在该路径下运行本地服务器，并保持打开状态"><a href="#在-chapter2-ws-目录下创建三个-txt-文件，并写入简单的内容，然后在该路径下运行本地服务器，并保持打开状态" class="headerlink" title="在 chapter2_ws 目录下创建三个 txt 文件，并写入简单的内容，然后在该路径下运行本地服务器，并保持打开状态"></a>在 chapter2_ws 目录下创建三个 txt 文件，并写入简单的内容，然后在该路径下运行本地服务器，并保持打开状态</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;第一章 hello word&quot; &gt; novel1.txt</span><br><span class="line">echo &quot;第二章 hello guys&quot; &gt; novel2.txt</span><br><span class="line">echo &quot;第三章 hello girls&quot; &gt; novel3.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_13.png"></p></blockquote><h3 id="在同一路径下打开另外一个终端，编译并执行-learn-thread-节点"><a href="#在同一路径下打开另外一个终端，编译并执行-learn-thread-节点" class="headerlink" title="在同一路径下打开另外一个终端，编译并执行 learn_thread 节点"></a>在同一路径下打开另外一个终端，编译并执行 learn_thread 节点</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run demo_one_pkg learn_thread</span><br></pre></td></tr></table></figure><h3 id="执行后会得到如下输出"><a href="#执行后会得到如下输出" class="headerlink" title="执行后会得到如下输出"></a>执行后会得到如下输出</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_14.png"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六弹</title>
      <link href="/2025/02/17/07/"/>
      <url>/2025/02/17/07/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS2-中，cpp新特性的应用"><a href="#ROS2-中，cpp新特性的应用" class="headerlink" title="ROS2 中，cpp新特性的应用"></a>ROS2 中，cpp新特性的应用</h1><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auto 自动推导类型</span></span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">1</span>; <span class="comment">// int a = 1</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><blockquote><h3 id="智能指针分为三种"><a href="#智能指针分为三种" class="headerlink" title="智能指针分为三种"></a>智能指针分为三种</h3><ul><li><h4 id="shared-ptr-共享的智能指针"><a href="#shared-ptr-共享的智能指针" class="headerlink" title="shared_ptr 共享的智能指针"></a>shared_ptr 共享的智能指针</h4></li><li><h4 id="weak-ptr-弱引用的智能指针"><a href="#weak-ptr-弱引用的智能指针" class="headerlink" title="weak_ptr 弱引用的智能指针"></a>weak_ptr 弱引用的智能指针</h4></li><li><h4 id="unique-ptr-独占的智能指针"><a href="#unique-ptr-独占的智能指针" class="headerlink" title="unique_ptr 独占的智能指针"></a>unique_ptr 独占的智能指针</h4></li></ul><h3 id="std-shared-ptr-是一个类模板，它的对象的行为类似于指针，它可以记录共享它所管理的内存对象的对象个数。多个共享指针可以共享同一个对象，当最后一个共享指针被销毁时，会自动释放其所指向的对象。一个共享指针通常使用-make-shared-来创建，也可以通过拷贝或者赋值其他共享指针的方式创建。"><a href="#std-shared-ptr-是一个类模板，它的对象的行为类似于指针，它可以记录共享它所管理的内存对象的对象个数。多个共享指针可以共享同一个对象，当最后一个共享指针被销毁时，会自动释放其所指向的对象。一个共享指针通常使用-make-shared-来创建，也可以通过拷贝或者赋值其他共享指针的方式创建。" class="headerlink" title="std::shared_ptr 是一个类模板，它的对象的行为类似于指针，它可以记录共享它所管理的内存对象的对象个数。多个共享指针可以共享同一个对象，当最后一个共享指针被销毁时，会自动释放其所指向的对象。一个共享指针通常使用 make_shared&lt;&gt; 来创建，也可以通过拷贝或者赋值其他共享指针的方式创建。"></a>std::shared_ptr<T> 是一个类模板，它的对象的行为类似于指针，它可以记录共享它所管理的内存对象的对象个数。多个共享指针可以共享同一个对象，当最后一个共享指针被销毁时，会自动释放其所指向的对象。一个共享指针通常使用 make_shared&lt;&gt; 来创建，也可以通过拷贝或者赋值其他共享指针的方式创建。</h3><h3 id="代码示例，在-demo-one-pkg-src-下创建-learn-shared-ptr-cpp"><a href="#代码示例，在-demo-one-pkg-src-下创建-learn-shared-ptr-cpp" class="headerlink" title="代码示例，在 demo_one_pkg&#x2F;src&#x2F; 下创建 learn_shared_ptr.cpp"></a>代码示例，在 demo_one_pkg&#x2F;src&#x2F; 下创建 learn_shared_ptr.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建共享智能指针 &lt;数据类型/类&gt;(参数) 返回值，对应类的共享指针</span></span><br><span class="line"><span class="keyword">auto</span> p1 = std::<span class="built_in">make_shared</span>&lt;std::string&gt;(<span class="string">&quot;This is a string.&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p1的引用计数: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;, 指向内存地址: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p2 = p1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p1的引用计数: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;, 指向内存地址: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p2的引用计数: &quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;, 指向内存地址: &quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放引用</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p1的引用计数: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;, 指向内存地址: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p2的引用计数: &quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;, 指向内存地址: &quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2-&gt;c_str() 调用成员函数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p2的指向内存地址数据: &quot;</span> &lt;&lt; p2-&gt;<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-CMakeLists-文件中添加"><a href="#在-CMakeLists-文件中添加" class="headerlink" title="在 CMakeLists 文件中添加"></a>在 CMakeLists 文件中添加</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加可执行文件</span><br><span class="line">add_executable(learn_shared_ptr src/learn_shared_ptr.cpp)</span><br><span class="line"># 拷贝节点到install</span><br><span class="line">install(TARGETS demo_one_node person_node learn_shared_ptr</span><br><span class="line">DESTINATION lib/$&#123;PROJECT_NAME&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编译并执行"><a href="#编译并执行" class="headerlink" title="编译并执行"></a>编译并执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run demo_one_pkg learn_shared_ptr</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_9.png"></p></blockquote><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><blockquote><h3 id="可以利用它来编写内嵌的匿名函数，用以替换独立函数或函数对象。"><a href="#可以利用它来编写内嵌的匿名函数，用以替换独立函数或函数对象。" class="headerlink" title="可以利用它来编写内嵌的匿名函数，用以替换独立函数或函数对象。"></a>可以利用它来编写内嵌的匿名函数，用以替换独立函数或函数对象。</h3><h3 id="代码示例，在-demo-one-pkg-src-下创建-learn-lambda-cpp"><a href="#代码示例，在-demo-one-pkg-src-下创建-learn-lambda-cpp" class="headerlink" title="代码示例，在 demo_one_pkg&#x2F;src&#x2F; 下创建 learn_lambda.cpp"></a>代码示例，在 demo_one_pkg&#x2F;src&#x2F; 下创建 learn_lambda.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [] 是捕获参数列表，() 中放置参数，&#123;&#125; 中是函数体， -&gt; 后面是返回类型</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 这里的 [sum] 可以替换为 [&amp;]，后者可以捕获其之前的所有参数</span></span><br><span class="line"><span class="keyword">auto</span> print_sum = [sum]() -&gt; <span class="type">void</span> &#123;std::cout &lt;&lt; sum &lt;&lt; std::endl;&#125;;</span><br><span class="line"><span class="built_in">print_sum</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-CMakeLists-文件中添加-1"><a href="#在-CMakeLists-文件中添加-1" class="headerlink" title="在 CMakeLists 文件中添加"></a>在 CMakeLists 文件中添加</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加可执行文件</span><br><span class="line">add_executable(learn_lambda src/learn_lambda.cpp)</span><br><span class="line"># 拷贝节点到install</span><br><span class="line">install(TARGETS demo_one_node person_node learn_shared_ptr learn_lambda</span><br><span class="line">DESTINATION lib/$&#123;PROJECT_NAME&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编译并执行-1"><a href="#编译并执行-1" class="headerlink" title="编译并执行"></a>编译并执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run demo_one_pkg learn_lambda</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_10.png"></p></blockquote><h3 id="函数包装器"><a href="#函数包装器" class="headerlink" title="函数包装器"></a>函数包装器</h3><blockquote><h3 id="cpp-中函数可大致分为三类，一类是自由函数，一类是成员函数，另外一类就是-Lambda函数。三种函数的调用方式不同，自由函数直接函数名加参数调用，成员函数需要对象来调用。函数包装器就是用于统一这三种函数的调用方式的。"><a href="#cpp-中函数可大致分为三类，一类是自由函数，一类是成员函数，另外一类就是-Lambda函数。三种函数的调用方式不同，自由函数直接函数名加参数调用，成员函数需要对象来调用。函数包装器就是用于统一这三种函数的调用方式的。" class="headerlink" title="cpp 中函数可大致分为三类，一类是自由函数，一类是成员函数，另外一类就是 Lambda函数。三种函数的调用方式不同，自由函数直接函数名加参数调用，成员函数需要对象来调用。函数包装器就是用于统一这三种函数的调用方式的。"></a>cpp 中函数可大致分为三类，一类是自由函数，一类是成员函数，另外一类就是 Lambda函数。三种函数的调用方式不同，自由函数直接函数名加参数调用，成员函数需要对象来调用。函数包装器就是用于统一这三种函数的调用方式的。</h3><h3 id="代码示例，在-demo-one-pkg-src-下创建-learn-functional-cpp"><a href="#代码示例，在-demo-one-pkg-src-下创建-learn-functional-cpp" class="headerlink" title="代码示例，在 demo_one_pkg&#x2F;src&#x2F; 下创建 learn_functional.cpp"></a>代码示例，在 demo_one_pkg&#x2F;src&#x2F; 下创建 learn_functional.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span><span class="comment">// 函数包装器头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自由函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">save_with_free_fun</span><span class="params">(<span class="type">const</span> std::string &amp; file_name)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;自由函数: &quot;</span> &lt;&lt; file_name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSave</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FileSave</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">FileSave</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">save_with_member_fun</span><span class="params">(<span class="type">const</span> std::string &amp; file_name)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;成员函数: &quot;</span> &lt;&lt; file_name &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">FileSave file_save;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 函数</span></span><br><span class="line"><span class="keyword">auto</span> save_with_lambda_fun = [](<span class="type">const</span> std::string &amp; file_name) -&gt; <span class="type">void</span> &#123;std::cout &lt;&lt; <span class="string">&quot;Lambda 函数: &quot;</span> &lt;&lt; file_name &lt;&lt; std::endl;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未统一调用</span></span><br><span class="line"><span class="built_in">save_with_free_fun</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">file_save.<span class="built_in">save_with_member_fun</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="built_in">save_with_lambda_fun</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数包装器统一调用</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string&amp;)&gt;save1 = save_with_free_fun;</span><br><span class="line"><span class="comment">// 成员函数放入包装器较为复杂，涉及三个参数</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string&amp;)&gt;save2 = std::<span class="built_in">bind</span>(&amp;FileSave::save_with_member_fun, &amp;file_save, std::placeholders::_1);</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string&amp;)&gt;save3 = save_with_lambda_fun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">save1</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="built_in">save2</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="built_in">save3</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-CMakeLists-文件中添加-2"><a href="#在-CMakeLists-文件中添加-2" class="headerlink" title="在 CMakeLists 文件中添加"></a>在 CMakeLists 文件中添加</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加可执行文件</span><br><span class="line">add_executable(learn_functional src/learn_functional.cpp)</span><br><span class="line"># 拷贝节点到install</span><br><span class="line">install(TARGETS demo_one_node person_node learn_shared_ptr learn_lambda learn_functional</span><br><span class="line">DESTINATION lib/$&#123;PROJECT_NAME&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编译并执行-2"><a href="#编译并执行-2" class="headerlink" title="编译并执行"></a>编译并执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run demo_one_pkg learn_functional</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_11.png"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五弹</title>
      <link href="/2025/02/17/06/"/>
      <url>/2025/02/17/06/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS2基础：cpp面向对象编程"><a href="#ROS2基础：cpp面向对象编程" class="headerlink" title="ROS2基础：cpp面向对象编程"></a>ROS2基础：cpp面向对象编程</h1><h3 id="在-chapter2-ws-sec-demo-one-pkg-src-下创建一个-person-node-cpp"><a href="#在-chapter2-ws-sec-demo-one-pkg-src-下创建一个-person-node-cpp" class="headerlink" title="在 chapter2_ws&#x2F;sec&#x2F;demo_one_pkg&#x2F;src 下创建一个 person_node.cpp"></a>在 chapter2_ws&#x2F;sec&#x2F;demo_one_pkg&#x2F;src 下创建一个 person_node.cpp</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd chapter2_ws/src/demo_one_pkg/src</span><br><span class="line">touch person_node.cpp</span><br><span class="line">gedit person_node.cpp</span><br></pre></td></tr></table></figure></blockquote><h3 id="然后，编辑-person-node-cpp-的内容"><a href="#然后，编辑-person-node-cpp-的内容" class="headerlink" title="然后，编辑 person_node.cpp 的内容"></a>然后，编辑 person_node.cpp 的内容</h3><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类，使其继承 Node</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonNode</span> : <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string name_;</span><br><span class="line"><span class="type">int</span> age_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数,调用父类的构造函数,属性初始化</span></span><br><span class="line"><span class="built_in">PersonNode</span>(<span class="type">const</span> std::string &amp;node_name, <span class="type">const</span> std::string &amp;name, <span class="type">const</span> <span class="type">int</span> &amp;age):<span class="built_in">Node</span>(node_name)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name_ = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;age_ = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> std::string &amp;food_name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这里用的是 C 的格式化输出，故需要将 name_ 转换为 C 风格的字符串</span></span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;I&#x27;m %s, %d years old and love eatting %s&quot;</span>, <span class="keyword">this</span>-&gt;name_.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;age_, food_name.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line"><span class="comment">// 这里的 make_shared 需要修改为 PersonNode 类型,传入的参数个数和形式必须与上面的PersonNode的一致</span></span><br><span class="line"><span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;PersonNode&gt;(<span class="string">&quot;person_node&quot;</span>,<span class="string">&quot;Peter&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(node-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果上面的 make_shared 不修改为 PersonNode 类型，那么这里无法调用其公共函数</span></span><br><span class="line">node-&gt;<span class="built_in">eat</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="修改-demo-one-pkg-的-CmakeLists-文件"><a href="#修改-demo-one-pkg-的-CmakeLists-文件" class="headerlink" title="修改 demo_one_pkg 的 CmakeLists 文件"></a>修改 demo_one_pkg 的 CmakeLists 文件</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加可执行文件</span></span><br><span class="line">add_executable(demo_one_node src/demo_one.cpp)</span><br><span class="line">add_executable(person_node src/person_node.cpp)# 添加这句</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加依赖</span></span><br><span class="line">ament_target_dependencies(demo_one_node rclcpp)</span><br><span class="line">ament_target_dependencies(person_node rclcpp)# 添加这句</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝节点到 install</span></span><br><span class="line">install(TARGETS demo_one_node person_node</span><br><span class="line">DESTINATION lib/$&#123;PROJECT_NAME&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></blockquote><h3 id="重新编译并执行"><a href="#重新编译并执行" class="headerlink" title="重新编译并执行"></a>重新编译并执行</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ./learn_ros2/chapter_2/chapter2_ws/</span><br><span class="line">colcon build</span><br><span class="line">ros2 run demo_one_pkg person_node</span><br></pre></td></tr></table></figure><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_8.png"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四弹</title>
      <link href="/2025/01/03/05/"/>
      <url>/2025/01/03/05/</url>
      
        <content type="html"><![CDATA[<h1 id="使用功能包组织cpp节点"><a href="#使用功能包组织cpp节点" class="headerlink" title="使用功能包组织cpp节点"></a>使用功能包组织cpp节点</h1><blockquote><h3 id="创建一个功能包，这里所在的目录是-learn-ros2-chapter-2"><a href="#创建一个功能包，这里所在的目录是-learn-ros2-chapter-2" class="headerlink" title="创建一个功能包，这里所在的目录是  ~&#x2F;learn_ros2&#x2F;chapter_2&#x2F;"></a>创建一个功能包，这里所在的目录是  ~&#x2F;learn_ros2&#x2F;chapter_2&#x2F;</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create demo_one_pkg --build-type ament_cmake --license Apache-2.0</span><br></pre></td></tr></table></figure><h3 id="创建好之后显示以下信息，"><a href="#创建好之后显示以下信息，" class="headerlink" title="创建好之后显示以下信息，"></a>创建好之后显示以下信息，</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_5.png"></p><h3 id="目录结构如下，include-demo-one-pkg-文件用于存放编写的头文件-库文件"><a href="#目录结构如下，include-demo-one-pkg-文件用于存放编写的头文件-库文件" class="headerlink" title="目录结构如下，include&#x2F;demo_one_pkg 文件用于存放编写的头文件&#x2F;库文件"></a>目录结构如下，include&#x2F;demo_one_pkg 文件用于存放编写的头文件&#x2F;库文件</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_6.png"></p><h3 id="创建好包之后，进入-demo-one-pkg-src-目录下，创建一个-cpp-文件，这里叫-demo-one-cpp，内容如下，"><a href="#创建好包之后，进入-demo-one-pkg-src-目录下，创建一个-cpp-文件，这里叫-demo-one-cpp，内容如下，" class="headerlink" title="创建好包之后，进入 demo_one_pkg&#x2F;src&#x2F; 目录下，创建一个 .cpp 文件，这里叫 demo_one.cpp，内容如下，"></a>创建好包之后，进入 demo_one_pkg&#x2F;src&#x2F; 目录下，创建一个 .cpp 文件，这里叫 demo_one.cpp，内容如下，</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化参数</span></span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;rclcpp::Node&gt;(<span class="string">&quot;demo_one_node&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(node-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// 运行节点</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    <span class="comment">// 关闭节点</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回上一级目录，即-demo-one-pkg-，编辑-CMakeLists-txt"><a href="#返回上一级目录，即-demo-one-pkg-，编辑-CMakeLists-txt" class="headerlink" title="返回上一级目录，即 demo_one_pkg&#x2F;，编辑 CMakeLists.txt"></a>返回上一级目录，即 demo_one_pkg&#x2F;，编辑 CMakeLists.txt</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.8)</span><br><span class="line">project(demo_one_pkg)</span><br><span class="line"></span><br><span class="line">if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES &quot;Clang&quot;)</span><br><span class="line">  add_compile_options(-Wall -Wextra -Wpedantic)</span><br><span class="line">endif()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到依赖</span></span><br><span class="line">find_package(ament_cmake REQUIRED)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.查找 rclcpp 的头文件和库文件</span></span><br><span class="line">find_package(rclcpp REQUIRED)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment the following section <span class="keyword">in</span> order to fill <span class="keyword">in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">further dependencies manually.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find_package(&lt;dependency&gt; REQUIRED)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.添加可执行文件，(节点名，源文件地址)</span></span><br><span class="line">add_executable(demo_one_node src/demo_one.cpp)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">头文件包含</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target_inlude_directories(demo_one_node PUBLIC <span class="variable">$&#123;rclcpp_INCLUDE_DIRS&#125;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">库文件链接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target_link_libraries(demo_one_node <span class="variable">$&#123;rclcpp_LIBRARIES&#125;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面两句用这一句代替,他是依赖于 find_package(ament_cmake REQUIRED) 的</span></span><br><span class="line">ament_target_dependencies(demo_one_node rclcpp)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 demo_one_node 拷贝到 install目录下</span></span><br><span class="line">install(TARGETS demo_one_node# 这里执行后目录就已经是 install/demo_one_pkg/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝到 install/pkg_name/lib/pkg_name/ 下</span></span><br><span class="line">DESTINATION lib/$&#123;PROJECT_NAME&#125;# 这里执行后最后目录就是 install/demo_one_pkg/lib/demo_one_pkg/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if(BUILD_TESTING)</span><br><span class="line">  find_package(ament_lint_auto REQUIRED)</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">the following line skips the linter <span class="built_in">which</span> checks <span class="keyword">for</span> copyrights</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">comment the line when a copyright and license is added to all <span class="built_in">source</span> files</span></span><br><span class="line">  set(ament_cmake_copyright_FOUND TRUE)</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">the following line skips cpplint (only works <span class="keyword">in</span> a git repo)</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">comment the line when this package is <span class="keyword">in</span> a git repo and when</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">a copyright and license is added to all <span class="built_in">source</span> files</span></span><br><span class="line">  set(ament_cmake_cpplint_FOUND TRUE)</span><br><span class="line">  ament_lint_auto_find_test_dependencies()</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">ament_package()</span><br></pre></td></tr></table></figure><h3 id="在与-CMakeLists-txt-同级目录下还有一个-package-xml-文件，在该文件中也要对引用的头文件进行声明"><a href="#在与-CMakeLists-txt-同级目录下还有一个-package-xml-文件，在该文件中也要对引用的头文件进行声明" class="headerlink" title="在与 CMakeLists.txt 同级目录下还有一个 package.xml 文件，在该文件中也要对引用的头文件进行声明"></a>在与 CMakeLists.txt 同级目录下还有一个 package.xml 文件，在该文件中也要对引用的头文件进行声明</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-model href=<span class="string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo_one_pkg<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;yanzu@todo.todo&quot;</span>&gt;</span>yanzu<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>Apache-2.0<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 在这里添加头文件的声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_auto<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_common<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build_type</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">build_type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="然后就可以对包进行编译了，编译时必须要在包的上一路径打开终端进行编译"><a href="#然后就可以对包进行编译了，编译时必须要在包的上一路径打开终端进行编译" class="headerlink" title="然后就可以对包进行编译了，编译时必须要在包的上一路径打开终端进行编译"></a>然后就可以对包进行编译了，编译时必须要在包的上一路径打开终端进行编译</h3><h3 id="在正式编译之前，可以在包目录下创建一个-build-文件先测试一下编译能否通过，创建这个build的目的是为了存放编译生成的文件"><a href="#在正式编译之前，可以在包目录下创建一个-build-文件先测试一下编译能否通过，创建这个build的目的是为了存放编译生成的文件" class="headerlink" title="在正式编译之前，可以在包目录下创建一个 build 文件先测试一下编译能否通过，创建这个build的目的是为了存放编译生成的文件"></a>在正式编译之前，可以在包目录下创建一个 build 文件先测试一下编译能否通过，创建这个build的目的是为了存放编译生成的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build/</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="因为-CMakeLists-txt-在上一级目录中，要使其转换为-makefile-，所以是-cmake"><a href="#因为-CMakeLists-txt-在上一级目录中，要使其转换为-makefile-，所以是-cmake" class="headerlink" title="因为 CMakeLists.txt 在上一级目录中，要使其转换为 makefile ，所以是 cmake ..&#x2F;"></a>因为 CMakeLists.txt 在上一级目录中，要使其转换为 makefile ，所以是 cmake ..&#x2F;</h3><h3 id="这里在-demo-one-pkg-的上一路径下进行编译，也即-chapter-2-路径下进行编译"><a href="#这里在-demo-one-pkg-的上一路径下进行编译，也即-chapter-2-路径下进行编译" class="headerlink" title="这里在 demo_one_pkg 的上一路径下进行编译，也即 chapter_2&#x2F; 路径下进行编译"></a>这里在 demo_one_pkg 的上一路径下进行编译，也即 chapter_2&#x2F; 路径下进行编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">colcon build</span><br></pre></td></tr></table></figure><h3 id="编译成功后，显示如下信息"><a href="#编译成功后，显示如下信息" class="headerlink" title="编译成功后，显示如下信息"></a>编译成功后，显示如下信息</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_7.png"></p><h3 id="此时，chapter-2-路径下分别有这些文件，build、install、log、demo-one-pkg"><a href="#此时，chapter-2-路径下分别有这些文件，build、install、log、demo-one-pkg" class="headerlink" title="此时，chapter_2&#x2F; 路径下分别有这些文件，build、install、log、demo_one_pkg"></a>此时，chapter_2&#x2F; 路径下分别有这些文件，build、install、log、demo_one_pkg</h3><h3 id="生成的可执行文件-demo-one-node-在-build-pkg-name-下，在该路径下，执行以下命令，可以查看当前节点依赖了哪些库，是否链接上"><a href="#生成的可执行文件-demo-one-node-在-build-pkg-name-下，在该路径下，执行以下命令，可以查看当前节点依赖了哪些库，是否链接上" class="headerlink" title="生成的可执行文件 demo_one_node 在 build&#x2F;pkg_name&#x2F; 下，在该路径下，执行以下命令，可以查看当前节点依赖了哪些库，是否链接上"></a>生成的可执行文件 demo_one_node 在 build&#x2F;pkg_name&#x2F; 下，在该路径下，执行以下命令，可以查看当前节点依赖了哪些库，是否链接上</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd demo_one_node</span><br></pre></td></tr></table></figure><h3 id="正式运行节点之前要添加环境变量，可以使用以下命令查看当前包的环境变量是否配置了，未配置直接运行节点会显示找不到当前的包-以下命令都是在-chapter-2-路径下执行"><a href="#正式运行节点之前要添加环境变量，可以使用以下命令查看当前包的环境变量是否配置了，未配置直接运行节点会显示找不到当前的包-以下命令都是在-chapter-2-路径下执行" class="headerlink" title="正式运行节点之前要添加环境变量，可以使用以下命令查看当前包的环境变量是否配置了，未配置直接运行节点会显示找不到当前的包(以下命令都是在 chapter_2&#x2F; 路径下执行)"></a>正式运行节点之前要添加环境变量，可以使用以下命令查看当前包的环境变量是否配置了，未配置直接运行节点会显示找不到当前的包(以下命令都是在 chapter_2&#x2F; 路径下执行)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printenv | grep AMENT</span><br></pre></td></tr></table></figure><h3 id="使用以下命令进行环境变量配置"><a href="#使用以下命令进行环境变量配置" class="headerlink" title="使用以下命令进行环境变量配置"></a>使用以下命令进行环境变量配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash</span><br></pre></td></tr></table></figure><h3 id="再使用上面查看环境变量的命令看看是否配置成功，最后运行节点（ros2-run-pkg-name-node-name）"><a href="#再使用上面查看环境变量的命令看看是否配置成功，最后运行节点（ros2-run-pkg-name-node-name）" class="headerlink" title="再使用上面查看环境变量的命令看看是否配置成功，最后运行节点（ros2 run pkg_name node_name）"></a>再使用上面查看环境变量的命令看看是否配置成功，最后运行节点（ros2 run pkg_name node_name）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run demo_one_pkg demo_one_node</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下安装与激活Typora</title>
      <link href="/2025/01/02/04/"/>
      <url>/2025/01/02/04/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu下安装与激活Typora"><a href="#Ubuntu下安装与激活Typora" class="headerlink" title="Ubuntu下安装与激活Typora"></a>Ubuntu下安装与激活Typora</h1><h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h2><h3 id="直接在官网下载最新版-https-typora-io-releases-all"><a href="#直接在官网下载最新版-https-typora-io-releases-all" class="headerlink" title="直接在官网下载最新版 https://typora.io/releases/all"></a>直接在官网下载最新版 <a href="https://typora.io/releases/all">https://typora.io/releases/all</a></h3><h3 id="下载好-deb-之后，安装"><a href="#下载好-deb-之后，安装" class="headerlink" title="下载好 deb 之后，安装"></a>下载好 deb 之后，安装</h3><blockquote><h3 id="sudo-dpkg-i-xxx-deb"><a href="#sudo-dpkg-i-xxx-deb" class="headerlink" title="sudo dpkg -i xxx.deb"></a>sudo dpkg -i xxx.deb</h3></blockquote><h2 id="2-激活"><a href="#2-激活" class="headerlink" title="2.激活"></a>2.激活</h2><h3 id="在home下打开终端，依次执行以下命令"><a href="#在home下打开终端，依次执行以下命令" class="headerlink" title="在home下打开终端，依次执行以下命令"></a>在home下打开终端，依次执行以下命令</h3><blockquote><h3 id="git-clone-https-github-com-hazukieq-Yporaject-git"><a href="#git-clone-https-github-com-hazukieq-Yporaject-git" class="headerlink" title="git clone https://github.com/hazukieq/Yporaject.git"></a>git clone <a href="https://github.com/hazukieq/Yporaject.git">https://github.com/hazukieq/Yporaject.git</a></h3><h3 id="sudo-apt-install-cargo"><a href="#sudo-apt-install-cargo" class="headerlink" title="sudo apt install cargo"></a>sudo apt install cargo</h3><h3 id="cd-Yporaject"><a href="#cd-Yporaject" class="headerlink" title="cd Yporaject&#x2F;"></a>cd Yporaject&#x2F;</h3><h3 id="这一步最好打开梯子"><a href="#这一步最好打开梯子" class="headerlink" title="# 这一步最好打开梯子"></a># 这一步最好打开梯子</h3><h3 id="cargo-build"><a href="#cargo-build" class="headerlink" title="cargo build"></a>cargo build</h3><h3 id="最后显示-finished-就说明成功了"><a href="#最后显示-finished-就说明成功了" class="headerlink" title="最后显示 finished 就说明成功了"></a>最后显示 finished 就说明成功了</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_4.png"></p><h3 id="ls一下，看看有没有出现可执行文件-node-inject"><a href="#ls一下，看看有没有出现可执行文件-node-inject" class="headerlink" title="# ls一下，看看有没有出现可执行文件 node_inject"></a># ls一下，看看有没有出现可执行文件 node_inject</h3><h3 id="ls-target-debug"><a href="#ls-target-debug" class="headerlink" title="ls target&#x2F;debug"></a>ls target&#x2F;debug</h3><h3 id="cargo-run"><a href="#cargo-run" class="headerlink" title="cargo run"></a>cargo run</h3><h3 id="sudo-cp-target-debug-node-inject-usr-share-typora"><a href="#sudo-cp-target-debug-node-inject-usr-share-typora" class="headerlink" title="sudo cp target&#x2F;debug&#x2F;node_inject &#x2F;usr&#x2F;share&#x2F;typora"></a>sudo cp target&#x2F;debug&#x2F;node_inject &#x2F;usr&#x2F;share&#x2F;typora</h3><h3 id="上面的终端不要关闭"><a href="#上面的终端不要关闭" class="headerlink" title="上面的终端不要关闭"></a>上面的终端不要关闭</h3></blockquote><h3 id="在-home-下打开新的终端，依次执行一下命令，"><a href="#在-home-下打开新的终端，依次执行一下命令，" class="headerlink" title="在 home 下打开新的终端，依次执行一下命令，"></a>在 home 下打开新的终端，依次执行一下命令，</h3><blockquote><h3 id="cd-usr-share-typora"><a href="#cd-usr-share-typora" class="headerlink" title="cd &#x2F;usr&#x2F;share&#x2F;typora&#x2F;"></a>cd &#x2F;usr&#x2F;share&#x2F;typora&#x2F;</h3><h3 id="权限拉闷"><a href="#权限拉闷" class="headerlink" title="# 权限拉闷"></a># 权限拉闷</h3><h3 id="sudo-chmod-777-node-inject"><a href="#sudo-chmod-777-node-inject" class="headerlink" title="sudo chmod 777 node_inject"></a>sudo chmod 777 node_inject</h3><h3 id="sudo-node-inject"><a href="#sudo-node-inject" class="headerlink" title="sudo .&#x2F;node_inject"></a>sudo .&#x2F;node_inject</h3><h3 id="终端输出了以下信息就说明可以了"><a href="#终端输出了以下信息就说明可以了" class="headerlink" title="# 终端输出了以下信息就说明可以了"></a># 终端输出了以下信息就说明可以了</h3><h3 id="extracting-node-modules-asar"><a href="#extracting-node-modules-asar" class="headerlink" title="extracting node_modules.asar"></a>extracting node_modules.asar</h3><h3 id="adding-hook-js"><a href="#adding-hook-js" class="headerlink" title="adding hook.js"></a>adding hook.js</h3><h3 id="applying-patch"><a href="#applying-patch" class="headerlink" title="applying patch"></a>applying patch</h3><h3 id="packing-node-modules-asar"><a href="#packing-node-modules-asar" class="headerlink" title="packing node_modules.asar"></a>packing node_modules.asar</h3><h3 id="done"><a href="#done" class="headerlink" title="done!"></a>done!</h3><h3 id="可以关掉这个终端了"><a href="#可以关掉这个终端了" class="headerlink" title="可以关掉这个终端了"></a>可以关掉这个终端了</h3></blockquote><h3 id="返回之前的终端，依次执行以下命令，"><a href="#返回之前的终端，依次执行以下命令，" class="headerlink" title="返回之前的终端，依次执行以下命令，"></a>返回之前的终端，依次执行以下命令，</h3><blockquote><h3 id="cd-license-gen"><a href="#cd-license-gen" class="headerlink" title="cd license-gen&#x2F;"></a>cd license-gen&#x2F;</h3><h3 id="这一步同样打开梯子进行"><a href="#这一步同样打开梯子进行" class="headerlink" title="# 这一步同样打开梯子进行"></a># 这一步同样打开梯子进行</h3><h3 id="cargo-build-1"><a href="#cargo-build-1" class="headerlink" title="cargo build"></a>cargo build</h3><h3 id="cargo-run-1"><a href="#cargo-run-1" class="headerlink" title="cargo run"></a>cargo run</h3><h3 id="然后就得到了激活码了"><a href="#然后就得到了激活码了" class="headerlink" title="然后就得到了激活码了"></a>然后就得到了激活码了</h3></blockquote><h3 id="这个激活教程真的太6了，当然不是我自己原创，在“垃圾堆”里面找到的，原作者也不知道是不是他，贴一手地址，"><a href="#这个激活教程真的太6了，当然不是我自己原创，在“垃圾堆”里面找到的，原作者也不知道是不是他，贴一手地址，" class="headerlink" title="这个激活教程真的太6了，当然不是我自己原创，在“垃圾堆”里面找到的，原作者也不知道是不是他，贴一手地址，"></a>这个激活教程真的太6了，当然不是我自己原创，在“垃圾堆”里面找到的，原作者也不知道是不是他，贴一手地址，</h3><h3 id="https-blog-csdn-net-weixin-65657501-article-details-142788747"><a href="#https-blog-csdn-net-weixin-65657501-article-details-142788747" class="headerlink" title="https://blog.csdn.net/weixin_65657501/article/details/142788747"></a><a href="https://blog.csdn.net/weixin_65657501/article/details/142788747">https://blog.csdn.net/weixin_65657501/article/details/142788747</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三弹</title>
      <link href="/2025/01/01/03/"/>
      <url>/2025/01/01/03/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-CMakeLists-管理-cpp"><a href="#使用-CMakeLists-管理-cpp" class="headerlink" title="使用 CMakeLists 管理 cpp"></a>使用 CMakeLists 管理 cpp</h1><h3 id="在当前目录下创建一个-cpp-文件，如-hello-cpp，内容就是输出-hello-world"><a href="#在当前目录下创建一个-cpp-文件，如-hello-cpp，内容就是输出-hello-world" class="headerlink" title="在当前目录下创建一个 cpp 文件，如 hello.cpp，内容就是输出 hello world"></a>在当前目录下创建一个 cpp 文件，如 hello.cpp，内容就是输出 hello world</h3><h3 id="再创建一个-CMakeLists-txt-的文件，内容如下"><a href="#再创建一个-CMakeLists-txt-的文件，内容如下" class="headerlink" title="再创建一个 CMakeLists.txt 的文件，内容如下:"></a>再创建一个 CMakeLists.txt 的文件，内容如下:</h3><blockquote><h3 id="指定-cmake-的最小版本"><a href="#指定-cmake-的最小版本" class="headerlink" title="# 指定 cmake 的最小版本"></a># 指定 cmake 的最小版本</h3><h3 id="cmake-minimum-required-VERSION-3-8"><a href="#cmake-minimum-required-VERSION-3-8" class="headerlink" title="cmake_minimum_required(VERSION 3.8)"></a>cmake_minimum_required(VERSION 3.8)</h3><h3 id="项目名称"><a href="#项目名称" class="headerlink" title="# 项目名称"></a># 项目名称</h3><h3 id="project-hello"><a href="#project-hello" class="headerlink" title="project(hello)"></a>project(hello)</h3><h3 id="添加可执行文件，-可执行文件名，源文件名"><a href="#添加可执行文件，-可执行文件名，源文件名" class="headerlink" title="# 添加可执行文件，(可执行文件名，源文件名)"></a># 添加可执行文件，(可执行文件名，源文件名)</h3><h3 id="add-executable-learn-cmake-hello-cpp"><a href="#add-executable-learn-cmake-hello-cpp" class="headerlink" title="add_executable(learn_cmake hello.cpp)"></a>add_executable(learn_cmake hello.cpp)</h3></blockquote><h3 id="然后执行命令-当前路径下打开命令框-，将-cmake-转换为-makefile"><a href="#然后执行命令-当前路径下打开命令框-，将-cmake-转换为-makefile" class="headerlink" title="然后执行命令(当前路径下打开命令框)，将 cmake 转换为 makefile"></a>然后执行命令(当前路径下打开命令框)，将 cmake 转换为 makefile</h3><blockquote><h3 id="cmake-后面跟的是目录"><a href="#cmake-后面跟的是目录" class="headerlink" title="# cmake 后面跟的是目录"></a># cmake 后面跟的是目录</h3><h3 id="cmake"><a href="#cmake" class="headerlink" title="$ cmake ."></a>$ cmake .</h3></blockquote><h3 id="再执行命令，编译生成可执行文件"><a href="#再执行命令，编译生成可执行文件" class="headerlink" title="再执行命令，编译生成可执行文件"></a>再执行命令，编译生成可执行文件</h3><blockquote><h3 id="make"><a href="#make" class="headerlink" title="$ make"></a>$ make</h3></blockquote><h3 id="此时就生成了可执行文件-learn-cmake-了，可以直接运行"><a href="#此时就生成了可执行文件-learn-cmake-了，可以直接运行" class="headerlink" title="此时就生成了可执行文件 learn_cmake 了，可以直接运行"></a>此时就生成了可执行文件 learn_cmake 了，可以直接运行</h3><blockquote><h3 id="learn-cmake"><a href="#learn-cmake" class="headerlink" title="$ .&#x2F;learn_cmake"></a>$ .&#x2F;learn_cmake</h3></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二弹</title>
      <link href="/2025/01/01/02/"/>
      <url>/2025/01/01/02/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的-Linux-操作命令"><a href="#常用的-Linux-操作命令" class="headerlink" title="常用的 Linux 操作命令"></a>常用的 Linux 操作命令</h1><h3 id="当前终端所在目录"><a href="#当前终端所在目录" class="headerlink" title="当前终端所在目录"></a>当前终端所在目录</h3><blockquote><h3 id="pwd"><a href="#pwd" class="headerlink" title="$ pwd"></a>$ pwd</h3></blockquote><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><blockquote><h3 id="cat-name-txt"><a href="#cat-name-txt" class="headerlink" title="$ cat name.txt"></a>$ cat name.txt</h3></blockquote><h3 id="卸载某个包"><a href="#卸载某个包" class="headerlink" title="卸载某个包"></a>卸载某个包</h3><blockquote><h3 id="sudo-apt-remove-pkg-name"><a href="#sudo-apt-remove-pkg-name" class="headerlink" title="$ sudo apt remove pkg_name"></a>$ sudo apt remove pkg_name</h3></blockquote><h3 id="安装-deb"><a href="#安装-deb" class="headerlink" title="安装 .deb"></a>安装 .deb</h3><blockquote><h3 id="sudo-dpkg-i-file-name-deb"><a href="#sudo-dpkg-i-file-name-deb" class="headerlink" title="$ sudo dpkg -i file_name.deb"></a>$ sudo dpkg -i file_name.deb</h3></blockquote><h3 id="解压-tar-gz-tgz"><a href="#解压-tar-gz-tgz" class="headerlink" title="解压 .tar.gz&#x2F;.tgz"></a>解压 .tar.gz&#x2F;.tgz</h3><blockquote><h3 id="tar-xzvf-file-tar-gz-C-path"><a href="#tar-xzvf-file-tar-gz-C-path" class="headerlink" title="$ tar -xzvf file.tar.gz -C &#x2F;path"></a>$ tar -xzvf file.tar.gz -C &#x2F;path</h3></blockquote><h3 id="解压-zip"><a href="#解压-zip" class="headerlink" title="解压 .zip"></a>解压 .zip</h3><blockquote><h3 id="unzip-file-zip-d-path"><a href="#unzip-file-zip-d-path" class="headerlink" title="$ unzip file.zip -d &#x2F;path"></a>$ unzip file.zip -d &#x2F;path</h3></blockquote><h3 id="解压-rar"><a href="#解压-rar" class="headerlink" title="解压 .rar"></a>解压 .rar</h3><blockquote><h3 id="unrar-x-file-rar"><a href="#unrar-x-file-rar" class="headerlink" title="$ unrar x file.rar"></a>$ unrar x file.rar</h3></blockquote><h3 id="查找某个文件"><a href="#查找某个文件" class="headerlink" title="查找某个文件"></a>查找某个文件</h3><blockquote><h3 id="whereis-file-name"><a href="#whereis-file-name" class="headerlink" title="$ whereis file_name"></a>$ whereis file_name</h3></blockquote><h3 id="使用-nano-编辑文本"><a href="#使用-nano-编辑文本" class="headerlink" title="使用 nano 编辑文本"></a>使用 nano 编辑文本</h3><blockquote><h3 id="nano-file-name"><a href="#nano-file-name" class="headerlink" title="$ nano file_name"></a>$ nano file_name</h3></blockquote><h3 id="查看执行过的命令"><a href="#查看执行过的命令" class="headerlink" title="查看执行过的命令"></a>查看执行过的命令</h3><blockquote><h3 id="history"><a href="#history" class="headerlink" title="$ history"></a>$ history</h3></blockquote><h3 id="终端中的复制粘贴快捷键"><a href="#终端中的复制粘贴快捷键" class="headerlink" title="终端中的复制粘贴快捷键"></a>终端中的复制粘贴快捷键</h3><blockquote><h3 id="ctrl-shift-C-ctrl-shift-V"><a href="#ctrl-shift-C-ctrl-shift-V" class="headerlink" title="ctrl + shift + C &#x2F; ctrl + shift + V"></a>ctrl + shift + C &#x2F; ctrl + shift + V</h3></blockquote><h3 id="终端中执行-py"><a href="#终端中执行-py" class="headerlink" title="终端中执行 .py"></a>终端中执行 .py</h3><blockquote><h3 id="python3-file-name-py"><a href="#python3-file-name-py" class="headerlink" title="$ python3 file_name.py"></a>$ python3 file_name.py</h3></blockquote><h3 id="给文件添加权限，文件或者目录的权限分为三类，权限也分为三类"><a href="#给文件添加权限，文件或者目录的权限分为三类，权限也分为三类" class="headerlink" title="给文件添加权限，文件或者目录的权限分为三类，权限也分为三类"></a>给文件添加权限，文件或者目录的权限分为三类，权限也分为三类</h3><blockquote><h4 id="1-用户-user-u-：文件拥有者"><a href="#1-用户-user-u-：文件拥有者" class="headerlink" title="1.用户(user,u)：文件拥有者"></a>1.用户(user,u)：文件拥有者</h4><h4 id="2-组-group-g-：与user在同一组的用户"><a href="#2-组-group-g-：与user在同一组的用户" class="headerlink" title="2.组(group,g)：与user在同一组的用户"></a>2.组(group,g)：与user在同一组的用户</h4><h4 id="3-其他人-others-o-：所有其他用户"><a href="#3-其他人-others-o-：所有其他用户" class="headerlink" title="3.其他人(others,o)：所有其他用户"></a>3.其他人(others,o)：所有其他用户</h4><h4 id="读，r，值为-4-；写，w，值为-2-；执行，x，值为-1"><a href="#读，r，值为-4-；写，w，值为-2-；执行，x，值为-1" class="headerlink" title="读，r，值为 4 ；写，w，值为 2 ；执行，x，值为 1"></a>读，r，值为 4 ；写，w，值为 2 ；执行，x，值为 1</h4></blockquote><h3 id="赋予所有用户执行权，添加权限就是-，移除权限就是"><a href="#赋予所有用户执行权，添加权限就是-，移除权限就是" class="headerlink" title="赋予所有用户执行权，添加权限就是 + ，移除权限就是 -"></a>赋予所有用户执行权，添加权限就是 + ，移除权限就是 -</h3><blockquote><h3 id="chmod-a-x-file"><a href="#chmod-a-x-file" class="headerlink" title="$ chmod a+x file"></a>$ chmod a+x file</h3></blockquote><h3 id="查看文件-目录权限"><a href="#查看文件-目录权限" class="headerlink" title="查看文件&#x2F;目录权限"></a>查看文件&#x2F;目录权限</h3><blockquote><h3 id="ls-l-file"><a href="#ls-l-file" class="headerlink" title="$ ls -l file"></a>$ ls -l file</h3></blockquote><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_3.png" alt="pic"></p><h3 id="要在命令框中直接执行-py-文件，不使用-python3-file-py，要指定编译器，在-py-文件顶部添加"><a href="#要在命令框中直接执行-py-文件，不使用-python3-file-py，要指定编译器，在-py-文件顶部添加" class="headerlink" title="要在命令框中直接执行 .py 文件，不使用 python3 file.py，要指定编译器，在 .py 文件顶部添加"></a>要在命令框中直接执行 .py 文件，不使用 python3 file.py，要指定编译器，在 .py 文件顶部添加</h3><blockquote><h3 id="usr-bin-python3"><a href="#usr-bin-python3" class="headerlink" title="#!usr&#x2F;bin&#x2F;python3"></a>#!usr&#x2F;bin&#x2F;python3</h3><h3 id="然后就可以使用"><a href="#然后就可以使用" class="headerlink" title="然后就可以使用"></a>然后就可以使用</h3><h3 id="file-py"><a href="#file-py" class="headerlink" title="$ .&#x2F;file.py"></a>$ .&#x2F;file.py</h3></blockquote><h3 id="echo-指令的使用，echo-本身的功能就是打印其后的字符"><a href="#echo-指令的使用，echo-本身的功能就是打印其后的字符" class="headerlink" title="echo 指令的使用，echo 本身的功能就是打印其后的字符"></a>echo 指令的使用，echo 本身的功能就是打印其后的字符</h3><blockquote><h3 id="可以找到跟在其后的字符的环境变量，echo-就能打印该环境变量"><a href="#可以找到跟在其后的字符的环境变量，echo-就能打印该环境变量" class="headerlink" title="$ 可以找到跟在其后的字符的环境变量，echo 就能打印该环境变量"></a>$ 可以找到跟在其后的字符的环境变量，echo 就能打印该环境变量</h3><h3 id="echo-ROS-VERSION"><a href="#echo-ROS-VERSION" class="headerlink" title="$ echo $ROS_VERSION"></a>$ echo $ROS_VERSION</h3><h3 id="查看-ros-的发行版本"><a href="#查看-ros-的发行版本" class="headerlink" title="# 查看 ros 的发行版本"></a># 查看 ros 的发行版本</h3><h3 id="echo-ROS-DISTRO"><a href="#echo-ROS-DISTRO" class="headerlink" title="$ echo $ROS_DISTRO"></a>$ echo $ROS_DISTRO</h3></blockquote><h3 id="查看所有环境变量列表"><a href="#查看所有环境变量列表" class="headerlink" title="查看所有环境变量列表"></a>查看所有环境变量列表</h3><blockquote><h3 id="printenv"><a href="#printenv" class="headerlink" title="$ printenv"></a>$ printenv</h3></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一弹</title>
      <link href="/2024/12/04/01/"/>
      <url>/2024/12/04/01/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS2-的安装"><a href="#ROS2-的安装" class="headerlink" title="ROS2 的安装"></a>ROS2 的安装</h1><h3 id="鱼香ROS安装命令"><a href="#鱼香ROS安装命令" class="headerlink" title="鱼香ROS安装命令"></a>鱼香ROS安装命令</h3><blockquote><h3 id="wget-http-fishros-com-install-O-fishros-bash-fishros"><a href="#wget-http-fishros-com-install-O-fishros-bash-fishros" class="headerlink" title="$ wget http://fishros.com/install -O fishros &amp;&amp; bash fishros"></a>$ wget <a href="http://fishros.com/install">http://fishros.com/install</a> -O fishros &amp;&amp; bash fishros</h3></blockquote><h3 id="安装成功后可使用以下命令查看"><a href="#安装成功后可使用以下命令查看" class="headerlink" title="安装成功后可使用以下命令查看"></a>安装成功后可使用以下命令查看</h3><blockquote><h3 id="ros2"><a href="#ros2" class="headerlink" title="$ ros2"></a>$ ros2</h3></blockquote><h3 id="测试安装是否成功，运行小海龟"><a href="#测试安装是否成功，运行小海龟" class="headerlink" title="测试安装是否成功，运行小海龟"></a>测试安装是否成功，运行小海龟</h3><h4 id="先运行一个小海龟节点"><a href="#先运行一个小海龟节点" class="headerlink" title="先运行一个小海龟节点"></a>先运行一个小海龟节点</h4><blockquote><h3 id="ros2-run-turtlesim-turtlesim-node"><a href="#ros2-run-turtlesim-turtlesim-node" class="headerlink" title="$ ros2 run turtlesim turtlesim_node"></a>$ ros2 run turtlesim turtlesim_node</h3></blockquote><h4 id="新建一个命令框运行另外一个节点，与前一个节点通信，从而通过键盘来控制小海龟移动"><a href="#新建一个命令框运行另外一个节点，与前一个节点通信，从而通过键盘来控制小海龟移动" class="headerlink" title="新建一个命令框运行另外一个节点，与前一个节点通信，从而通过键盘来控制小海龟移动"></a>新建一个命令框运行另外一个节点，与前一个节点通信，从而通过键盘来控制小海龟移动</h4><blockquote><h3 id="ros2-run-turtlesim-turtle-teleop-key"><a href="#ros2-run-turtlesim-turtle-teleop-key" class="headerlink" title="$ ros2 run turtlesim turtle_teleop_key"></a>$ ros2 run turtlesim turtle_teleop_key</h3></blockquote><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_1.png" alt="pic"></p><h4 id="此时可以再新建一个命令框，执行"><a href="#此时可以再新建一个命令框，执行" class="headerlink" title="此时可以再新建一个命令框，执行"></a>此时可以再新建一个命令框，执行</h4><blockquote><h3 id="rqt"><a href="#rqt" class="headerlink" title="$ rqt"></a>$ rqt</h3></blockquote><h3 id="点击-plugins-introspection-node-graph，就可以看到当前两个节点之间的通信情况了"><a href="#点击-plugins-introspection-node-graph，就可以看到当前两个节点之间的通信情况了" class="headerlink" title="点击 plugins -&gt; introspection -&gt; node graph，就可以看到当前两个节点之间的通信情况了"></a>点击 plugins -&gt; introspection -&gt; node graph，就可以看到当前两个节点之间的通信情况了</h3><h3 id="teleop-turtle-通过-turtle1-cmd-vel-对-turtlesim-进行控制"><a href="#teleop-turtle-通过-turtle1-cmd-vel-对-turtlesim-进行控制" class="headerlink" title="teleop_turtle 通过 &#x2F;turtle1&#x2F;cmd_vel 对 turtlesim 进行控制"></a>teleop_turtle 通过 &#x2F;turtle1&#x2F;cmd_vel 对 turtlesim 进行控制</h3><p><img src="http://picbed.yanzu.tech/img/learn_ros2/pic_2.png" alt="pic"></p><h3 id="ros2-run-turtlesim-turtlesim-node-这条命令是什么意思，又是如何执行的？"><a href="#ros2-run-turtlesim-turtlesim-node-这条命令是什么意思，又是如何执行的？" class="headerlink" title="ros2 run turtlesim turtlesim_node 这条命令是什么意思，又是如何执行的？"></a>ros2 run turtlesim turtlesim_node 这条命令是什么意思，又是如何执行的？</h3><blockquote><h3 id="首先，-ros2-run-会找到一个环境变量-AMENT-PREFIX-PATH，可能有多个值，多值就循环遍历"><a href="#首先，-ros2-run-会找到一个环境变量-AMENT-PREFIX-PATH，可能有多个值，多值就循环遍历" class="headerlink" title="首先， ros2 run 会找到一个环境变量 AMENT_PREFIX_PATH，可能有多个值，多值就循环遍历"></a>首先， ros2 run 会找到一个环境变量 AMENT_PREFIX_PATH，可能有多个值，多值就循环遍历</h3><h3 id="接着，在这个环境变量对应的路径下去找-lib-文件，找到后再在其目录下找-turtlesim-包"><a href="#接着，在这个环境变量对应的路径下去找-lib-文件，找到后再在其目录下找-turtlesim-包" class="headerlink" title="接着，在这个环境变量对应的路径下去找 lib 文件，找到后再在其目录下找 turtlesim 包"></a>接着，在这个环境变量对应的路径下去找 lib 文件，找到后再在其目录下找 turtlesim 包</h3><h3 id="找到对应的包之后，在其目录下找到可执行文件-turtlesim-node，然后执行"><a href="#找到对应的包之后，在其目录下找到可执行文件-turtlesim-node，然后执行" class="headerlink" title="找到对应的包之后，在其目录下找到可执行文件 turtlesim_node，然后执行"></a>找到对应的包之后，在其目录下找到可执行文件 turtlesim_node，然后执行</h3><h3 id="那么可以直接使用以下命令代替执行对应的可执行文件"><a href="#那么可以直接使用以下命令代替执行对应的可执行文件" class="headerlink" title="那么可以直接使用以下命令代替执行对应的可执行文件"></a>那么可以直接使用以下命令代替执行对应的可执行文件</h3><h3 id="但只能是-AMENT-PREFIX-PATH-opt-ros-humble-的情况下才能这么执行"><a href="#但只能是-AMENT-PREFIX-PATH-opt-ros-humble-的情况下才能这么执行" class="headerlink" title="(但只能是 AMENT_PREFIX_PATH&#x3D;&#x2F;opt&#x2F;ros&#x2F;humble 的情况下才能这么执行)"></a>(但只能是 AMENT_PREFIX_PATH&#x3D;&#x2F;opt&#x2F;ros&#x2F;humble 的情况下才能这么执行)</h3><h3 id="AMENT-PREFIX-PATH-lib-turtlesim-turtlesim-node"><a href="#AMENT-PREFIX-PATH-lib-turtlesim-turtlesim-node" class="headerlink" title="$ $AMENT_PREFIX_PATH&#x2F;lib&#x2F;turtlesim&#x2F;turtlesim_node"></a>$ $AMENT_PREFIX_PATH&#x2F;lib&#x2F;turtlesim&#x2F;turtlesim_node</h3></blockquote><h3 id="修改环境变量，-export-环境变量名-path"><a href="#修改环境变量，-export-环境变量名-path" class="headerlink" title="修改环境变量， export 环境变量名&#x3D;path"></a>修改环境变量， export 环境变量名&#x3D;path</h3><blockquote><h3 id="export-AMENT-PREFIX-PATH-opt-ros"><a href="#export-AMENT-PREFIX-PATH-opt-ros" class="headerlink" title="export AMENT_PREFIX_PATH&#x3D;&#x2F;opt&#x2F;ros"></a>export AMENT_PREFIX_PATH&#x3D;&#x2F;opt&#x2F;ros</h3></blockquote><h3 id="在-linux-中，以-点-如-a-txt-开头的文件或文件夹是隐藏文件"><a href="#在-linux-中，以-点-如-a-txt-开头的文件或文件夹是隐藏文件" class="headerlink" title="在 linux 中，以 点(如 .a.txt) 开头的文件或文件夹是隐藏文件"></a>在 linux 中，以 点(如 .a.txt) 开头的文件或文件夹是隐藏文件</h3><blockquote><h3 id="查看当前目录下的所有文件，包括隐藏文件"><a href="#查看当前目录下的所有文件，包括隐藏文件" class="headerlink" title="查看当前目录下的所有文件，包括隐藏文件"></a>查看当前目录下的所有文件，包括隐藏文件</h3><h3 id="ls-a"><a href="#ls-a" class="headerlink" title="$ ls -a"></a>$ ls -a</h3></blockquote><h3 id="只要一打开终端，就会默认启动一个脚本-bashrc，他会设置一系列的环境变量"><a href="#只要一打开终端，就会默认启动一个脚本-bashrc，他会设置一系列的环境变量" class="headerlink" title="只要一打开终端，就会默认启动一个脚本 .bashrc，他会设置一系列的环境变量"></a>只要一打开终端，就会默认启动一个脚本 .bashrc，他会设置一系列的环境变量</h3>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
